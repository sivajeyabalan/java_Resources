## 1. Topic Overview

Wrapper classes provide rich utility methods for parsing, converting, comparing, and manipulating primitive values. Key method categories include: parsing methods (`parseXxx`), factory methods (`valueOf`), conversion methods (`toString`, `xxxValue`), comparison methods (`compare`, `compareTo`), and constant fields (`MAX_VALUE`, `MIN_VALUE`). These methods eliminate the need for custom utility code and provide standardized, optimized implementations.

## 2. Topic Definition

- **What**: Static and instance methods in wrapper classes for common operations on primitive values
- **Why**: Provide standardized, optimized utilities; eliminate boilerplate code; support parsing from strings and formatting to strings
- **How**: Static methods for parsing/conversion, instance methods for object operations, constants for boundary values
- **When/Where**: String-to-number conversion, number formatting, value comparisons, boundary checking, radix conversions
- **What If**:
  - Parsing invalid strings throws NumberFormatException
  - Overflow/underflow in parsing may wrap around or throw exceptions
  - Some methods return primitives, others return wrapper objects
- **Examples**:
  - `Integer.parseInt("123")` → 123 (primitive)
  - `Integer.valueOf("123")` → Integer object
  - `Integer.toString(255, 16)` → "ff" (hex)

## 3. Deep Dive with Examples

```java
// File: WrapperMethodsDemo.java
import java.util.*;

public class WrapperMethodsDemo {
    public static void main(String[] args) {
        demonstrateParsingMethods();
        demonstrateValueOfMethods();
        demonstrateConversionMethods();
        demonstrateComparisonMethods();
        demonstrateConstantsAndUtilities();
        demonstrateAdvancedFeatures();
    }
    
    static void demonstrateParsingMethods() {
        System.out.println("=== Parsing Methods ===");
        
        // Basic parsing (returns primitives)
        int decimal = Integer.parseInt("123");
        long longVal = Long.parseLong("9876543210");
        double doubleVal = Double.parseDouble("3.14159");
        boolean boolVal = Boolean.parseBoolean("true");
        
        System.out.printf("Parsed: %d, %d, %.3f, %b%n", decimal, longVal, doubleVal, boolVal);
        
        // Radix parsing
        int binary = Integer.parseInt("1010", 2);      // 10 in decimal
        int hex = Integer.parseInt("FF", 16);          // 255 in decimal
        int octal = Integer.parseInt("77", 8);         // 63 in decimal
        
        System.out.printf("Radix parsing: binary=%d, hex=%d, octal=%d%n", binary, hex, octal);
        
        // Error handling
        try {
            int invalid = Integer.parseInt("not_a_number");
        } catch (NumberFormatException e) {
            System.out.println("Caught NumberFormatException: " + e.getMessage());
        }
        
        // Boundary cases
        try {
            int overflow = Integer.parseInt("2147483648"); // MAX_VALUE + 1
        } catch (NumberFormatException e) {
            System.out.println("Integer overflow: " + e.getMessage());
        }
    }
    
    static void demonstrateValueOfMethods() {
        System.out.println("\n=== valueOf Methods ===");
        
        // valueOf returns wrapper objects (may use caching)
        Integer intObj1 = Integer.valueOf("456");
        Integer intObj2 = Integer.valueOf(456);
        Long longObj = Long.valueOf("123456789");
        
        // Radix support
        Integer hexObj = Integer.valueOf("A0", 16);    // 160 in decimal
        
        System.out.printf("valueOf objects: %s, %s, %s, %s%n", 
                         intObj1, intObj2, longObj, hexObj);
        
        // Caching demonstration
        Integer cached1 = Integer.valueOf(100);
        Integer cached2 = Integer.valueOf(100);
        Integer notCached1 = Integer.valueOf(200);
        Integer notCached2 = Integer.valueOf(200);
        
        System.out.println("Cached objects same reference: " + (cached1 == cached2));
        System.out.println("Non-cached objects same reference: " + (notCached1 == notCached2));
        System.out.println("But values are equal: " + notCached1.equals(notCached2));
    }
    
    static void demonstrateConversionMethods() {
        System.out.println("\n=== Conversion Methods ===");
        
        Integer num = 255;
        
        // toString variations
        String decimal = num.toString();                    // "255"
        String hex = Integer.toString(num, 16);            // "ff"
        String binary = Integer.toString(num, 2);          // "11111111"
        String octal = Integer.toString(num, 8);           // "377"
        
        System.out.printf("255 in different bases: dec=%s, hex=%s, bin=%s, oct=%s%n",
                         decimal, hex, binary, octal);
        
        // toHexString, toBinaryString, toOctalString
        System.out.println("Hex string: " + Integer.toHexString(255));
        System.out.println("Binary string: " + Integer.toBinaryString(255));
        System.out.println("Octal string: " + Integer.toOctalString(255));
        
        // xxxValue methods (unboxing alternatives)
        Double doubleWrapper = 42.7;
        int asInt = doubleWrapper.intValue();              // 42 (truncated)
        long asLong = doubleWrapper.longValue();           // 42L
        float asFloat = doubleWrapper.floatValue();        // 42.7f
        byte asByte = doubleWrapper.byteValue();           // 42 (truncated)
        
        System.out.printf("42.7 as: int=%d, long=%d, float=%.1f, byte=%d%n",
                         asInt, asLong, asFloat, asByte);
    }
    
    static void demonstrateComparisonMethods() {
        System.out.println("\n=== Comparison Methods ===");
        
        // Static compare methods (returns -1, 0, or 1)
        System.out.println("Integer.compare(10, 20): " + Integer.compare(10, 20));     // -1
        System.out.println("Integer.compare(20, 10): " + Integer.compare(20, 10));     // 1
        System.out.println("Integer.compare(15, 15): " + Integer.compare(15, 15));     // 0
        
        // Instance compareTo method
        Integer a = 100;
        Integer b = 200;
        System.out.println("a.compareTo(b): " + a.compareTo(b));                       // -1
        
        // Useful for sorting
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        numbers.sort(Integer::compareTo);
        System.out.println("Sorted: " + numbers);
        
        // compareUnsigned for treating as unsigned values
        int negative = -1;  // 0xFFFFFFFF as unsigned = 4294967295
        int positive = 1;
        System.out.println("Signed compare(-1, 1): " + Integer.compare(negative, positive));         // -1
        System.out.println("Unsigned compare(-1, 1): " + Integer.compareUnsigned(negative, positive)); // 1
    }
    
    static void demonstrateConstantsAndUtilities() {
        System.out.println("\n=== Constants and Utilities ===");
        
        // Boundary constants
        System.out.println("Integer.MAX_VALUE: " + Integer.MAX_VALUE);
        System.out.println("Integer.MIN_VALUE: " + Integer.MIN_VALUE);
        System.out.println("Integer.SIZE: " + Integer.SIZE + " bits");
        System.out.println("Integer.BYTES: " + Integer.BYTES + " bytes");
        
        // Type information
        System.out.println("Integer.TYPE: " + Integer.TYPE);                    // int.class
        
        // Utility methods
        System.out.println("Integer.signum(-42): " + Integer.signum(-42));      // -1
        System.out.println("Integer.signum(0): " + Integer.signum(0));          // 0
        System.out.println("Integer.signum(42): " + Integer.signum(42));        // 1
        
        // Bit manipulation utilities
        System.out.println("Integer.highestOneBit(12): " + Integer.highestOneBit(12));      // 8
        System.out.println("Integer.lowestOneBit(12): " + Integer.lowestOneBit(12));        // 4
        System.out.println("Integer.bitCount(15): " + Integer.bitCount(15));                // 4
        System.out.println("Integer.reverse(1): " + Integer.reverse(1));                    // -2147483648
        
        // Hash code
        System.out.println("Integer.hashCode(42): " + Integer.hashCode(42));
    }
    
    static void demonstrateAdvancedFeatures() {
        System.out.println("\n=== Advanced Features ===");
        
        // decode method (handles 0x, 0, # prefixes)
        Integer hexDecoded = Integer.decode("0xFF");        // 255
        Integer octalDecoded = Integer.decode("077");       // 63
        Integer decimalDecoded = Integer.decode("123");     // 123
        
        System.out.printf("Decoded: hex=%d, octal=%d, decimal=%d%n",
                         hexDecoded, octalDecoded, decimalDecoded);
        
        // getInteger system property method
        Integer sysProp = Integer.getInteger("java.version.major", 11);
        System.out.println("Java major version (or default 11): " + sysProp);
        
        // Unsigned operations (Java 8+)
        int unsigned1 = Integer.parseUnsignedInt("4294967295");  // Would overflow signed
        String unsignedStr = Integer.toUnsignedString(-1);       // "4294967295"
        
        System.out.println("Unsigned string of -1: " + unsignedStr);
        
        // divideUnsigned and remainderUnsigned
        int quotient = Integer.divideUnsigned(-2, 2);           // Treats -2 as large positive
        int remainder = Integer.remainderUnsigned(-2, 3);
        
        System.out.printf("Unsigned division: quotient=%d, remainder=%d%n", quotient, remainder);
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use `valueOf` instead of constructors for better performance (caching)
- Handle `NumberFormatException` when parsing user input
- Use appropriate radix for the expected input format
- Prefer `compare` methods over manual comparison logic
- Use constants like `MAX_VALUE` instead of hardcoding limits

**Don'ts:**
- Don't ignore overflow possibilities when parsing
- Don't use deprecated constructors like `new Integer()`
- Don't assume all `valueOf` calls return cached instances
- Don't mix signed and unsigned operations without understanding implications

**Common Pitfalls:**
- Forgetting that `parseInt` returns primitive, `valueOf` returns object
- Not handling `NumberFormatException` in production code
- Assuming radix 10 when input might be in different base
- Using `==` to compare `valueOf` results outside cached range
- Overflow/underflow in parsing large numbers

## 5. Summary

- Parsing methods (`parseXxx`) convert strings to primitives with optional radix support
- Factory methods (`valueOf`) create wrapper objects with potential caching benefits
- Conversion methods support multiple number bases and cross-type conversions
- Comparison methods provide standardized ordering and unsigned arithmetic
- Constants and utilities offer boundary values and bit manipulation helpers
- Always handle `NumberFormatException` and consider overflow scenarios
- Prefer factory methods over constructors for better performance

## 6. Tricky Interview Questions

1. **Method Selection**: What's the difference between `Integer.parseInt("123")` and `Integer.valueOf("123")`? When would you use each?

2. **Radix Confusion**: What will `Integer.parseInt("123", 8)` return and why? What about `Integer.parseInt("189", 8)`?

3. **Caching Behavior**: Explain why this code behaves differently:
   ```java
   Integer a = Integer.valueOf(127);
   Integer b = Integer.valueOf(127);
   Integer c = Integer.valueOf(128);
   Integer d = Integer.valueOf(128);
   System.out.println((a == b) + " " + (c == d));
   ```

4. **Overflow Handling**: How does `Integer.parseInt("2147483648")` behave? How would you safely parse potentially large numbers?

5. **Unsigned Operations**: What's the output and why?
   ```java
   System.out.println(Integer.compare(-1, 1));
   System.out.println(Integer.compareUnsigned(-1, 1));
   ```

6. **Decode Method**: What values will these return?
   ```java
   Integer.decode("0xFF");
   Integer.decode("077");
   Integer.decode("#FF");
   ```

7. **Performance Trap**: Identify the performance issue in this parsing loop:
   ```java
   List<String> numbers = Arrays.asList("1", "2", "3", "4", "5");
   List<Integer> parsed = new ArrayList<>();
   for (String s : numbers) {
       parsed.add(new Integer(s));  // What's wrong here?
   }
   ```

8. **Bit Manipulation**: What do these methods return for input 12 (binary: 1100)?
   ```java
   Integer.highestOneBit(12);
   Integer.lowestOneBit(12);
   Integer.bitCount(12);
   ```
