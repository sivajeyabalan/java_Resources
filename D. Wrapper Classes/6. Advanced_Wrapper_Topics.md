## 1. Topic Overview

Advanced wrapper class topics include unsigned arithmetic operations, bit manipulation utilities, system property integration, number format parsing with locale support, and performance optimization techniques. Java 8+ introduced unsigned operations for Integer and Long, while wrapper classes provide extensive bit manipulation methods. Understanding these advanced features enables efficient numeric processing, system configuration handling, and cross-platform compatibility in enterprise applications.

## 2. Topic Definition

- **What**: Advanced features like unsigned arithmetic, bit operations, system properties, locale-aware parsing, and optimization techniques
- **Why**: Handle edge cases, improve performance, support internationalization, work with system configurations, and perform low-level operations
- **How**: Use specialized methods like `divideUnsigned`, bit manipulation utilities, `getInteger` for properties, locale-specific parsing
- **When/Where**: Cryptographic operations, system utilities, international applications, performance-critical code, bit-level algorithms
- **What If**:
  - Unsigned operations treat negative numbers as large positive values
  - Bit manipulation can optimize certain algorithms significantly
  - Locale-specific parsing handles different number formats globally
  - System property integration enables runtime configuration
- **Examples**:
  - `Integer.divideUnsigned(-2, 2)` treats -2 as 4294967294
  - `Integer.bitCount(15)` returns 4 (number of 1-bits)
  - `NumberFormat.getInstance(Locale.FRANCE).parse("1 234,56")`

## 3. Deep Dive with Examples

```java
// File: AdvancedWrapperDemo.java
import java.text.*;
import java.util.*;
import java.math.*;

public class AdvancedWrapperDemo {
    public static void main(String[] args) {
        demonstrateUnsignedOperations();
        demonstrateBitManipulation();
        demonstrateSystemProperties();
        demonstrateLocaleAwareParsing();
        demonstratePerformanceOptimizations();
        demonstrateAdvancedConversions();
        demonstrateEdgeCases();
    }
    
    static void demonstrateUnsignedOperations() {
        System.out.println("=== Unsigned Operations ===");
        
        // Unsigned arithmetic (Java 8+)
        int negative = -1;  // 0xFFFFFFFF = 4294967295 unsigned
        int positive = 2;
        
        // Signed vs unsigned division
        System.out.println("Signed division (-1 / 2): " + (negative / positive));                    // -1
        System.out.println("Unsigned division (-1 / 2): " + Integer.divideUnsigned(negative, positive)); // 2147483647
        
        // Signed vs unsigned remainder
        System.out.println("Signed remainder (-1 % 3): " + (negative % 3));                         // -1
        System.out.println("Unsigned remainder (-1 % 3): " + Integer.remainderUnsigned(negative, 3)); // 2
        
        // Unsigned comparison
        System.out.println("Signed compare(-1, 1): " + Integer.compare(negative, 1));               // -1
        System.out.println("Unsigned compare(-1, 1): " + Integer.compareUnsigned(negative, 1));     // 1
        
        // Unsigned string conversion
        System.out.println("Signed toString(-1): " + Integer.toString(negative));                   // "-1"
        System.out.println("Unsigned toString(-1): " + Integer.toUnsignedString(negative));         // "4294967295"
        
        // Unsigned parsing
        try {
            int parsed = Integer.parseUnsignedInt("4294967295");
            System.out.println("Parsed unsigned: " + parsed);                                       // -1 (as signed)
            System.out.println("As unsigned string: " + Integer.toUnsignedString(parsed));          // "4294967295"
        } catch (NumberFormatException e) {
            System.out.println("Parse error: " + e.getMessage());
        }
        
        // Long unsigned operations
        long negativeLong = -1L;
        System.out.println("Unsigned long (-1): " + Long.toUnsignedString(negativeLong));           // "18446744073709551615"
        
        // Practical example: handling unsigned 32-bit values from C/native code
        demonstrateUnsignedUseCase();
    }
    
    static void demonstrateUnsignedUseCase() {
        System.out.println("\n--- Unsigned Use Case: File Size ---");
        
        // Simulating unsigned 32-bit file size from native system
        int fileSizeFromNative = -2147483648; // 0x80000000 = 2147483648 unsigned
        
        System.out.println("Raw value from native: " + fileSizeFromNative);
        System.out.println("Interpreted as signed: " + fileSizeFromNative + " bytes");
        System.out.println("Interpreted as unsigned: " + Integer.toUnsignedString(fileSizeFromNative) + " bytes");
        
        // Convert to long for safe arithmetic
        long actualFileSize = Integer.toUnsignedLong(fileSizeFromNative);
        System.out.println("Safe long value: " + actualFileSize + " bytes");
        System.out.println("In MB: " + (actualFileSize / (1024 * 1024)) + " MB");
    }
    
    static void demonstrateBitManipulation() {
        System.out.println("\n=== Bit Manipulation ===");
        
        int value = 12; // Binary: 1100
        
        // Bit counting and analysis
        System.out.printf("Value: %d (binary: %s)%n", value, Integer.toBinaryString(value));
        System.out.println("Bit count (number of 1s): " + Integer.bitCount(value));               // 2
        System.out.println("Highest one bit: " + Integer.highestOneBit(value));                   // 8 (1000)
        System.out.println("Lowest one bit: " + Integer.lowestOneBit(value));                     // 4 (0100)
        System.out.println("Leading zeros: " + Integer.numberOfLeadingZeros(value));              // 28
        System.out.println("Trailing zeros: " + Integer.numberOfTrailingZeros(value));            // 2
        
        // Bit rotation and reversal
        int rotated = Integer.rotateLeft(value, 2);
        System.out.printf("Rotate left by 2: %d (binary: %s)%n", rotated, Integer.toBinaryString(rotated));
        
        int reversed = Integer.reverse(value);
        System.out.printf("Bit reverse: %d (binary: %s)%n", reversed, Integer.toBinaryString(reversed));
        
        int byteReversed = Integer.reverseBytes(value);
        System.out.printf("Byte reverse: %d (binary: %s)%n", byteReversed, Integer.toBinaryString(byteReversed));
        
        // Practical bit manipulation examples
        demonstrateBitManipulationUseCases();
    }
    
    static void demonstrateBitManipulationUseCases() {
        System.out.println("\n--- Bit Manipulation Use Cases ---");
        
        // 1. Power of 2 checking
        int[] testValues = {1, 2, 3, 4, 8, 15, 16, 32};
        for (int val : testValues) {
            boolean isPowerOf2 = (val > 0) && (val & (val - 1)) == 0;
            // Alternative using bit manipulation utilities
            boolean isPowerOf2Alt = (val > 0) && Integer.bitCount(val) == 1;
            System.out.printf("%d is power of 2: %b (method 2: %b)%n", val, isPowerOf2, isPowerOf2Alt);
        }
        
        // 2. Flag manipulation (bit sets)
        int flags = 0;
        final int FLAG_READ = 1;    // 001
        final int FLAG_WRITE = 2;   // 010
        final int FLAG_EXECUTE = 4; // 100
        
        // Set flags
        flags |= FLAG_READ | FLAG_WRITE;
        System.out.printf("Flags after setting READ|WRITE: %s%n", Integer.toBinaryString(flags));
        
        // Check flags
        boolean canRead = (flags & FLAG_READ) != 0;
        boolean canExecute = (flags & FLAG_EXECUTE) != 0;
        System.out.printf("Can read: %b, Can execute: %b%n", canRead, canExecute);
        
        // Clear flag
        flags &= ~FLAG_WRITE;
        System.out.printf("Flags after clearing WRITE: %s%n", Integer.toBinaryString(flags));
        
        // 3. Fast multiplication/division by powers of 2
        int number = 100;
        int multiplyBy8 = number << 3;  // Multiply by 2^3 = 8
        int divideBy4 = number >> 2;    // Divide by 2^2 = 4
        System.out.printf("%d * 8 = %d, %d / 4 = %d%n", number, multiplyBy8, number, divideBy4);
    }
    
    static void demonstrateSystemProperties() {
        System.out.println("\n=== System Properties Integration ===");
        
        // Reading system properties with defaults
        Integer javaVersion = Integer.getInteger("java.version.major", 8);
        Integer customProperty = Integer.getInteger("app.max.connections", 100);
        
        System.out.println("Java major version: " + javaVersion);
        System.out.println("Max connections (default): " + customProperty);
        
        // Setting and reading custom properties
        System.setProperty("app.timeout.seconds", "30");
        Integer timeout = Integer.getInteger("app.timeout.seconds");
        System.out.println("App timeout: " + timeout + " seconds");
        
        // Boolean system properties
        Boolean debugMode = Boolean.getBoolean("app.debug.enabled");
        System.out.println("Debug mode: " + debugMode);
        
        // Long system properties
        Long maxMemory = Long.getLong("app.max.memory.mb", 512L);
        System.out.println("Max memory: " + maxMemory + " MB");
        
        // Practical configuration example
        demonstrateConfigurationPattern();
    }
    
    static void demonstrateConfigurationPattern() {
        System.out.println("\n--- Configuration Pattern ---");
        
        // Application configuration using system properties
        class AppConfig {
            private final int maxThreads;
            private final long cacheSize;
            private final boolean enableMetrics;
            
            public AppConfig() {
                // Read from system properties with sensible defaults
                this.maxThreads = Integer.getInteger("app.threads.max", 
                                  Runtime.getRuntime().availableProcessors());
                this.cacheSize = Long.getLong("app.cache.size.mb", 64L) * 1024 * 1024;
                this.enableMetrics = Boolean.getBoolean("app.metrics.enabled");
            }
            
            @Override
            public String toString() {
                return String.format("AppConfig{maxThreads=%d, cacheSize=%d bytes, enableMetrics=%b}",
                                   maxThreads, cacheSize, enableMetrics);
            }
        }
        
        AppConfig config = new AppConfig();
        System.out.println("Application configuration: " + config);
        
        // Demonstrate runtime property changes
        System.setProperty("app.threads.max", "16");
        AppConfig newConfig = new AppConfig();
        System.out.println("Updated configuration: " + newConfig);
    }
    
    static void demonstrateLocaleAwareParsing() {
        System.out.println("\n=== Locale-Aware Parsing ===");
        
        try {
            // Different locale number formats
            Locale[] locales = {Locale.US, Locale.GERMANY, Locale.FRANCE, new Locale("hi", "IN")};
            double value = 1234567.89;
            
            System.out.println("Formatting " + value + " in different locales:");
            for (Locale locale : locales) {
                NumberFormat formatter = NumberFormat.getInstance(locale);
                String formatted = formatter.format(value);
                System.out.printf("  %s: %s%n", locale.getDisplayName(), formatted);
                
                // Parse back
                try {
                    Number parsed = formatter.parse(formatted);
                    System.out.printf("    Parsed back: %s%n", parsed);
                } catch (ParseException e) {
                    System.out.printf("    Parse error: %s%n", e.getMessage());
                }
            }
            
            // Currency formatting
            System.out.println("\nCurrency formatting:");
            for (Locale locale : Arrays.asList(Locale.US, Locale.GERMANY, Locale.JAPAN)) {
                NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(locale);
                String formatted = currencyFormatter.format(value);
                System.out.printf("  %s: %s%n", locale.getDisplayName(), formatted);
            }
            
            // Percentage formatting
            System.out.println("\nPercentage formatting:");
            NumberFormat percentFormatter = NumberFormat.getPercentInstance();
            System.out.println("  0.75 as percentage: " + percentFormatter.format(0.75));
            
        } catch (Exception e) {
            System.out.println("Locale parsing error: " + e.getMessage());
        }
    }
    
    static void demonstratePerformanceOptimizations() {
        System.out.println("\n=== Performance Optimizations ===");
        
        int iterations = 1_000_000;
        
        // 1. valueOf vs constructor performance
        long start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            Integer cached = Integer.valueOf(i % 256); // Many will be cached
        }
        long valueOfTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            @SuppressWarnings("deprecation")
            Integer newObj = new Integer(i % 256); // Always creates new
        }
        long constructorTime = System.nanoTime() - start;
        
        System.out.printf("valueOf: %d ns, constructor: %d ns (%.2fx slower)%n",
                         valueOfTime, constructorTime, (double)constructorTime / valueOfTime);
        
        // 2. String conversion performance
        start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            String s = Integer.toString(i);
        }
        long toStringTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            String s = String.valueOf(i);
        }
        long stringValueOfTime = System.nanoTime() - start;
        
        System.out.printf("Integer.toString: %d ns, String.valueOf: %d ns%n",
                         toStringTime, stringValueOfTime);
        
        // 3. Primitive vs wrapper arithmetic
        start = System.nanoTime();
        int primitiveSum = 0;
        for (int i = 0; i < iterations; i++) {
            primitiveSum += i;
        }
        long primitiveTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        Integer wrapperSum = 0;
        for (int i = 0; i < iterations; i++) {
            wrapperSum += i; // Boxing/unboxing overhead
        }
        long wrapperTime = System.nanoTime() - start;
        
        System.out.printf("Primitive arithmetic: %d ns, wrapper arithmetic: %d ns (%.2fx slower)%n",
                         primitiveTime, wrapperTime, (double)wrapperTime / primitiveTime);
    }
    
    static void demonstrateAdvancedConversions() {
        System.out.println("\n=== Advanced Conversions ===");
        
        // BigInteger integration
        BigInteger bigInt = new BigInteger("12345678901234567890");
        System.out.println("BigInteger: " + bigInt);
        
        // Convert to wrapper (with overflow risk)
        try {
            int intValue = bigInt.intValueExact(); // Throws if overflow
            System.out.println("Exact int conversion: " + intValue);
        } catch (ArithmeticException e) {
            System.out.println("Overflow in exact conversion: " + e.getMessage());
            int intValue = bigInt.intValue(); // Truncates
            System.out.println("Truncated int conversion: " + intValue);
        }
        
        // Hex, octal, binary conversions with validation
        String[] testStrings = {"FF", "377", "11111111", "invalid"};
        int[] radixes = {16, 8, 2, 10};
        
        for (int i = 0; i < testStrings.length; i++) {
            try {
                int parsed = Integer.parseInt(testStrings[i], radixes[i % radixes.length]);
                System.out.printf("Parsed '%s' (radix %d): %d%n", 
                                testStrings[i], radixes[i % radixes.length], parsed);
            } catch (NumberFormatException e) {
                System.out.printf("Invalid format '%s': %s%n", testStrings[i], e.getMessage());
            }
        }
        
        // Scientific notation parsing
        try {
            double scientific = Double.parseDouble("1.23E-4");
            System.out.println("Scientific notation: " + scientific);
            
            // Convert back to string in different formats
            System.out.println("Default format: " + scientific);
            System.out.printf("Fixed format: %.8f%n", scientific);
            System.out.printf("Scientific format: %e%n", scientific);
        } catch (NumberFormatException e) {
            System.out.println("Scientific parsing error: " + e.getMessage());
        }
    }
    
    static void demonstrateEdgeCases() {
        System.out.println("\n=== Edge Cases ===");
        
        // Infinity and NaN handling
        Double positiveInfinity = Double.POSITIVE_INFINITY;
        Double negativeInfinity = Double.NEGATIVE_INFINITY;
        Double notANumber = Double.NaN;
        
        System.out.println("Positive infinity: " + positiveInfinity);
        System.out.println("Negative infinity: " + negativeInfinity);
        System.out.println("NaN: " + notANumber);
        
        // Testing special values
        System.out.println("Is positive infinity finite: " + Double.isFinite(positiveInfinity));
        System.out.println("Is NaN a number: " + !Double.isNaN(notANumber));
        System.out.println("NaN equals NaN: " + notANumber.equals(Double.NaN));
        
        // Overflow behavior
        try {
            int maxInt = Integer.MAX_VALUE;
            System.out.println("MAX_VALUE: " + maxInt);
            System.out.println("MAX_VALUE + 1: " + (maxInt + 1)); // Overflow to MIN_VALUE
            
            // Safe overflow detection
            try {
                int result = Math.addExact(maxInt, 1);
                System.out.println("Safe addition result: " + result);
            } catch (ArithmeticException e) {
                System.out.println("Overflow detected: " + e.getMessage());
            }
        } catch (Exception e) {
            System.out.println("Edge case error: " + e.getMessage());
        }
        
        // Underflow in floating point
        float tiny = Float.MIN_VALUE;
        System.out.println("Float MIN_VALUE: " + tiny);
        System.out.println("MIN_VALUE / 2: " + (tiny / 2)); // Underflow to 0
        
        // Precision loss
        float precisionLoss = 16777216f + 1f; // 2^24 + 1
        System.out.println("Precision loss (16777216f + 1f): " + precisionLoss);
        System.out.println("Lost precision: " + (precisionLoss == 16777216f));
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use unsigned operations when working with data from C/native code or bit manipulation
- Leverage bit manipulation utilities for performance-critical algorithms
- Use system property integration for configurable applications
- Handle locale-specific number formats in international applications
- Choose appropriate numeric types based on range and precision requirements

**Don'ts:**
- Don't assume signed arithmetic behavior when working with unsigned data
- Don't ignore overflow/underflow possibilities in numeric operations
- Don't hardcode locale-specific number formats
- Don't use wrapper arithmetic in performance-critical loops
- Don't forget to handle NumberFormatException in parsing operations

**Common Pitfalls:**
- Misunderstanding unsigned arithmetic behavior with negative values
- Performance degradation from excessive boxing/unboxing
- Locale-dependent parsing failures in international deployments
- Precision loss in floating-point operations
- Overflow/underflow going undetected in calculations

## 5. Summary

- Unsigned operations treat integers as unsigned values, useful for interop and bit manipulation
- Bit manipulation utilities provide efficient operations for flags, powers of 2, and low-level algorithms
- System property integration enables runtime configuration through wrapper class utilities
- Locale-aware parsing supports international number formats and currencies
- Performance optimization requires understanding caching, boxing costs, and primitive alternatives
- Advanced conversions handle BigInteger integration, radix parsing, and scientific notation
- Edge cases include infinity, NaN, overflow detection, and precision loss scenarios

## 6. Tricky Interview Questions

1. **Unsigned Arithmetic**: What's the result of `Integer.divideUnsigned(-1, 2)` and why? How does this differ from regular division?

2. **Bit Manipulation**: Write a method to check if a number is a power of 2 using bit manipulation. Provide two different approaches.

3. **System Properties**: How would you create a configuration system that reads integer values from system properties with defaults? Show error handling.

4. **Performance Analysis**: Compare the performance implications of these three approaches for summing integers 1 to 1,000,000:
   ```java
   // Approach 1: primitives
   // Approach 2: wrapper with boxing/unboxing  
   // Approach 3: wrapper with manual valueOf/intValue
   ```

5. **Locale Parsing**: How would you safely parse a user-entered number that could be in any locale format? Handle both parsing errors and locale detection.

6. **Overflow Detection**: Implement a safe integer multiplication method that detects overflow without using `Math.multiplyExact()`.

7. **Bit Flags**: Design a permission system using bit flags for READ(1), WRITE(2), EXECUTE(4), DELETE(8). Implement methods to set, clear, check, and toggle permissions.

8. **Edge Cases**: What happens when you parse these strings and why?
   ```java
   Double.parseDouble("Infinity");
   Double.parseDouble("NaN"); 
   Float.parseFloat("1.7976931348623157E308");
   ```

9. **Unsigned Use Case**: You're interfacing with a C library that returns unsigned 32-bit file sizes. How do you handle values larger than `Integer.MAX_VALUE` in Java?

10. **Advanced Conversion**: Convert a `BigInteger` to an `Integer` safely, handling overflow by either throwing an exception or returning a default value based on a parameter.
