## 1. Topic Overview

Java wrapper classes are immutable objects that encapsulate primitive values so they can be used where objects are required (e.g., generics, collections, reflection, streams). Core wrappers: `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`, and `Void` (a special placeholder type). They provide utility methods for parsing, formatting, comparing, and operating on values.

## 2 . Topic definition

- **What**: Object representations of primitives; each primitive type has a corresponding wrapper class.
- **Why**: Required for APIs that work with objects only (collections/generics), to access utility methods (`parseX`, `valueOf`, `compare`, constants), and to represent nullable primitives.
- **How**: Create via constructors (discouraged) or factory methods like `valueOf` and parsing methods like `parseInt`. Java also performs autoboxing/unboxing between primitives and wrappers.
- **When/Where**: Use in collections (`List<Integer>`), optional/nullable settings, method references, or when utility helpers are needed.
- **What if**:
  - Using wrappers in tight loops can add allocation overhead; prefer primitives when possible.
  - Unboxing a `null` reference throws `NullPointerException`.
  - `==` compares object identity, not numeric equality, for wrappers; use `equals` for value equality.
- **Examples**:
  - Parsing: `Integer.parseInt("123")` → 123
  - Boxing: `Integer x = 10;` (autoboxing)
  - Unboxing: `int y = x;` (automatic unboxing)

## 3. Deep Dive with Examples

```java
// File: OverviewDemo.java
public class OverviewDemo {
    public static void main(String[] args) {
        // Construction (prefer valueOf over constructors)
        Integer a = Integer.valueOf(42);
        Integer b = 42; // autoboxing

        // Parsing and formatting
        int decimal = Integer.parseInt("255");
        int hex = Integer.parseInt("FF", 16);
        String asString = Integer.toString(255); // "255"

        // Comparisons
        System.out.println(Integer.compare(10, 20)); // -1
        System.out.println(a.equals(b));             // true

        // Beware: identity vs equality
        System.out.println(a == b); // true here due to Integer cache for small values
        Integer big1 = 1000;
        Integer big2 = 1000;
        System.out.println(big1 == big2); // false (different objects)

        // Nullability and unboxing risk
        Integer maybeNull = null;
        try {
            int n = maybeNull; // NullPointerException
        } catch (NullPointerException e) {
            System.out.println("Unboxing NPE: " + e.getClass().getSimpleName());
        }

        // Collections require objects
        java.util.List<Integer> numbers = new java.util.ArrayList<>();
        numbers.add(1); // autoboxing
        numbers.add(2);
        int sum = 0;
        for (int val : numbers) { // unboxing in the enhanced for-loop
            sum += val;
        }
        System.out.println("sum=" + sum);
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer `valueOf` over constructors; it may return cached instances.
- Use `equals` (not `==`) to compare numeric wrapper values; reserve `==` for identity checks.
- Guard against unboxing `null`; use `Objects.requireNonNullElse` or ternaries.
- Avoid excessive boxing in performance-critical code; keep primitives in hot paths.
- Understand caching: `Integer`, `Short`, `Byte`, `Character` (0–127), and `Long` cache small values.
- Use `parseX` for primitives, `valueOf` when you need wrapper objects.

## 5. Summary

- Wrappers adapt primitives to object-oriented Java APIs.
- They are immutable and provide rich utility methods.
- Autoboxing/unboxing is convenient but can hide performance and NPE traps.
- Use value-based comparisons and be mindful of caches.

## 6. Tricky Interview Questions

1. For which value ranges does `Integer.valueOf` return cached objects by default? Can it be tuned?
2. Why can `Integer a = 127; Integer b = 127; a == b` be true but `a == 128` be false when compared to another `128` wrapper?
3. Difference between `Integer.parseInt` and `Integer.valueOf`? When to use which?
4. Can autoboxing introduce hidden allocations in loops? How to avoid?
5. What happens when unboxing `null`? Show a defensive pattern to avoid this.
6. Is `Void` instantiable? What is it used for?
7. Why is using wrappers as map keys sometimes risky with `==`? Show the correct approach.
8. How do wrappers participate in generics and why primitives cannot?


