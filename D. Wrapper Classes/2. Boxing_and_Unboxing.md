## 1. Topic Overview

Boxing and unboxing are automatic conversions between primitive types and their corresponding wrapper classes. Boxing converts a primitive to its wrapper object, while unboxing extracts the primitive value from a wrapper. Java performs these conversions automatically (autoboxing/auto-unboxing) when needed, making code more readable but potentially hiding performance implications and null pointer risks.

## 2. Topic Definition

- **What**: Boxing = primitive → wrapper object; Unboxing = wrapper object → primitive value
- **Why**: Enables seamless integration between primitive-based and object-based APIs without explicit conversions
- **How**: Compiler automatically inserts `valueOf()` calls for boxing and `xxxValue()` calls for unboxing
- **When/Where**: Collections, generics, method parameters expecting objects, conditional expressions mixing types
- **What If**: 
  - Excessive boxing in loops creates garbage collection pressure
  - Unboxing null wrappers throws NullPointerException
  - Identity comparisons (==) on boxed values can be unpredictable
- **Examples**:
  - Boxing: `Integer x = 5;` → `Integer x = Integer.valueOf(5);`
  - Unboxing: `int y = x;` → `int y = x.intValue();`

## 3. Deep Dive with Examples

```java
// File: BoxingUnboxingDemo.java
import java.util.*;

public class BoxingUnboxingDemo {
    public static void main(String[] args) {
        // Manual boxing (old way)
        Integer manualBox = Integer.valueOf(100);
        
        // Autoboxing (compiler does valueOf automatically)
        Integer autoBox = 100; // Integer.valueOf(100)
        
        // Manual unboxing (old way)
        int manualUnbox = manualBox.intValue();
        
        // Auto-unboxing (compiler does intValue automatically)
        int autoUnbox = autoBox; // autoBox.intValue()
        
        System.out.println("Boxing/Unboxing basic operations completed");
        
        // Collections demonstrate autoboxing
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);    // autoboxing: Integer.valueOf(1)
        numbers.add(2);    // autoboxing: Integer.valueOf(2)
        numbers.add(3);    // autoboxing: Integer.valueOf(3)
        
        int sum = 0;
        for (Integer num : numbers) {
            sum += num;    // auto-unboxing: num.intValue()
        }
        System.out.println("Sum: " + sum);
        
        // Mixed expressions trigger boxing/unboxing
        Integer wrapped = 50;
        int result = wrapped + 25; // unbox wrapped, add, result is primitive
        Integer finalResult = result + wrapped; // unbox wrapped, add, box result
        
        // Conditional expressions with mixed types
        boolean condition = true;
        Integer conditionalResult = condition ? 42 : new Integer(0); // both sides become Integer
        
        // Performance implications in loops
        demonstratePerformanceImpact();
        
        // Null pointer risks
        demonstrateNullRisks();
        
        // Caching behavior affects identity
        demonstrateCachingBehavior();
    }
    
    static void demonstratePerformanceImpact() {
        System.out.println("\n--- Performance Impact Demo ---");
        
        // BAD: Creates many Integer objects
        long start = System.nanoTime();
        Integer sum = 0;
        for (int i = 0; i < 100000; i++) {
            sum += i; // unbox sum, add i, box result back to sum
        }
        long badTime = System.nanoTime() - start;
        
        // GOOD: Uses primitive throughout
        start = System.nanoTime();
        int primitiveSum = 0;
        for (int i = 0; i < 100000; i++) {
            primitiveSum += i;
        }
        long goodTime = System.nanoTime() - start;
        
        System.out.printf("Wrapper loop: %d ns, Primitive loop: %d ns%n", badTime, goodTime);
        System.out.printf("Wrapper is %.2fx slower%n", (double)badTime / goodTime);
    }
    
    static void demonstrateNullRisks() {
        System.out.println("\n--- Null Pointer Risks ---");
        
        Integer nullInteger = null;
        
        try {
            int value = nullInteger; // NullPointerException on unboxing
        } catch (NullPointerException e) {
            System.out.println("NPE during unboxing: " + e.getMessage());
        }
        
        // Safe approaches
        int safeValue1 = (nullInteger != null) ? nullInteger : 0;
        int safeValue2 = Objects.requireNonNullElse(nullInteger, 0);
        
        System.out.println("Safe values: " + safeValue1 + ", " + safeValue2);
    }
    
    static void demonstrateCachingBehavior() {
        System.out.println("\n--- Caching Behavior ---");
        
        // Cached range (-128 to 127 for Integer)
        Integer a1 = 127;
        Integer a2 = 127;
        System.out.println("127 == 127: " + (a1 == a2)); // true (cached)
        
        Integer b1 = 128;
        Integer b2 = 128;
        System.out.println("128 == 128: " + (b1 == b2)); // false (not cached)
        
        // Always use equals for value comparison
        System.out.println("128 equals 128: " + b1.equals(b2)); // true
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use autoboxing/unboxing for cleaner, more readable code
- Always use `equals()` for value comparisons between wrappers
- Check for null before unboxing or use defensive patterns
- Prefer primitives in performance-critical loops and calculations

**Don'ts:**
- Don't rely on `==` for wrapper value comparisons outside cached ranges
- Avoid excessive boxing/unboxing in tight loops
- Don't assume all wrapper instances are cached
- Don't ignore null safety when working with wrapper collections

**Common Pitfalls:**
- Forgetting that unboxing null throws NPE
- Performance degradation from hidden boxing in loops
- Identity vs equality confusion with cached vs non-cached values
- Mixing primitive and wrapper arithmetic without understanding the conversions

## 5. Summary

- Boxing converts primitives to wrapper objects; unboxing does the reverse
- Java performs these conversions automatically for convenience
- Autoboxing uses `valueOf()`, auto-unboxing uses `xxxValue()` methods
- Performance cost: boxing creates objects, unboxing has method call overhead
- Null safety: always guard against unboxing null references
- Caching affects identity comparisons for small values
- Use `equals()` for value comparisons, primitives for performance-critical code

## 6. Tricky Interview Questions

1. **Code Analysis**: What's the output and why?
   ```java
   Integer a = 128, b = 128, c = 127, d = 127;
   System.out.println((a == b) + " " + (c == d));
   ```

2. **Performance Trap**: Identify the performance issue in this code and fix it:
   ```java
   Integer sum = 0;
   for (int i = 0; i < 1000000; i++) {
       sum += i;
   }
   ```

3. **NPE Scenario**: When will this throw NullPointerException and how to prevent it?
   ```java
   List<Integer> list = Arrays.asList(1, null, 3);
   int total = list.stream().mapToInt(x -> x).sum();
   ```

4. **Conditional Expression**: What type is `result` and why?
   ```java
   boolean flag = true;
   var result = flag ? 42 : new Double(3.14);
   ```

5. **Method Overloading**: Which method gets called and why?
   ```java
   void process(int x) { System.out.println("primitive"); }
   void process(Integer x) { System.out.println("wrapper"); }
   process(42);
   ```

6. **Caching Boundaries**: How can you verify the exact caching range for Integer on your JVM?

7. **Collection Behavior**: Explain why this might behave unexpectedly:
   ```java
   Set<Integer> set = new HashSet<>();
   set.add(new Integer(42));
   set.add(42);
   System.out.println(set.size());
   ```

8. **Ternary Operator**: What happens during compilation of this expression?
   ```java
   Integer x = condition ? null : 0;
   ```
