## 1. Topic Overview

Hibernate tracks entity instances through states: transient, persistent, detached, and removed. CRUD operations transition entities between these states.

## 2 . Topic definition

- **Transient**: New object, not associated with a session.
- **Persistent**: Managed by a session; changes auto-detected (dirty checking).
- **Detached**: Was persistent but session closed/cleared.
- **Removed**: Scheduled for deletion upon flush/commit.

## 3. Deep Dive with Examples

```java
try (Session s = sf.openSession()) {
  Transaction tx = s.beginTransaction();
  User u = new User(); // transient
  s.persist(u);        // now persistent
  u.setName("Alice"); // dirty -> update at flush
  tx.commit();         // flush + commit
}

User u2;
try (Session s = sf.openSession()) {
  u2 = s.get(User.class, 1L); // persistent
}
// detached outside session
try (Session s = sf.openSession()) {
  s.beginTransaction();
  u2.setName("Bob");
  s.merge(u2);          // copy state to managed instance
  s.getTransaction().commit();
}
```

Removal:
```java
s.remove(entity); // marks for delete at flush/commit
```

## 4. Best Practices & Pitfalls

- Prefer `persist` for new entities; `merge` for updating detached graphs.
- Avoid holding sessions across layers/threads; keep units-of-work small.
- Pitfall: LazyInitializationException when accessing lazy associations after session closed.

## 5. Summary

- Understand entity states and transitions to avoid unintended SQL and exceptions.

## 6. Tricky Interview Questions

1) How does dirty checking work and when does flush occur?
2) Differences between `save`, `persist`, and `merge` in practice?
