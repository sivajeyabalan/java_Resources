## 1. Topic Overview

- The N+1 query problem occurs when fetching a parent list triggers an additional query per child collection. Hibernate offers fetching strategies to avoid it.

## 2 . Topic definition

- WHAT: N+1 = 1 query for parents + N queries for children. Fetching strategies: `JOIN FETCH`, `EntityGraph`, batch fetching, `@Fetch`(SUBSELECT).
- WHY: Prevent performance degradation and DB load.
- HOW: Use JPQL `join fetch`, named/entity graphs, `@BatchSize`, `hibernate.default_batch_fetch_size`, `@Fetch(FetchMode.SUBSELECT)`.
- WHEN/WHERE: When rendering lists with associated data; API endpoints returning aggregates.
- WHAT IF: Blind eager fetching causes huge Cartesian products; choose targeted strategies.

## 3. Deep Dive with Examples

```java
// Entities
import jakarta.persistence.*;
import org.hibernate.annotations.Fetch;
import org.hibernate.annotations.FetchMode;
import org.hibernate.annotations.BatchSize;
import java.util.*;

@Entity
class Author {
    @Id Long id; String name;
    @OneToMany(mappedBy = "author")
    @BatchSize(size = 20)
    @Fetch(FetchMode.SUBSELECT)
    List<Book> books = new ArrayList<>();
}

@Entity
class Book { @Id Long id; String title; @ManyToOne Author author; }
```

```java
// JPQL join fetch to avoid N+1 when you need authors with books
List<Author> list = em.createQuery(
  "select distinct a from Author a left join fetch a.books", Author.class)
  .getResultList();
```

```java
// EntityGraph to control attribute fetching per use case
EntityGraph<Author> graph = em.createEntityGraph(Author.class);
graph.addAttributeNodes("name");
graph.addSubgraph("books").addAttributeNodes("title");
Map<String,Object> hints = Map.of("jakarta.persistence.fetchgraph", graph);
List<Author> authors = em.createQuery("select a from Author a", Author.class)
  .setHint("jakarta.persistence.fetchgraph", graph)
  .getResultList();
```

Batch fetching config:
- Per-association: `@BatchSize(size = 20)`
- Global: `hibernate.default_batch_fetch_size=20`

## 4. Best Practices & Pitfalls

- Fetch only what the view needs; avoid blanket eager fetching.
- Use `distinct` when join fetching to prevent duplicates; de-duplicate in memory.
- Prefer pagination with fetch graphs; avoid join fetch of multiple collections.

## 5. Summary

- Combine `JOIN FETCH`, entity graphs, and batch/subselect to eliminate N+1 with controlled result sizes.

## 6. Tricky Interview Questions

1. Why can `JOIN FETCH` on multiple collections explode row counts? Alternatives?
2. Compare `@BatchSize` vs `SUBSELECT` fetching and when to choose each.

