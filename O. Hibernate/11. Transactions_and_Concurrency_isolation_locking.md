## 1. Topic Overview

Transactions ensure atomicity and consistency; concurrency control avoids lost updates and dirty reads. Hibernate integrates with JDBC/JTA transactions and supports locking.

## 2 . Topic definition

- **Isolation levels**: READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE.
- **Optimistic locking**: Version/timestamp field detects concurrent updates.
- **Pessimistic locking**: `SELECT ... FOR UPDATE`-style locks via lock modes.

## 3. Deep Dive with Examples

Optimistic lock:
```java
@Entity
class Account {
  @Id @GeneratedValue Long id;
  @Version Long version;
  BigDecimal balance;
}
```

```java
try (Session s = sf.openSession()) {
  Transaction tx = s.beginTransaction();
  Account a = s.get(Account.class, 1L);
  a.setBalance(a.getBalance().add(new BigDecimal("10")));
  tx.commit(); // Throws on stale version
}
```

Pessimistic lock:
```java
Account a = s.find(Account.class, 1L, LockModeType.PESSIMISTIC_WRITE);
```

## 4. Best Practices & Pitfalls

- Use optimistic locking by default; fall back to pessimistic for critical sections.
- Keep transactions short; avoid user think-time inside transactions.
- Pitfall: Misaligned DB isolation level vs application expectations.

## 5. Summary

- Manage isolation and locking to maintain correctness under concurrency.

## 6. Tricky Interview Questions

1) When would you choose pessimistic over optimistic locking?
2) How do retries fit into optimistic locking failures?
