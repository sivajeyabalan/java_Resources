## 1. Topic Overview

Hibernate supports configuration via XML files or programmatic properties, and mapping via annotations or XML. Bootstrap builds a `SessionFactory` using these settings and mappings.

## 2 . Topic definition

- **hibernate.cfg.xml**: Central XML config (datasource, dialect, mappings).
- **Annotations**: `@Entity`, `@Table`, `@Column`, `@Id`, `@GeneratedValue`.
- **XML mappings (hbm.xml)**: Alternative mapping file for legacy or advanced control.

## 3. Deep Dive with Examples

hibernate.cfg.xml (optional if programmatic):
```xml
<hibernate-configuration>
  <session-factory>
    <property name="hibernate.connection.url">jdbc:h2:mem:test</property>
    <property name="hibernate.hbm2ddl.auto">update</property>
    <mapping class="com.example.User"/>
  </session-factory>
</hibernate-configuration>
```

Annotated entity:
```java
@Entity @Table(name="users")
public class User { @Id @GeneratedValue Long id; @Column(nullable=false) String name; }
```

Programmatic bootstrap:
```java
StandardServiceRegistry reg = new StandardServiceRegistryBuilder()
  .applySetting("hibernate.connection.url","jdbc:h2:mem:test")
  .applySetting("hibernate.hbm2ddl.auto","update").build();
Metadata md = new MetadataSources(reg).addAnnotatedClass(User.class).buildMetadata();
SessionFactory sf = md.buildSessionFactory();
```

## 4. Best Practices & Pitfalls

- Prefer annotations for most cases; use XML when you need externalized mappings.
- Keep DDL generation (`hbm2ddl.auto`) off in production; use migrations.
- Pitfall: Mismatched dialect/driver causes subtle SQL issues.

## 5. Summary

- Configure via XML or code; map with annotations or XML; build a `SessionFactory` for use.

## 6. Tricky Interview Questions

1) When do XML mappings provide advantages over annotations?
2) Why avoid `create-drop` in non-test environments?
