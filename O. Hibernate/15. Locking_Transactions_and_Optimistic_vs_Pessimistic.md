## 1. Topic Overview

- Concurrency control in JPA/Hibernate: optimistic vs pessimistic locking and transaction patterns.

## 2 . Topic definition

- WHAT: Optimistic locking with `@Version`; pessimistic locks (`LockModeType.PESSIMISTIC_READ/WRITE`); transaction boundaries.
- WHY: Prevent lost updates and ensure consistency under concurrent access.
- HOW: Add version column; apply lock modes in queries; handle `OptimisticLockException` and deadlocks gracefully.
- WHEN/WHERE: High-contention updates (pessimistic) vs low-contention (optimistic).
- WHAT IF: Overusing pessimistic locks reduces throughput; ignoring version conflicts loses data.

## 3. Deep Dive with Examples

```java
import jakarta.persistence.*;

@Entity
class Account {
    @Id Long id; int balance;
    @Version long version; // optimistic lock
}
```

```java
// Optimistic update pattern with retry
boolean success = false; int attempts = 0;
while (!success && attempts++ < 3) {
  try {
    em.getTransaction().begin();
    Account a = em.find(Account.class, 1L);
    a.balance += 10;
    em.getTransaction().commit();
    success = true;
  } catch (OptimisticLockException e) {
    em.getTransaction().rollback();
  }
}
```

```java
// Pessimistic lock
Account a = em.find(Account.class, 1L, LockModeType.PESSIMISTIC_WRITE);
```

## 4. Best Practices & Pitfalls

- Prefer optimistic locking with retries; reserve pessimistic for short critical sections.
- Keep locked transactions brief; avoid user interactions while holding locks.
- Map database deadlocks/timeouts to retryable errors.

## 5. Summary

- Choose locking strategy based on contention profile; implement safe retry/timeout patterns.

## 6. Tricky Interview Questions

1. When does optimistic locking fail and how do you handle it?
2. Trade-offs between PESSIMISTIC_WRITE vs optimistic with retries.

