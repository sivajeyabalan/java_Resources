## 1. Topic Overview

Associations link entities: one-to-one, one-to-many, many-to-one, and many-to-many. Proper ownership and join configuration are key.

## 2 . Topic definition

- **Owning side**: Side that holds the foreign key; defines join columns.
- **Inverse side**: Mapped by the owning side; does not own the FK.
- **Cascade**: Propagate operations (PERSIST, MERGE, REMOVE) across associations.

## 3. Deep Dive with Examples

One-to-one:
```java
@Entity class UserProfile { @Id Long id; @OneToOne @MapsId User user; }
```

One-to-many / Many-to-one:
```java
@Entity class Dept { @Id @GeneratedValue Long id; @OneToMany(mappedBy="dept") List<Emp> emps; }
@Entity class Emp { @Id @GeneratedValue Long id; @ManyToOne(fetch=FetchType.LAZY) Dept dept; }
```

Many-to-many:
```java
@Entity class Student {
  @ManyToMany
  @JoinTable(name="student_course",
    joinColumns=@JoinColumn(name="student_id"),
    inverseJoinColumns=@JoinColumn(name="course_id"))
  Set<Course> courses;
}
```

## 4. Best Practices & Pitfalls

- Set the owning side explicitly; update both sides in code for bidirectional links.
- Avoid many-to-many in OLTP; prefer join entity (with payload) modeled as two one-to-many.
- Pitfall: Cascade REMOVE across large graphs can delete unintended data.

## 5. Summary

- Choose association types carefully; define ownership and cascading deliberately.

## 6. Tricky Interview Questions

1) How to model many-to-many with extra attributes (grade, timestamp)?
2) What goes wrong if you set `mappedBy` on the wrong side?
