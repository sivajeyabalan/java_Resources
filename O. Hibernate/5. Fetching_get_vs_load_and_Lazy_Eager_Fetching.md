## 1. Topic Overview

Fetching controls how and when Hibernate loads entities and associations. `get()` hits the DB immediately; `load()` may return a proxy. Associations can be LAZY (default) or EAGER.

## 2 . Topic definition

- **get()**: Returns entity or null; executes SQL immediately.
- **load()**: Returns proxy; DB access deferred until property access; throws if not found.
- **Lazy fetch**: Data loaded when needed.
- **Eager fetch**: Data loaded immediately with the owner.

## 3. Deep Dive with Examples

```java
User u1 = s.get(User.class, id);   // immediate select
User u2 = s.load(User.class, id);  // proxy; select on access
```

Associations:
```java
@Entity class Order {
  @ManyToOne(fetch = FetchType.LAZY) User user;
  @OneToMany(mappedBy = "order", fetch = FetchType.LAZY) List<OrderLine> lines;
}
```

Fetch join to avoid N+1:
```java
List<Order> orders = s.createQuery(
  "select o from Order o join fetch o.user", Order.class).getResultList();
```

## 4. Best Practices & Pitfalls

- Prefer lazy by default; selectively use fetch joins in queries.
- Beware EAGER on large graphs—can explode SQL and memory.
- Pitfall: Accessing lazy associations after session closed → LazyInitializationException.

## 5. Summary

- Choose `get` vs `load` intentionally; control association fetching to balance performance.

## 6. Tricky Interview Questions

1) When is a proxy created and how does it behave outside a session?
2) How do you fix N+1 without making everything EAGER?
