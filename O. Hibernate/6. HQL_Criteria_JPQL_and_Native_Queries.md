## 1. Topic Overview

Hibernate supports multiple querying options: HQL/JPQL (object-oriented), Criteria API (typesafe), and native SQL for full control.

## 2 . Topic definition

- **HQL/JPQL**: Query entities and their properties using entity names, not table names.
- **Criteria API**: Programmatic, typesafe queries built with builders and metamodel.
- **Native SQL**: Direct SQL for complex or vendor-specific features.

## 3. Deep Dive with Examples

HQL/JPQL:
```java
List<User> users = s.createQuery("from User u where u.name like :p", User.class)
  .setParameter("p", "A%")
  .getResultList();
```

Criteria (JPA):
```java
CriteriaBuilder cb = s.getCriteriaBuilder();
CriteriaQuery<User> q = cb.createQuery(User.class);
Root<User> u = q.from(User.class);
q.select(u).where(cb.like(u.get("name"), "A%"));
List<User> list = s.createQuery(q).getResultList();
```

Native SQL:
```java
List<Object[]> rows = s.createNativeQuery("select id, name from users where name like ?")
  .setParameter(1, "A%")
  .getResultList();
```

## 4. Best Practices & Pitfalls

- Prefer HQL/Criteria for portability; use native SQL when necessary.
- Use named queries for reuse and caching.
- Pitfall: Selecting large graphs inadvertently; specify projections.

## 5. Summary

- Choose HQL/JPQL for object queries, Criteria for typesafety, native SQL for special cases.

## 6. Tricky Interview Questions

1) When would you choose Criteria over HQL?
2) How do you map native query results to DTOs efficiently?
