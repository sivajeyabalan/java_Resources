## 1. Topic Overview

- Integrate Bean Validation with JPA entities and control schema generation for reliable persistence.

## 2 . Topic definition

- WHAT: Jakarta Bean Validation annotations on entities; `javax.validation` integration; schema generation (`hibernate.hbm2ddl.auto`, JPA schema generation properties).
- WHY: Enforce invariants at entity boundary; manage DDL for dev vs prod.
- HOW: Annotate fields, enable validation on persist/update; configure schema generation in properties or migration tools.
- WHEN/WHERE: Model layer; dev bootstrap vs production migrations.
- WHAT IF: Relying on auto DDL in prod is risky; validation groups may be needed for partial updates.

## 3. Deep Dive with Examples

```java
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

@Entity
class Customer {
    @Id @GeneratedValue Long id;
    @NotBlank String name;
    @Email String email;
}
```

```properties
# application.properties
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=validate # or update/create-drop in dev only
```

## 4. Best Practices & Pitfalls

- Use migrations (Flyway/Liquibase) in production; avoid schema auto-update.
- Keep validations at DTO and entity levels consistent.
- Validate associations with `@Valid` when cascading.

## 5. Summary

- Bean Validation guards data integrity; schema generation is for devâ€”use migrations for prod.

## 6. Tricky Interview Questions

1. How to handle different validation rules for create vs update?
2. Why prefer Flyway/Liquibase over Hibernate auto DDL in production?

