## 1. Topic Overview

Filters intercept requests/responses to apply cross-cutting concerns (logging, auth, compression) before reaching servlets/JSPs. Listeners observe container/application events (context/session/request lifecycle) to run code on those events.

## 2 . Topic definition

- **Filter**: Component implementing `doFilter` to pre/post-process requests and responses; chainable.
- **Listener**: Callback for lifecycle events: `ServletContextListener`, `HttpSessionListener`, `ServletRequestListener`, attribute listeners, etc.
- **Filter chain**: Ordered sequence; each filter decides to continue or short-circuit.

## 3. Deep Dive with Examples

```java
// LoggingFilter.java
@WebFilter(urlPatterns = "/*")
public class LoggingFilter implements Filter {
  public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    long start = System.currentTimeMillis();
    chain.doFilter(req, res); // continue
    System.out.println("took=" + (System.currentTimeMillis() - start) + "ms");
  }
}
```

```java
// AppContextListener.java
@WebListener
public class AppContextListener implements ServletContextListener {
  public void contextInitialized(ServletContextEvent sce) {
    sce.getServletContext().setAttribute("startedAt", System.currentTimeMillis());
  }
  public void contextDestroyed(ServletContextEvent sce) { /* cleanup */ }
}
```

## 4. Best Practices & Pitfalls

- Keep filters stateless and fast; avoid heavy I/O on request path.
- Order filters deliberately (security → logging → compression, etc.).
- Avoid business logic in filters/listeners; use them for plumbing.

## 5. Summary

- Filters wrap requests/responses; listeners react to lifecycle events.
- Use for cross-cutting concerns and app bootstrap/cleanup.

## 6. Tricky Interview Questions

1) How do you guarantee a filter runs before another? Where configure order?
2) Can a filter terminate the chain and return a response? When to do that?
