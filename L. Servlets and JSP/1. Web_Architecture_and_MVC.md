## 1. Topic Overview

Modern Java web apps follow a layered, component-based architecture where the browser talks HTTP to a server that runs inside a servlet container. MVC (Model–View–Controller) separates concerns: models hold data and rules, views render UI (JSP/HTML), and controllers (Servlets) coordinate requests, call services/DAOs, and select a view. This separation improves testability, reuse, and team parallelism.

## 2 . Topic definition

- **WHAT**: MVC is an architectural pattern that splits responsibilities into `Model` (domain/state), `View` (presentation), and `Controller` (request handling/coordination). In classic Java EE: `Servlet` = Controller, `JSP` = View, `Java classes/POJOs + DAO/JPA` = Model.
- **WHY**: Decoupling improves maintainability, reduces merge conflicts, and enables independent evolution of UI and business logic.
- **HOW**: The web container routes HTTP requests to a `Servlet` (controller). The controller validates input, calls the service layer (model), stores results in scoped attributes, and forwards to a `JSP` (view) for rendering.
- **WHEN/WHERE**: Apply MVC anywhere you render server-side HTML or need clean separation for complex flows. Even with SPA frontends, server MVC often still powers server-rendered pages or APIs.
- **WHAT IF**: Skipping MVC leads to scriptlet-heavy JSPs, duplicated logic, and hard-to-test code. Over-separating can over-engineer simple pages—balance is key.
- **EXAMPLES**: Servlet as controller + JSP with JSTL/EL as view + POJOs/DAOs as model.

## 3. Deep Dive with Examples

### Request flow (high level)
1) Browser calls `/products`. 2) Container maps to `ProductServlet`. 3) Servlet calls `ProductService` to fetch list. 4) Put list into `request` attribute. 5) Forward to `products.jsp`. 6) JSP iterates with JSTL and renders HTML.

### Minimal runnable example

```java
// Controller: ProductServlet.java
package web;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@WebServlet(name = "productServlet", urlPatterns = "/products")
public class ProductServlet extends HttpServlet {
    private final ProductService productService = new ProductService();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List<Product> products = productService.findAll();
        req.setAttribute("products", products);           // Model -> request scope
        req.getRequestDispatcher("/WEB-INF/views/products.jsp").forward(req, resp); // View
    }
}

// Model: Product.java
class Product {
    private final String name;
    private final double price;
    Product(String name, double price) { this.name = name; this.price = price; }
    public String getName() { return name; }
    public double getPrice() { return price; }
}

// Model service: ProductService.java
class ProductService {
    public List<Product> findAll() { return java.util.List.of(new Product("Pen", 1.5), new Product("Notebook", 3.9)); }
}
```

```jsp
<!-- View: /WEB-INF/views/products.jsp -->
<%@ page contentType="text/html;charset=UTF-8" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html><body>
<h2>Products</h2>
<table border="1">
  <tr><th>Name</th><th>Price</th></tr>
  <c:forEach var="p" items="${products}">
    <tr><td>${p.name}</td><td>${p.price}</td></tr>
  </c:forEach>
  <c:if test="${empty products}"><tr><td colspan="2">No products</td></tr></c:if>
</table>
</body></html>
```

### URL mapping via annotations or web.xml

```xml
<!-- web.xml (optional when not using @WebServlet) -->
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee" version="5.0">
  <servlet>
    <servlet-name>productServlet</servlet-name>
    <servlet-class>web.ProductServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>productServlet</servlet-name>
    <url-pattern>/products</url-pattern>
  </servlet-mapping>
</web-app>
```

## 4. Best Practices & Pitfalls

- **Use JSP as pure view**: Avoid scriptlets; prefer EL + JSTL.
- **Keep controllers thin**: Delegate business rules to services.
- **Prefer forward over redirect** for internal view rendering; use redirect after POST to avoid resubmits (PRG pattern).
- **Place JSPs under `/WEB-INF`** so they are not directly accessible.
- **Validate input early**: Return 400 for invalid parameters.
- **Pitfall**: Putting DB logic in servlets or JSPs → hard to test and maintain.

## 5. Summary

- MVC separates Controller (Servlet), View (JSP), Model (POJOs/services/DAOs).
- Controller sets scoped attributes, forwards to JSP.
- Use EL/JSTL for clean views; keep logic out of JSPs.

## 6. Tricky Interview Questions

1) In classic Servlet–JSP MVC, where should validation and error formatting live and why?
2) Compare server-side MVC with SPA + REST in terms of caching and SEO.
3) Why put JSPs under `/WEB-INF` and what changes in URL design?
4) When do you use forward vs redirect in MVC flows? Explain PRG.
5) How would you add cross-cutting logging without polluting controllers?
