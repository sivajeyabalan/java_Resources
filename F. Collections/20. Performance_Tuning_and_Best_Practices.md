## 1. Topic Overview

- Practical guidance to choose the right collection and tune performance with profiling-driven decisions.

## 2 . Topic definition

- WHAT: Memory/perf characteristics, resizing costs, iteration patterns, boxing overhead, cache friendliness.
- WHY: Reduce GC pressure and latency, improve throughput and responsiveness.
- HOW: Pre-size collections, choose right structures, minimize allocations, avoid unnecessary boxing, reuse buffers.
- WHEN/WHERE: Hot paths, high-frequency operations, large datasets.
- WHAT IF: Premature optimization can complicate code—measure first.

## 3. Deep Dive with Examples

```java
// Pre-sizing to avoid resize
import java.util.*;

class Presize {
    public static void main(String[] args) {
        int expected = 10_000;
        Map<String, Integer> map = new HashMap<>((int)(expected / 0.75f) + 1);
        List<Integer> list = new ArrayList<>(expected);
    }
}
```

```java
// Primitive streams to avoid boxing
import java.util.stream.*;

class Primitives {
    public static void main(String[] args) {
        long sum = IntStream.range(0, 1_000_000).asLongStream().sum();
        System.out.println(sum);
    }
}
```

Checklist:
- Choose `ArrayList` for random-access, `LinkedList` only for specific deque patterns.
- Prefer `ArrayDeque` over `Stack`/`LinkedList` for stack/queue.
- For high contention maps, use `ConcurrentHashMap` with `compute`/`merge`.
- Avoid `CopyOnWriteArrayList` for large, frequently mutated lists.
- Use immutable collections for read-mostly shared data.

## 4. Best Practices & Pitfalls

- Measure with JMH or realistic benchmarks; beware of micro-benchmark traps.
- Avoid mixing ordered streams with costly `sorted` unless required; consider `unordered()`.
- Be mindful of equals/hashCode costs in hot loops.
- Reuse buffers/arrays in parsers and I/O-heavy code paths.

## 5. Summary

- Right data structure + sizing + allocation discipline yields predictable, efficient code—guided by measurement.

## 6. Tricky Interview Questions

1. How do load factor and capacity impact `HashMap` performance and memory?
2. Why is `ArrayDeque` often superior to `LinkedList` as a queue?
3. What profiling evidence would justify switching to primitive collections or custom structures?

