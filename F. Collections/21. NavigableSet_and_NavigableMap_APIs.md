## 1. Topic Overview

- `NavigableSet`/`NavigableMap` extend sorted collections with navigation operations for nearest matches and range views.

## 2 . Topic definition

- WHAT: APIs adding `lower`, `floor`, `ceiling`, `higher`, and view-returning methods like `descendingSet`, `subSet`, `headSet`, `tailSet`.
- WHY: Efficient range queries and nearest neighbor lookups.
- HOW: Use on `TreeSet`/`TreeMap` (and their views) which maintain sorted order.
- WHEN/WHERE: Schedulers, time-series windows, leaderboards.
- WHAT IF: Operations outside view bounds throw exceptions; views are backed by the original structure.

## 3. Deep Dive with Examples

```java
import java.util.*;

class NavApiDemo {
    public static void main(String[] args) {
        NavigableSet<Integer> set = new TreeSet<>(List.of(10, 20, 30));
        System.out.println(set.floor(25));   // 20
        System.out.println(set.ceiling(25)); // 30
        System.out.println(set.lower(10));   // null
        System.out.println(set.higher(30));  // null

        NavigableSet<Integer> view = set.subSet(10, true, 30, false);
        view.add(25);
        System.out.println(set); // [10,20,25,30]
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer navigable methods over manual iteration for nearest lookups.
- Be cautious mutating through sub-views; respect bounds.
- Use `descending` views for reverse traversal efficiently.

## 5. Summary

- Navigable APIs enable efficient nearest and range operations with live views.

## 6. Tricky Interview Questions

1. Contrast `floor` vs `lower`, `ceiling` vs `higher` with examples.
2. How do sub-views interact with the underlying set/map?

