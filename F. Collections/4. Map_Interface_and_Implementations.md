## 1. Topic Overview

The Map interface in Java represents a mapping between keys and values, where each key maps to exactly one value. Unlike Collection, Map is a separate interface hierarchy that stores key-value pairs rather than single elements. Major implementations include HashMap (hash table), TreeMap (red-black tree), LinkedHashMap (hash table with linked list), and Hashtable (legacy synchronized HashMap). Maps provide efficient key-based lookup, insertion, and deletion operations, making them essential for associative data storage and caching scenarios.

## 2. Topic Definition

- **What**: Interface for storing key-value pairs with unique keys and efficient key-based operations
- **Why**: Provides associative data storage, fast lookups by key, and mapping relationships between data
- **How**: Keys must be unique (determined by equals()); values can be duplicated; different implementations optimize for different use cases
- **When/Where**: Caching, indexing, configuration storage, database-like operations, lookup tables
- **What If**:
  - HashMap: Fast O(1) operations but no ordering guarantees
  - TreeMap: Sorted by keys with O(log n) operations
  - LinkedHashMap: Maintains insertion/access order
  - Hashtable: Thread-safe but with performance overhead
  - Null key/value handling varies by implementation
- **Examples**:
  - User profiles: `Map<String, User> users = new HashMap<>()`
  - Configuration: `Map<String, String> config = new Properties()`
  - Sorted data: `Map<String, Integer> sortedScores = new TreeMap<>()`

## 3. Deep Dive with Examples

```java
// File: MapInterfaceDemo.java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class MapInterfaceDemo {
    public static void main(String[] args) {
        demonstrateMapInterface();
        demonstrateHashMap();
        demonstrateTreeMap();
        demonstrateLinkedHashMap();
        demonstrateHashtable();
        demonstrateMapOperations();
        demonstrateMapViews();
        demonstratePerformanceComparison();
        demonstrateThreadSafety();
    }
    
    static void demonstrateMapInterface() {
        System.out.println("=== Map Interface ===");
        
        System.out.println("MAP CHARACTERISTICS:");
        System.out.println("1. Stores key-value pairs");
        System.out.println("2. Keys must be unique (no duplicate keys)");
        System.out.println("3. Each key maps to exactly one value");
        System.out.println("4. Values can be duplicated");
        System.out.println("5. Does not extend Collection interface");
        System.out.println("6. Provides Collection views (keySet, values, entrySet)");
        
        // Basic Map operations
        System.out.println("\n--- Basic Map Operations ---");
        Map<String, Integer> ages = new HashMap<>();
        
        // Adding key-value pairs
        Integer oldValue1 = ages.put("Alice", 25);
        Integer oldValue2 = ages.put("Bob", 30);
        Integer oldValue3 = ages.put("Alice", 26); // Updates existing key
        
        System.out.println("Put 'Alice', 25: " + oldValue1);      // null (new key)
        System.out.println("Put 'Bob', 30: " + oldValue2);        // null (new key)
        System.out.println("Put 'Alice', 26: " + oldValue3);      // 25 (updated existing)
        
        System.out.println("Map contents: " + ages);
        System.out.println("Map size: " + ages.size());
        
        // Retrieving values
        System.out.println("Alice's age: " + ages.get("Alice"));
        System.out.println("Charlie's age: " + ages.get("Charlie")); // null (key not found)
        System.out.println("Charlie's age (with default): " + ages.getOrDefault("Charlie", 0));
        
        // Checking keys and values
        System.out.println("Contains key 'Bob': " + ages.containsKey("Bob"));
        System.out.println("Contains value 30: " + ages.containsValue(30));
        
        // Removing entries
        Integer removedValue = ages.remove("Bob");
        System.out.println("Removed Bob's age: " + removedValue);
        System.out.println("Final map: " + ages);
        
        // Why Map doesn't extend Collection
        System.out.println("\n--- Why Map Doesn't Extend Collection ---");
        System.out.println("1. Map stores pairs, not single elements");
        System.out.println("2. Collection methods like add(E) don't fit key-value pairs");
        System.out.println("3. Map has its own semantics: put(K,V), get(K), etc.");
        System.out.println("4. Map provides Collection views instead");
    }
    
    static void demonstrateHashMap() {
        System.out.println("\n=== HashMap Implementation ===");
        
        System.out.println("HASHMAP CHARACTERISTICS:");
        System.out.println("- Hash table implementation");
        System.out.println("- Average O(1) for put, get, remove");
        System.out.println("- No ordering guarantees");
        System.out.println("- Allows one null key and multiple null values");
        System.out.println("- Not synchronized (not thread-safe)");
        System.out.println("- Default initial capacity: 16, load factor: 0.75");
        
        // HashMap creation
        System.out.println("\n--- HashMap Creation ---");
        HashMap<String, String> hashMap = new HashMap<>(); // Default capacity
        HashMap<String, String> hashMapWithCapacity = new HashMap<>(32); // Initial capacity 32
        HashMap<String, String> hashMapWithLoadFactor = new HashMap<>(16, 0.8f); // Capacity 16, load factor 0.8
        HashMap<String, String> hashMapFromMap = new HashMap<>(Map.of("key1", "value1", "key2", "value2"));
        
        System.out.println("Default HashMap: " + hashMap);
        System.out.println("From existing map: " + hashMapFromMap);
        
        // Demonstrate no ordering
        System.out.println("\n--- No Ordering Guarantee ---");
        HashMap<String, Integer> scores = new HashMap<>();
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);
        scores.put("David", 88);
        scores.put("Eve", 94);
        
        System.out.println("HashMap (no guaranteed order): " + scores);
        
        // Multiple iterations might show different orders
        System.out.println("Multiple iterations:");
        for (int i = 0; i < 3; i++) {
            System.out.print("  Iteration " + (i + 1) + ": ");
            for (Map.Entry<String, Integer> entry : scores.entrySet()) {
                System.out.print(entry.getKey() + "=" + entry.getValue() + " ");
            }
            System.out.println();
        }
        
        // Null handling
        System.out.println("\n--- Null Handling ---");
        HashMap<String, String> nullMap = new HashMap<>();
        nullMap.put("key1", "value1");
        nullMap.put(null, "nullKeyValue");     // One null key allowed
        nullMap.put("key2", null);             // Null values allowed
        nullMap.put("key3", null);             // Multiple null values allowed
        
        System.out.println("HashMap with nulls: " + nullMap);
        System.out.println("Value for null key: " + nullMap.get(null));
        
        // HashMap-specific operations
        System.out.println("\n--- HashMap-Specific Operations ---");
        HashMap<String, List<String>> multiMap = new HashMap<>();
        
        // putIfAbsent - only puts if key doesn't exist
        multiMap.putIfAbsent("fruits", new ArrayList<>());
        multiMap.get("fruits").add("Apple");
        multiMap.putIfAbsent("fruits", new ArrayList<>()); // Won't replace existing
        multiMap.get("fruits").add("Banana");
        
        System.out.println("MultiMap: " + multiMap);
        
        // compute methods
        HashMap<String, Integer> wordCount = new HashMap<>();
        String[] words = {"apple", "banana", "apple", "cherry", "banana", "apple"};
        
        for (String word : words) {
            wordCount.compute(word, (key, val) -> (val == null) ? 1 : val + 1);
        }
        
        System.out.println("Word count using compute: " + wordCount);
        
        // merge method
        HashMap<String, Integer> map1 = new HashMap<>(Map.of("a", 1, "b", 2));
        HashMap<String, Integer> map2 = new HashMap<>(Map.of("b", 3, "c", 4));
        
        map2.forEach((key, value) -> map1.merge(key, value, Integer::sum));
        System.out.println("Merged map (sum values for duplicate keys): " + map1);
        
        // Performance characteristics
        demonstrateHashMapPerformance();
    }
    
    static void demonstrateHashMapPerformance() {
        System.out.println("\n--- HashMap Performance ---");
        
        HashMap<Integer, String> hashMap = new HashMap<>();
        int size = 100000;
        
        // Test put performance
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashMap.put(i, "Value" + i);
        }
        long putTime = System.nanoTime() - startTime;
        
        // Test get performance
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashMap.get(i);
        }
        long getTime = System.nanoTime() - startTime;
        
        // Test remove performance
        startTime = System.nanoTime();
        for (int i = 0; i < size / 2; i++) {
            hashMap.remove(i);
        }
        long removeTime = System.nanoTime() - startTime;
        
        System.out.printf("HashMap Performance (size: %d):%n", size);
        System.out.printf("  Put %d entries: %.2f ms%n", size, putTime / 1_000_000.0);
        System.out.printf("  Get %d entries: %.2f ms%n", size, getTime / 1_000_000.0);
        System.out.printf("  Remove %d entries: %.2f ms%n", size / 2, removeTime / 1_000_000.0);
    }
    
    static void demonstrateTreeMap() {
        System.out.println("\n=== TreeMap Implementation ===");
        
        System.out.println("TREEMAP CHARACTERISTICS:");
        System.out.println("- Red-black tree (self-balancing BST) implementation");
        System.out.println("- O(log n) for put, get, remove");
        System.out.println("- Keys stored in sorted order");
        System.out.println("- Keys must be Comparable or use custom Comparator");
        System.out.println("- Does not allow null keys (but allows null values)");
        System.out.println("- Not synchronized (not thread-safe)");
        
        // TreeMap creation
        System.out.println("\n--- TreeMap Creation ---");
        TreeMap<String, Integer> treeMap = new TreeMap<>();
        TreeMap<String, Integer> treeMapFromMap = new TreeMap<>(Map.of("Zebra", 1, "Apple", 2, "Banana", 3));
        TreeMap<String, Integer> treeMapWithComparator = new TreeMap<>(Collections.reverseOrder());
        
        System.out.println("Empty TreeMap: " + treeMap);
        System.out.println("From map (auto-sorted): " + treeMapFromMap);
        
        // Demonstrate automatic sorting
        System.out.println("\n--- Automatic Sorting by Keys ---");
        TreeMap<Integer, String> numbers = new TreeMap<>();
        numbers.put(5, "Five");
        numbers.put(2, "Two");
        numbers.put(8, "Eight");
        numbers.put(1, "One");
        numbers.put(9, "Nine");
        numbers.put(3, "Three");
        
        System.out.println("TreeMap (automatically sorted by keys): " + numbers);
        
        // TreeMap with custom comparator
        System.out.println("\n--- Custom Comparator ---");
        treeMapWithComparator.put("Apple", 1);
        treeMapWithComparator.put("Banana", 2);
        treeMapWithComparator.put("Cherry", 3);
        
        System.out.println("TreeMap with reverse order: " + treeMapWithComparator);
        
        // TreeMap-specific operations
        System.out.println("\n--- TreeMap-Specific Operations ---");
        TreeMap<String, Integer> grades = new TreeMap<>();
        grades.put("Alice", 85);
        grades.put("Bob", 92);
        grades.put("Charlie", 78);
        grades.put("David", 95);
        grades.put("Eve", 88);
        
        System.out.println("Original TreeMap: " + grades);
        System.out.println("First key (lowest): " + grades.firstKey());
        System.out.println("Last key (highest): " + grades.lastKey());
        System.out.println("Lower key than 'Charlie': " + grades.lowerKey("Charlie"));
        System.out.println("Higher key than 'Charlie': " + grades.higherKey("Charlie"));
        System.out.println("Floor key of 'Chris': " + grades.floorKey("Chris"));
        System.out.println("Ceiling key of 'Chris': " + grades.ceilingKey("Chris"));
        
        // Range operations
        System.out.println("\n--- Range Operations ---");
        SortedMap<String, Integer> headMap = grades.headMap("Charlie");    // Keys < "Charlie"
        SortedMap<String, Integer> tailMap = grades.tailMap("Charlie");    // Keys >= "Charlie"
        SortedMap<String, Integer> subMap = grades.subMap("Bob", "David"); // Keys >= "Bob" and < "David"
        
        System.out.println("Head map (< 'Charlie'): " + headMap);
        System.out.println("Tail map (>= 'Charlie'): " + tailMap);
        System.out.println("Sub map ['Bob', 'David'): " + subMap);
        
        // NavigableMap operations
        System.out.println("\n--- NavigableMap Operations ---");
        Map.Entry<String, Integer> firstEntry = grades.firstEntry();
        Map.Entry<String, Integer> lastEntry = grades.lastEntry();
        Map.Entry<String, Integer> pollFirst = grades.pollFirstEntry(); // Remove and return first
        
        System.out.println("First entry: " + firstEntry);
        System.out.println("Last entry: " + lastEntry);
        System.out.println("Polled first entry: " + pollFirst);
        System.out.println("After polling first: " + grades);
        
        // Null handling
        System.out.println("\n--- Null Key Handling ---");
        try {
            TreeMap<String, String> nullTest = new TreeMap<>();
            nullTest.put(null, "value"); // This will throw NullPointerException
        } catch (NullPointerException e) {
            System.out.println("TreeMap does not allow null keys: " + e.getClass().getSimpleName());
        }
        
        // Null values are allowed
        TreeMap<String, String> nullValueTest = new TreeMap<>();
        nullValueTest.put("key1", null);
        nullValueTest.put("key2", "value2");
        System.out.println("TreeMap with null value: " + nullValueTest);
    }
    
    static void demonstrateLinkedHashMap() {
        System.out.println("\n=== LinkedHashMap Implementation ===");
        
        System.out.println("LINKEDHASHMAP CHARACTERISTICS:");
        System.out.println("- Hash table + doubly-linked list implementation");
        System.out.println("- Maintains insertion order or access order");
        System.out.println("- Slightly slower than HashMap due to linked list overhead");
        System.out.println("- O(1) for put, get, remove (like HashMap)");
        System.out.println("- Allows one null key and multiple null values");
        System.out.println("- Not synchronized (not thread-safe)");
        
        // LinkedHashMap with insertion order
        System.out.println("\n--- Insertion Order Maintenance ---");
        LinkedHashMap<String, Integer> insertionOrder = new LinkedHashMap<>();
        
        insertionOrder.put("First", 1);
        insertionOrder.put("Second", 2);
        insertionOrder.put("Third", 3);
        insertionOrder.put("Fourth", 4);
        insertionOrder.put("Second", 22); // Update existing key, order unchanged
        
        System.out.println("LinkedHashMap (insertion order): " + insertionOrder);
        
        // Compare with HashMap
        HashMap<String, Integer> hashMap = new HashMap<>(insertionOrder);
        System.out.println("Same data in HashMap (no order): " + hashMap);
        
        // LinkedHashMap with access order
        System.out.println("\n--- Access Order Maintenance ---");
        LinkedHashMap<String, Integer> accessOrder = new LinkedHashMap<>(16, 0.75f, true); // true = access order
        
        accessOrder.put("A", 1);
        accessOrder.put("B", 2);
        accessOrder.put("C", 3);
        accessOrder.put("D", 4);
        
        System.out.println("Initial access order map: " + accessOrder);
        
        // Access some elements (moves them to end)
        accessOrder.get("B");
        System.out.println("After accessing 'B': " + accessOrder);
        
        accessOrder.get("A");
        System.out.println("After accessing 'A': " + accessOrder);
        
        // LRU Cache implementation using LinkedHashMap
        System.out.println("\n--- LRU Cache Implementation ---");
        
        class LRUCache<K, V> extends LinkedHashMap<K, V> {
            private final int capacity;
            
            public LRUCache(int capacity) {
                super(16, 0.75f, true); // access order = true
                this.capacity = capacity;
            }
            
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > capacity;
            }
        }
        
        LRUCache<String, String> lruCache = new LRUCache<>(3);
        lruCache.put("1", "One");
        lruCache.put("2", "Two");
        lruCache.put("3", "Three");
        System.out.println("LRU Cache (capacity 3): " + lruCache);
        
        lruCache.put("4", "Four"); // Should remove "1" (least recently used)
        System.out.println("After adding '4': " + lruCache);
        
        lruCache.get("2"); // Access "2", making it most recently used
        lruCache.put("5", "Five"); // Should remove "3" now
        System.out.println("After accessing '2' and adding '5': " + lruCache);
    }
    
    static void demonstrateHashtable() {
        System.out.println("\n=== Hashtable Implementation ===");
        
        System.out.println("HASHTABLE CHARACTERISTICS:");
        System.out.println("- Legacy class (since JDK 1.0)");
        System.out.println("- Synchronized (thread-safe)");
        System.out.println("- Similar to HashMap but with synchronization overhead");
        System.out.println("- Does not allow null keys or null values");
        System.out.println("- Generally avoided in favor of HashMap + synchronization");
        
        // Hashtable creation and operations
        System.out.println("\n--- Hashtable Operations ---");
        Hashtable<String, Integer> hashtable = new Hashtable<>();
        
        hashtable.put("Alice", 25);
        hashtable.put("Bob", 30);
        hashtable.put("Charlie", 35);
        
        System.out.println("Hashtable: " + hashtable);
        
        // Hashtable-specific methods (legacy)
        System.out.println("\n--- Legacy Methods ---");
        Enumeration<String> keys = hashtable.keys();
        System.out.print("Keys via Enumeration: ");
        while (keys.hasMoreElements()) {
            System.out.print(keys.nextElement() + " ");
        }
        System.out.println();
        
        Enumeration<Integer> values = hashtable.elements();
        System.out.print("Values via Enumeration: ");
        while (values.hasMoreElements()) {
            System.out.print(values.nextElement() + " ");
        }
        System.out.println();
        
        // Null handling (not allowed)
        System.out.println("\n--- Null Handling ---");
        try {
            hashtable.put(null, 100); // NullPointerException
        } catch (NullPointerException e) {
            System.out.println("Hashtable doesn't allow null keys: " + e.getClass().getSimpleName());
        }
        
        try {
            hashtable.put("NullValue", null); // NullPointerException
        } catch (NullPointerException e) {
            System.out.println("Hashtable doesn't allow null values: " + e.getClass().getSimpleName());
        }
        
        // Thread safety demonstration
        System.out.println("\n--- Thread Safety ---");
        System.out.println("Hashtable is synchronized - all methods are thread-safe");
        System.out.println("However, HashMap + Collections.synchronizedMap() is preferred");
        
        // Properties (extends Hashtable)
        System.out.println("\n--- Properties Class ---");
        Properties props = new Properties();
        props.setProperty("database.url", "jdbc:mysql://localhost:3306/mydb");
        props.setProperty("database.user", "admin");
        props.setProperty("database.password", "secret");
        
        System.out.println("Properties: " + props);
        System.out.println("Database URL: " + props.getProperty("database.url"));
        System.out.println("Timeout (with default): " + props.getProperty("timeout", "30"));
    }
    
    static void demonstrateMapOperations() {
        System.out.println("\n=== Advanced Map Operations ===");
        
        Map<String, Integer> map = new HashMap<>();
        map.put("Apple", 5);
        map.put("Banana", 3);
        map.put("Cherry", 8);
        map.put("Date", 2);
        
        System.out.println("Original map: " + map);
        
        // Bulk operations
        System.out.println("\n--- Bulk Operations ---");
        Map<String, Integer> additionalItems = Map.of("Elderberry", 4, "Fig", 6);
        map.putAll(additionalItems);
        System.out.println("After putAll: " + map);
        
        // Conditional operations (Java 8+)
        System.out.println("\n--- Conditional Operations ---");
        
        // putIfAbsent
        map.putIfAbsent("Grape", 7);        // Adds new entry
        map.putIfAbsent("Apple", 10);       // Doesn't replace existing
        System.out.println("After putIfAbsent: " + map);
        
        // replace methods
        map.replace("Banana", 33);          // Replace if key exists
        map.replace("Cherry", 8, 88);       // Replace if key exists with specific value
        System.out.println("After replace operations: " + map);
        
        // remove with value check
        boolean removed1 = map.remove("Date", 2);     // Remove if key-value pair matches
        boolean removed2 = map.remove("Fig", 999);    // Won't remove (value doesn't match)
        System.out.println("Removed Date: " + removed1 + ", Removed Fig: " + removed2);
        System.out.println("After conditional removes: " + map);
        
        // Compute operations
        System.out.println("\n--- Compute Operations ---");
        
        // compute - always computes new value
        map.compute("Apple", (key, val) -> val == null ? 1 : val * 2);
        System.out.println("After compute on Apple: " + map);
        
        // computeIfAbsent - computes only if key absent
        map.computeIfAbsent("Honeydew", key -> key.length());
        System.out.println("After computeIfAbsent: " + map);
        
        // computeIfPresent - computes only if key present
        map.computeIfPresent("Banana", (key, val) -> val + 100);
        System.out.println("After computeIfPresent: " + map);
        
        // merge - merges values for existing keys
        map.merge("Apple", 1000, Integer::sum);      // Adds to existing value
        map.merge("Kiwi", 15, Integer::sum);         // Creates new entry
        System.out.println("After merge operations: " + map);
        
        // forEach operation
        System.out.println("\n--- forEach Operation ---");
        System.out.println("Items with quantity > 10:");
        map.forEach((key, value) -> {
            if (value > 10) {
                System.out.println("  " + key + ": " + value);
            }
        });
        
        // replaceAll operation
        System.out.println("\n--- replaceAll Operation ---");
        Map<String, Integer> copyMap = new HashMap<>(map);
        copyMap.replaceAll((key, value) -> value * 2); // Double all values
        System.out.println("Original: " + map);
        System.out.println("After replaceAll (double values): " + copyMap);
    }
    
    static void demonstrateMapViews() {
        System.out.println("\n=== Map Views ===");
        
        Map<String, Integer> scores = new HashMap<>();
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);
        scores.put("David", 88);
        
        System.out.println("Original map: " + scores);
        
        // Key set view
        System.out.println("\n--- Key Set View ---");
        Set<String> keys = scores.keySet();
        System.out.println("Keys: " + keys);
        System.out.println("Keys type: " + keys.getClass().getSimpleName());
        
        // Modify through key set (removes from map)
        keys.remove("Bob");
        System.out.println("After removing 'Bob' from keySet: " + scores);
        
        // Values collection view
        System.out.println("\n--- Values Collection View ---");
        Collection<Integer> values = scores.values();
        System.out.println("Values: " + values);
        System.out.println("Values type: " + values.getClass().getSimpleName());
        
        // Values can contain duplicates
        scores.put("Eve", 92); // Same score as Charlie
        System.out.println("Values after adding duplicate score: " + scores.values());
        
        // Entry set view
        System.out.println("\n--- Entry Set View ---");
        Set<Map.Entry<String, Integer>> entries = scores.entrySet();
        System.out.println("Entries: " + entries);
        
        // Iterate through entries
        System.out.println("Iterating through entries:");
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.printf("  %s: %d%n", entry.getKey(), entry.getValue());
            
            // Modify value through entry
            if (entry.getKey().equals("Alice")) {
                entry.setValue(100); // Updates the map
            }
        }
        System.out.println("After modifying Alice's score: " + scores);
        
        // Views are backed by the map
        System.out.println("\n--- Views are Backed by Original Map ---");
        System.out.println("Original map size: " + scores.size());
        System.out.println("KeySet size: " + keys.size());
        System.out.println("Values size: " + values.size());
        System.out.println("EntrySet size: " + entries.size());
        
        scores.put("Frank", 85);
        System.out.println("After adding to map - KeySet size: " + keys.size());
        System.out.println("Views automatically reflect map changes");
    }
    
    static void demonstratePerformanceComparison() {
        System.out.println("\n=== Performance Comparison ===");
        
        int size = 100000;
        
        // Initialize maps
        HashMap<Integer, String> hashMap = new HashMap<>();
        TreeMap<Integer, String> treeMap = new TreeMap<>();
        LinkedHashMap<Integer, String> linkedHashMap = new LinkedHashMap<>();
        
        // Test put performance
        System.out.println("--- Put Performance ---");
        
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashMap.put(i, "Value" + i);
        }
        long hashMapPutTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            treeMap.put(i, "Value" + i);
        }
        long treeMapPutTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            linkedHashMap.put(i, "Value" + i);
        }
        long linkedHashMapPutTime = System.nanoTime() - startTime;
        
        System.out.printf("Put %d entries:%n", size);
        System.out.printf("  HashMap: %.2f ms%n", hashMapPutTime / 1_000_000.0);
        System.out.printf("  TreeMap: %.2f ms%n", treeMapPutTime / 1_000_000.0);
        System.out.printf("  LinkedHashMap: %.2f ms%n", linkedHashMapPutTime / 1_000_000.0);
        
        // Test get performance
        System.out.println("\n--- Get Performance ---");
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashMap.get(i);
        }
        long hashMapGetTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            treeMap.get(i);
        }
        long treeMapGetTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            linkedHashMap.get(i);
        }
        long linkedHashMapGetTime = System.nanoTime() - startTime;
        
        System.out.printf("Get %d entries:%n", size);
        System.out.printf("  HashMap: %.2f ms%n", hashMapGetTime / 1_000_000.0);
        System.out.printf("  TreeMap: %.2f ms%n", treeMapGetTime / 1_000_000.0);
        System.out.printf("  LinkedHashMap: %.2f ms%n", linkedHashMapGetTime / 1_000_000.0);
        
        // Summary
        System.out.println("\n--- Performance Summary ---");
        System.out.println("HashMap: Fastest for put/get operations, no ordering");
        System.out.println("TreeMap: Slower but maintains sorted order by keys");
        System.out.println("LinkedHashMap: Slightly slower than HashMap, maintains insertion/access order");
    }
    
    static void demonstrateThreadSafety() {
        System.out.println("\n=== Thread Safety in Maps ===");
        
        System.out.println("THREAD SAFETY OPTIONS:");
        System.out.println("1. Hashtable - Built-in synchronization (legacy)");
        System.out.println("2. Collections.synchronizedMap() - Wrapper");
        System.out.println("3. ConcurrentHashMap - Concurrent map");
        System.out.println("4. External synchronization");
        
        // Synchronized wrapper
        System.out.println("\n--- Synchronized Wrapper ---");
        Map<String, Integer> unsafeMap = new HashMap<>();
        Map<String, Integer> safeMap = Collections.synchronizedMap(unsafeMap);
        
        safeMap.put("Key1", 1);
        safeMap.put("Key2", 2);
        
        System.out.println("Synchronized map: " + safeMap);
        System.out.println("Type: " + safeMap.getClass().getSimpleName());
        
        // ConcurrentHashMap
        System.out.println("\n--- ConcurrentHashMap ---");
        Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        concurrentMap.put("A", 1);
        concurrentMap.put("B", 2);
        concurrentMap.put("C", 3);
        
        System.out.println("ConcurrentHashMap: " + concurrentMap);
        System.out.println("- Thread-safe without full synchronization");
        System.out.println("- Better performance than synchronized HashMap");
        System.out.println("- Supports concurrent reads and limited concurrent writes");
        
        // Demonstrate concurrent operations
        ConcurrentHashMap<String, Integer> concMap = new ConcurrentHashMap<>();
        concMap.put("counter", 0);
        
        // Atomic increment operation
        concMap.compute("counter", (key, val) -> val + 1);
        System.out.println("After atomic increment: " + concMap);
        
        // Important note about iteration
        System.out.println("\n--- Important: Iteration Synchronization ---");
        System.out.println("For Collections.synchronizedMap(), manual synchronization needed for iteration:");
        System.out.println("synchronized(safeMap) {");
        System.out.println("    for (Map.Entry<String, Integer> entry : safeMap.entrySet()) {");
        System.out.println("        // Process entry safely");
        System.out.println("    }");
        System.out.println("}");
        
        System.out.println("\nConcurrentHashMap doesn't require external synchronization for iteration");
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use HashMap for fast key-value operations when order doesn't matter
- Use TreeMap when you need sorted keys
- Use LinkedHashMap when you need predictable iteration order
- Always override both equals() and hashCode() for custom key objects
- Consider initial capacity for HashMap to avoid rehashing

**Don'ts:**
- Don't use Hashtable in new code (use HashMap + synchronization instead)
- Don't use null keys in TreeMap (throws NullPointerException)
- Don't modify key objects in ways that affect equals/hashCode while they're in the map
- Don't assume any ordering in HashMap
- Don't use raw types (avoid `Map map = new HashMap()`)

**Common Pitfalls:**
- Violating equals/hashCode contract for key objects causing lookup failures
- NullPointerException when using null keys in TreeMap
- ClassCastException in TreeMap when keys are not comparable
- Memory leaks from not removing entries from maps
- Thread safety issues in multi-threaded environments

## 5. Summary

- **Map interface** stores key-value pairs with unique keys and doesn't extend Collection
- **HashMap**: Fast O(1) operations, no ordering, allows one null key and multiple null values
- **TreeMap**: Sorted by keys O(log n) operations, no null keys, requires Comparable/Comparator
- **LinkedHashMap**: Maintains insertion/access order with O(1) operations, useful for LRU caches
- **Hashtable**: Legacy synchronized HashMap, doesn't allow null keys/values
- **Map views**: keySet(), values(), entrySet() provide Collection views backed by the original map
- **Thread safety** available through Hashtable, synchronized wrappers, or ConcurrentHashMap
- **Choose implementation** based on ordering needs, performance requirements, and thread safety

## 6. Tricky Interview Questions

1. **Map vs Collection**: What is the difference between Set and Map? Why doesn't Map extend Collection interface?

2. **HashMap vs TreeMap**: What is the difference between HashMap and TreeMap? When would you use each?

3. **HashMap vs Hashtable**: What is the difference between HashMap and Hashtable? Why is Hashtable not recommended?

4. **Map Views**: What are the different Collection views provided by Map interface? How are they related to the original map?

5. **equals/hashCode**: What is the importance of hashCode() and equals() methods for Map keys? Show what happens when they're not properly implemented.

6. **Null Handling**: Which Map implementations allow null keys and values? What happens when you try to use null in TreeMap?

7. **LRU Cache**: How would you implement an LRU (Least Recently Used) cache using LinkedHashMap? Show the code.

8. **Performance Analysis**: Compare the time complexity of put(), get(), and remove() operations for HashMap, TreeMap, and LinkedHashMap.

9. **Thread Safety**: How do you decide between HashMap and TreeMap? What are the thread-safe alternatives for each?

10. **Concurrent Operations**: What's the difference between Collections.synchronizedMap(new HashMap()) and ConcurrentHashMap? When would you use each?

11. **Properties File**: What is the advantage of Properties file? How does it relate to Hashtable?
