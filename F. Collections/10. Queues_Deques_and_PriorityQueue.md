## 1. Topic Overview

- Queues and deques provide FIFO/LIFO and double-ended operations; `PriorityQueue` orders elements by priority, not insertion.

## 2 . Topic definition

- WHAT: `Queue`, `Deque`, `ArrayDeque`, `LinkedList` (as deque), `PriorityQueue`.
- WHY: Task scheduling, buffering, breadth-first traversal, sliding windows.
- HOW: Choose `ArrayDeque` for most deques; `PriorityQueue` for min-heap ordering.
- WHEN/WHERE: BFS uses queues; undo stacks use deques; top-k uses `PriorityQueue`.
- WHAT IF: `PriorityQueue` is not thread-safe and not stable; custom comparator must be consistent.

## 3. Deep Dive with Examples

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class UndoStack {
    private final Deque<String> stack = new ArrayDeque<>();
    public void push(String cmd) { stack.push(cmd); }
    public String undo() { return stack.pop(); }
}
```

```java
import java.util.*;

public class TopK {
    public static List<Integer> topK(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(k);
        for (int n : nums) {
            if (pq.size() < k) pq.offer(n);
            else if (n > pq.peek()) { pq.poll(); pq.offer(n); }
        }
        ArrayList<Integer> res = new ArrayList<>(pq);
        res.sort(Comparator.reverseOrder());
        return res;
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer `ArrayDeque` over `Stack` and `LinkedList` for stacks/queues.
- Ensure comparator imposes a total order; avoid inconsistent comparators.
- For thread-safety, use `BlockingQueue` variants (see concurrent collections topic).

## 5. Summary

- Queues/deques handle ends efficiently; `PriorityQueue` enables priority-based retrieval.

## 6. Tricky Interview Questions

1. Why is `ArrayDeque` preferred over `Stack`/`LinkedList` for stacks?
2. Implement top-k using `PriorityQueue` with O(n log k) complexity.
3. What breaks with a comparator inconsistent with `equals`?

