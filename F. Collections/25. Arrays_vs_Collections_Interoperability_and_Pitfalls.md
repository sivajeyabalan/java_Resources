## 1. Topic Overview

- Arrays interoperate with collections, but edge cases (fixed-size lists, covariance) trip many developers.

## 2 . Topic definition

- WHAT: Conversions (`Arrays.asList`, `List.toArray`), array covariance vs generics invariance, primitive arrays.
- WHY: Bridge APIs and avoid subtle bugs in conversions.
- HOW: Use `List.toArray(T[])` or `toArray(IntFunction)`; beware `Arrays.asList` fixed-size behavior.
- WHEN/WHERE: Interfacing with legacy APIs, performance-sensitive paths.
- WHAT IF: Mutating `Arrays.asList` size throws; `toArray()` without generator boxes elements and may allocate twice.

## 3. Deep Dive with Examples

```java
import java.util.*;

class Interop {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3));
        Integer[] arr = list.toArray(Integer[]::new);
        List<Integer> fixed = Arrays.asList(arr);
        // fixed.add(4); // UnsupportedOperationException
        System.out.println(Arrays.toString(arr));
    }
}
```

```java
// Covariance pitfall
class Covariance {
    public static void main(String[] args) {
        Number[] nums = new Integer[]{1,2,3};
        // nums[0] = 1.5; // ArrayStoreException at runtime
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer collection views over arrays unless interop or performance requires arrays.
- Use generator `toArray(T[]::new)` to avoid extra allocations.
- Avoid `Arrays.asList` when you need to change size; wrap in `new ArrayList<>(...)`.

## 5. Summary

- Interoperability is straightforward with the right methods; watch for fixed-size lists and covariance traps.

## 6. Tricky Interview Questions

1. Why does `Arrays.asList` produce a fixed-size list? How to get a resizable one?
2. Explain array covariance vs generics invariance with examples.

