## 1. Topic Overview

Iterators in Java provide a standardized way to traverse collections without exposing their internal structure. The Iterator interface is the foundation for collection traversal, while ListIterator extends it with bidirectional navigation and modification capabilities. Enumeration is a legacy interface similar to Iterator but with fewer methods and no removal capability. Understanding these iteration mechanisms is crucial for safe collection traversal, especially in concurrent environments where fail-fast behavior helps detect concurrent modifications.

## 2. Topic Definition

- **What**: Interfaces for traversing collections safely and uniformly across different collection types
- **Why**: Provides consistent iteration API, enables safe traversal, supports modification during iteration, detects concurrent modifications
- **How**: Iterator for forward-only traversal, ListIterator for bidirectional traversal, Enumeration for legacy code compatibility
- **When/Where**: Collection traversal, safe element removal during iteration, bidirectional navigation in lists, legacy system integration
- **What If**:
  - Iterator: Fail-fast behavior throws ConcurrentModificationException on concurrent modification
  - ListIterator: Allows bidirectional movement and in-place modifications
  - Enumeration: Legacy interface without removal capability, not fail-fast
  - Enhanced for-loop uses Iterator internally
- **Examples**:
  - Basic iteration: `Iterator<String> it = list.iterator(); while(it.hasNext()) {...}`
  - Safe removal: `it.remove()` instead of `list.remove(element)`
  - Bidirectional: `ListIterator<String> lit = list.listIterator()`

## 3. Deep Dive with Examples

```java
// File: IteratorsDemo.java
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class IteratorsDemo {
    public static void main(String[] args) {
        demonstrateIteratorInterface();
        demonstrateListIterator();
        demonstrateEnumeration();
        demonstrateFailFastBehavior();
        demonstrateIteratorComparison();
        demonstrateAdvancedIteratorUsage();
        demonstrateConcurrentIteration();
    }
    
    static void demonstrateIteratorInterface() {
        System.out.println("=== Iterator Interface ===");
        
        System.out.println("ITERATOR CHARACTERISTICS:");
        System.out.println("1. Forward-only traversal");
        System.out.println("2. Fail-fast behavior (detects concurrent modifications)");
        System.out.println("3. Safe element removal during iteration");
        System.out.println("4. Works with all Collection implementations");
        System.out.println("5. Three main methods: hasNext(), next(), remove()");
        
        // Basic Iterator usage
        System.out.println("\n--- Basic Iterator Usage ---");
        List<String> fruits = new ArrayList<>(Arrays.asList("Apple", "Banana", "Cherry", "Date", "Elderberry"));
        
        Iterator<String> iterator = fruits.iterator();
        System.out.println("Original list: " + fruits);
        
        System.out.print("Iterating with Iterator: ");
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.print(fruit + " ");
        }
        System.out.println();
        
        // Safe removal during iteration
        System.out.println("\n--- Safe Removal During Iteration ---");
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        System.out.println("Original numbers: " + numbers);
        
        Iterator<Integer> numIterator = numbers.iterator();
        while (numIterator.hasNext()) {
            Integer num = numIterator.next();
            if (num % 2 == 0) { // Remove even numbers
                numIterator.remove(); // Safe removal
            }
        }
        System.out.println("After removing even numbers: " + numbers);
        
        // Unsafe removal (causes ConcurrentModificationException)
        System.out.println("\n--- Unsafe Removal (Don't do this!) ---");
        List<String> colors = new ArrayList<>(Arrays.asList("Red", "Green", "Blue", "Yellow"));
        
        try {
            for (String color : colors) { // Enhanced for-loop uses Iterator internally
                if (color.equals("Green")) {
                    colors.remove(color); // Unsafe - modifies collection during iteration
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("ConcurrentModificationException caught: " + e.getClass().getSimpleName());
            System.out.println("Never modify collection directly during iteration!");
        }
        
        // Iterator with different collection types
        System.out.println("\n--- Iterator with Different Collections ---");
        
        // Set iterator
        Set<String> stringSet = new HashSet<>(Arrays.asList("Alpha", "Beta", "Gamma"));
        System.out.print("Set iteration: ");
        for (Iterator<String> it = stringSet.iterator(); it.hasNext(); ) {
            System.out.print(it.next() + " ");
        }
        System.out.println();
        
        // Map iterator (through entrySet)
        Map<String, Integer> map = new HashMap<>();
        map.put("One", 1);
        map.put("Two", 2);
        map.put("Three", 3);
        
        System.out.println("Map iteration through entrySet:");
        Iterator<Map.Entry<String, Integer>> mapIterator = map.entrySet().iterator();
        while (mapIterator.hasNext()) {
            Map.Entry<String, Integer> entry = mapIterator.next();
            System.out.printf("  %s = %d%n", entry.getKey(), entry.getValue());
        }
    }
    
    static void demonstrateListIterator() {
        System.out.println("\n=== ListIterator Interface ===");
        
        System.out.println("LISTITERATOR CHARACTERISTICS:");
        System.out.println("1. Bidirectional traversal (forward and backward)");
        System.out.println("2. Index-aware iteration");
        System.out.println("3. In-place modification (set, add, remove)");
        System.out.println("4. Only available for List implementations");
        System.out.println("5. Extends Iterator interface");
        
        // Basic ListIterator usage
        System.out.println("\n--- Basic ListIterator Usage ---");
        List<String> animals = new ArrayList<>(Arrays.asList("Cat", "Dog", "Elephant", "Fox", "Giraffe"));
        
        ListIterator<String> listIterator = animals.listIterator();
        System.out.println("Original list: " + animals);
        
        // Forward iteration with indices
        System.out.println("Forward iteration with indices:");
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String animal = listIterator.next();
            System.out.printf("  Index %d: %s%n", index, animal);
        }
        
        // Backward iteration
        System.out.println("Backward iteration:");
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String animal = listIterator.previous();
            System.out.printf("  Index %d: %s%n", index, animal);
        }
        
        // Starting from specific position
        System.out.println("\n--- Starting from Specific Position ---");
        ListIterator<String> positionIterator = animals.listIterator(2); // Start at index 2
        System.out.println("Starting from index 2:");
        while (positionIterator.hasNext()) {
            System.out.println("  " + positionIterator.next());
        }
        
        // ListIterator modifications
        System.out.println("\n--- ListIterator Modifications ---");
        List<Integer> modifiableList = new ArrayList<>(Arrays.asList(10, 20, 30, 40, 50));
        System.out.println("Original: " + modifiableList);
        
        ListIterator<Integer> modIterator = modifiableList.listIterator();
        
        while (modIterator.hasNext()) {
            Integer value = modIterator.next();
            
            if (value == 20) {
                modIterator.set(200); // Replace current element
                System.out.println("Replaced 20 with 200");
            }
            
            if (value == 30) {
                modIterator.add(35); // Insert after current element
                System.out.println("Added 35 after 30");
            }
            
            if (value == 50) {
                modIterator.remove(); // Remove current element
                System.out.println("Removed 50");
            }
        }
        
        System.out.println("After modifications: " + modifiableList);
        
        // Bidirectional search example
        System.out.println("\n--- Bidirectional Search ---");
        List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "cherry", "date", "elderberry"));
        
        // Find element and then navigate around it
        ListIterator<String> searchIterator = words.listIterator();
        String target = "cherry";
        
        // Search forward for target
        while (searchIterator.hasNext()) {
            if (searchIterator.next().equals(target)) {
                System.out.println("Found '" + target + "' at index " + (searchIterator.nextIndex() - 1));
                break;
            }
        }
        
        // Navigate backward from found position
        System.out.print("Elements before '" + target + "': ");
        while (searchIterator.hasPrevious()) {
            String prev = searchIterator.previous();
            if (!prev.equals(target)) {
                System.out.print(prev + " ");
            }
        }
        System.out.println();
    }
    
    static void demonstrateEnumeration() {
        System.out.println("\n=== Enumeration Interface ===");
        
        System.out.println("ENUMERATION CHARACTERISTICS:");
        System.out.println("1. Legacy interface (since JDK 1.0)");
        System.out.println("2. Forward-only traversal");
        System.out.println("3. No removal capability");
        System.out.println("4. Not fail-fast");
        System.out.println("5. Two methods: hasMoreElements(), nextElement()");
        System.out.println("6. Used by legacy classes like Vector, Hashtable");
        
        // Enumeration with Vector
        System.out.println("\n--- Enumeration with Vector ---");
        Vector<String> vector = new Vector<>(Arrays.asList("First", "Second", "Third", "Fourth"));
        
        Enumeration<String> enumeration = vector.elements();
        System.out.print("Vector elements via Enumeration: ");
        while (enumeration.hasMoreElements()) {
            System.out.print(enumeration.nextElement() + " ");
        }
        System.out.println();
        
        // Enumeration with Hashtable
        System.out.println("\n--- Enumeration with Hashtable ---");
        Hashtable<String, Integer> hashtable = new Hashtable<>();
        hashtable.put("A", 1);
        hashtable.put("B", 2);
        hashtable.put("C", 3);
        
        // Keys enumeration
        Enumeration<String> keysEnum = hashtable.keys();
        System.out.print("Hashtable keys: ");
        while (keysEnum.hasMoreElements()) {
            System.out.print(keysEnum.nextElement() + " ");
        }
        System.out.println();
        
        // Values enumeration
        Enumeration<Integer> valuesEnum = hashtable.elements();
        System.out.print("Hashtable values: ");
        while (valuesEnum.hasMoreElements()) {
            System.out.print(valuesEnum.nextElement() + " ");
        }
        System.out.println();
        
        // Converting between Iterator and Enumeration
        System.out.println("\n--- Converting Between Iterator and Enumeration ---");
        
        List<String> list = Arrays.asList("X", "Y", "Z");
        
        // Iterator to Enumeration
        Iterator<String> iterator = list.iterator();
        Enumeration<String> enumFromIterator = new Enumeration<String>() {
            public boolean hasMoreElements() { return iterator.hasNext(); }
            public String nextElement() { return iterator.next(); }
        };
        
        System.out.print("Iterator converted to Enumeration: ");
        while (enumFromIterator.hasMoreElements()) {
            System.out.print(enumFromIterator.nextElement() + " ");
        }
        System.out.println();
        
        // Collections.enumeration() utility
        Enumeration<String> utilityEnum = Collections.enumeration(list);
        System.out.print("Collections.enumeration(): ");
        while (utilityEnum.hasMoreElements()) {
            System.out.print(utilityEnum.nextElement() + " ");
        }
        System.out.println();
        
        // Collections.list() - Enumeration to List
        Vector<String> sourceVector = new Vector<>(Arrays.asList("P", "Q", "R"));
        List<String> listFromEnum = Collections.list(sourceVector.elements());
        System.out.println("Enumeration to List: " + listFromEnum);
    }
    
    static void demonstrateFailFastBehavior() {
        System.out.println("\n=== Fail-Fast Behavior ===");
        
        System.out.println("FAIL-FAST MECHANISM:");
        System.out.println("1. Detects concurrent modifications during iteration");
        System.out.println("2. Throws ConcurrentModificationException");
        System.out.println("3. Uses modCount field to track modifications");
        System.out.println("4. Applies to Iterator and enhanced for-loop");
        System.out.println("5. Not guaranteed - best effort detection");
        
        // Demonstrate fail-fast with Iterator
        System.out.println("\n--- Fail-Fast with Iterator ---");
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        Iterator<String> iterator = list.iterator();
        
        try {
            iterator.next(); // First element
            list.add("F"); // Modify collection outside iterator
            iterator.next(); // This should throw ConcurrentModificationException
        } catch (ConcurrentModificationException e) {
            System.out.println("ConcurrentModificationException: Detected concurrent modification");
        }
        
        // Demonstrate fail-fast with enhanced for-loop
        System.out.println("\n--- Fail-Fast with Enhanced For-Loop ---");
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        try {
            for (Integer num : numbers) {
                if (num == 3) {
                    numbers.remove(num); // Modifies collection during iteration
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("ConcurrentModificationException in enhanced for-loop");
        }
        
        // Safe modification patterns
        System.out.println("\n--- Safe Modification Patterns ---");
        
        // Pattern 1: Use Iterator.remove()
        List<String> safeList1 = new ArrayList<>(Arrays.asList("Red", "Green", "Blue", "Yellow"));
        Iterator<String> safeIterator = safeList1.iterator();
        while (safeIterator.hasNext()) {
            String color = safeIterator.next();
            if (color.startsWith("G")) {
                safeIterator.remove(); // Safe removal
            }
        }
        System.out.println("Safe removal with Iterator: " + safeList1);
        
        // Pattern 2: Collect items to remove, then remove them
        List<String> safeList2 = new ArrayList<>(Arrays.asList("Red", "Green", "Blue", "Yellow"));
        List<String> toRemove = new ArrayList<>();
        
        for (String color : safeList2) {
            if (color.startsWith("B")) {
                toRemove.add(color);
            }
        }
        safeList2.removeAll(toRemove);
        System.out.println("Safe removal with separate list: " + safeList2);
        
        // Pattern 3: Use removeIf (Java 8+)
        List<String> safeList3 = new ArrayList<>(Arrays.asList("Red", "Green", "Blue", "Yellow"));
        safeList3.removeIf(color -> color.startsWith("Y"));
        System.out.println("Safe removal with removeIf: " + safeList3);
        
        // Enumeration is NOT fail-fast
        System.out.println("\n--- Enumeration is NOT Fail-Fast ---");
        Vector<String> vector = new Vector<>(Arrays.asList("X", "Y", "Z"));
        Enumeration<String> enumeration = vector.elements();
        
        enumeration.nextElement(); // First element
        vector.add("W"); // Modify vector
        
        try {
            String next = enumeration.nextElement(); // This works (no exception)
            System.out.println("Enumeration continued after modification: " + next);
            System.out.println("Enumeration is NOT fail-fast");
        } catch (Exception e) {
            System.out.println("Unexpected exception: " + e.getClass().getSimpleName());
        }
    }
    
    static void demonstrateIteratorComparison() {
        System.out.println("\n=== Iterator vs ListIterator vs Enumeration ===");
        
        // Create test data
        List<String> testList = new ArrayList<>(Arrays.asList("One", "Two", "Three", "Four"));
        Vector<String> testVector = new Vector<>(testList);
        
        System.out.println("Test data: " + testList);
        
        // Feature comparison table
        System.out.println("\n--- Feature Comparison ---");
        System.out.printf("%-20s %-10s %-15s %-12s%n", "Feature", "Iterator", "ListIterator", "Enumeration");
        System.out.println("-".repeat(60));
        System.out.printf("%-20s %-10s %-15s %-12s%n", "Direction", "Forward", "Bidirectional", "Forward");
        System.out.printf("%-20s %-10s %-15s %-12s%n", "Modification", "Remove", "Add/Set/Remove", "None");
        System.out.printf("%-20s %-10s %-15s %-12s%n", "Fail-fast", "Yes", "Yes", "No");
        System.out.printf("%-20s %-10s %-15s %-12s%n", "Index access", "No", "Yes", "No");
        System.out.printf("%-20s %-10s %-15s %-12s%n", "Collections", "All", "List only", "Legacy");
        
        // Performance comparison
        System.out.println("\n--- Performance Comparison ---");
        int size = 100000;
        List<Integer> largeList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            largeList.add(i);
        }
        
        // Iterator performance
        long startTime = System.nanoTime();
        Iterator<Integer> iterator = largeList.iterator();
        while (iterator.hasNext()) {
            iterator.next();
        }
        long iteratorTime = System.nanoTime() - startTime;
        
        // ListIterator performance
        startTime = System.nanoTime();
        ListIterator<Integer> listIterator = largeList.listIterator();
        while (listIterator.hasNext()) {
            listIterator.next();
        }
        long listIteratorTime = System.nanoTime() - startTime;
        
        // Enhanced for-loop performance (uses Iterator internally)
        startTime = System.nanoTime();
        for (Integer num : largeList) {
            // Just iterate
        }
        long enhancedForTime = System.nanoTime() - startTime;
        
        System.out.printf("Iteration over %d elements:%n", size);
        System.out.printf("  Iterator: %.2f ms%n", iteratorTime / 1_000_000.0);
        System.out.printf("  ListIterator: %.2f ms%n", listIteratorTime / 1_000_000.0);
        System.out.printf("  Enhanced for-loop: %.2f ms%n", enhancedForTime / 1_000_000.0);
    }
    
    static void demonstrateAdvancedIteratorUsage() {
        System.out.println("\n=== Advanced Iterator Usage ===");
        
        // Custom Iterator implementation
        System.out.println("--- Custom Iterator Implementation ---");
        
        class NumberRange implements Iterable<Integer> {
            private final int start;
            private final int end;
            private final int step;
            
            public NumberRange(int start, int end, int step) {
                this.start = start;
                this.end = end;
                this.step = step;
            }
            
            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {
                    private int current = start;
                    
                    @Override
                    public boolean hasNext() {
                        return current < end;
                    }
                    
                    @Override
                    public Integer next() {
                        if (!hasNext()) {
                            throw new NoSuchElementException();
                        }
                        int result = current;
                        current += step;
                        return result;
                    }
                };
            }
        }
        
        NumberRange range = new NumberRange(0, 20, 3);
        System.out.print("Custom range iterator (0 to 20, step 3): ");
        for (Integer num : range) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        // Iterator chaining
        System.out.println("\n--- Iterator Chaining ---");
        
        List<String> list1 = Arrays.asList("A", "B", "C");
        List<String> list2 = Arrays.asList("D", "E", "F");
        
        class ChainedIterator<T> implements Iterator<T> {
            private final Iterator<T> first;
            private final Iterator<T> second;
            
            public ChainedIterator(Iterator<T> first, Iterator<T> second) {
                this.first = first;
                this.second = second;
            }
            
            @Override
            public boolean hasNext() {
                return first.hasNext() || second.hasNext();
            }
            
            @Override
            public T next() {
                if (first.hasNext()) {
                    return first.next();
                } else if (second.hasNext()) {
                    return second.next();
                } else {
                    throw new NoSuchElementException();
                }
            }
        }
        
        ChainedIterator<String> chainedIterator = new ChainedIterator<>(list1.iterator(), list2.iterator());
        System.out.print("Chained iterator: ");
        while (chainedIterator.hasNext()) {
            System.out.print(chainedIterator.next() + " ");
        }
        System.out.println();
        
        // Filtering iterator
        System.out.println("\n--- Filtering Iterator ---");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        class FilteringIterator<T> implements Iterator<T> {
            private final Iterator<T> iterator;
            private final java.util.function.Predicate<T> predicate;
            private T nextElement;
            private boolean hasNext;
            
            public FilteringIterator(Iterator<T> iterator, java.util.function.Predicate<T> predicate) {
                this.iterator = iterator;
                this.predicate = predicate;
                advance();
            }
            
            private void advance() {
                hasNext = false;
                while (iterator.hasNext()) {
                    nextElement = iterator.next();
                    if (predicate.test(nextElement)) {
                        hasNext = true;
                        break;
                    }
                }
            }
            
            @Override
            public boolean hasNext() {
                return hasNext;
            }
            
            @Override
            public T next() {
                if (!hasNext) {
                    throw new NoSuchElementException();
                }
                T result = nextElement;
                advance();
                return result;
            }
        }
        
        FilteringIterator<Integer> evenIterator = new FilteringIterator<>(
            numbers.iterator(), 
            n -> n % 2 == 0
        );
        
        System.out.print("Even numbers only: ");
        while (evenIterator.hasNext()) {
            System.out.print(evenIterator.next() + " ");
        }
        System.out.println();
    }
    
    static void demonstrateConcurrentIteration() {
        System.out.println("\n=== Concurrent Iteration ===");
        
        System.out.println("CONCURRENT ITERATION STRATEGIES:");
        System.out.println("1. Synchronized collections with external synchronization");
        System.out.println("2. Concurrent collections (CopyOnWriteArrayList, etc.)");
        System.out.println("3. Snapshot iteration");
        System.out.println("4. Lock-based iteration");
        
        // CopyOnWriteArrayList - safe concurrent iteration
        System.out.println("\n--- CopyOnWriteArrayList ---");
        
        CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>(
            Arrays.asList("Item1", "Item2", "Item3")
        );
        
        // This is safe - iterator won't see modifications
        Iterator<String> cowIterator = cowList.iterator();
        
        System.out.print("Iterating while modifying: ");
        while (cowIterator.hasNext()) {
            String item = cowIterator.next();
            System.out.print(item + " ");
            
            // Safe to modify during iteration
            cowList.add("NewItem");
        }
        System.out.println();
        System.out.println("Final list: " + cowList);
        System.out.println("Iterator saw snapshot, not modifications");
        
        // Synchronized collection with proper synchronization
        System.out.println("\n--- Synchronized Collection ---");
        
        List<String> syncList = Collections.synchronizedList(new ArrayList<>(
            Arrays.asList("A", "B", "C", "D")
        ));
        
        // Proper synchronization for iteration
        synchronized (syncList) {
            Iterator<String> syncIterator = syncList.iterator();
            while (syncIterator.hasNext()) {
                System.out.println("  " + syncIterator.next());
                // Safe to modify through iterator
                // syncIterator.remove(); // if needed
            }
        }
        
        System.out.println("\n--- Best Practices for Concurrent Iteration ---");
        System.out.println("1. Use CopyOnWriteArrayList for read-heavy, low-write scenarios");
        System.out.println("2. Synchronize on the collection when iterating synchronized collections");
        System.out.println("3. Consider using concurrent collections from java.util.concurrent");
        System.out.println("4. Use Iterator.remove() instead of Collection.remove() during iteration");
        System.out.println("5. Be aware of fail-fast behavior and handle ConcurrentModificationException");
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use Iterator.remove() for safe element removal during iteration
- Use ListIterator for bidirectional traversal and in-place modifications
- Synchronize on the collection when iterating over synchronized collections
- Handle ConcurrentModificationException appropriately
- Use enhanced for-loop when you don't need to modify the collection

**Don'ts:**
- Don't modify collections directly during iteration (use Iterator.remove() instead)
- Don't assume Enumeration is fail-fast (it's not)
- Don't ignore ConcurrentModificationException in multi-threaded code
- Don't use Enumeration in new code (use Iterator instead)
- Don't call Iterator.remove() without calling next() first

**Common Pitfalls:**
- ConcurrentModificationException when modifying collection during iteration
- NoSuchElementException when calling next() without checking hasNext()
- IllegalStateException when calling remove() multiple times or before next()
- Thread safety issues when iterating over collections in concurrent environments
- Performance issues from unnecessary iterator creation in loops

## 5. Summary

- **Iterator**: Forward-only traversal with fail-fast behavior and safe removal capability
- **ListIterator**: Bidirectional traversal with index access and in-place modification methods
- **Enumeration**: Legacy interface for forward-only traversal without fail-fast behavior or removal
- **Fail-fast behavior**: Detects concurrent modifications and throws ConcurrentModificationException
- **Safe iteration patterns**: Use Iterator.remove(), collect-then-remove, or removeIf() for modifications
- **Thread safety**: Requires external synchronization for synchronized collections or use concurrent collections
- **Enhanced for-loop**: Uses Iterator internally and provides cleaner syntax for read-only iteration

## 6. Tricky Interview Questions

1. **Iterator vs Enumeration**: What is the difference between Iterator and Enumeration? Why is Iterator preferred?

2. **Iterator vs ListIterator**: What is the difference between Iterator and ListIterator? When would you use each?

3. **Fail-Fast Behavior**: What causes ConcurrentModificationException? How can you safely modify a collection during iteration?

4. **Iterator Advantages**: What are the advantages of iterating a collection using Iterator compared to traditional for-loops?

5. **Thread Safety**: How do you safely iterate over a synchronized collection in a multi-threaded environment?

6. **ListIterator Features**: What additional capabilities does ListIterator provide over Iterator? Show examples of bidirectional traversal.

7. **Enhanced For-Loop**: How does the enhanced for-loop relate to Iterator? What are its limitations?

8. **Concurrent Modification**: Show three different safe patterns for removing elements from a list during iteration.

9. **Custom Iterator**: How would you implement a custom Iterator for a class? What methods must be implemented?

10. **Performance Comparison**: Compare the performance characteristics of Iterator, ListIterator, and enhanced for-loop. When would you choose each?

11. **Legacy Integration**: When might you still encounter Enumeration in modern Java applications? How do you convert between Iterator and Enumeration?
