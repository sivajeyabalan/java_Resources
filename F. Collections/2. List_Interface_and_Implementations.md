## 1. Topic Overview

The List interface in Java represents an ordered collection (sequence) that allows duplicate elements and provides positional access to elements via index. It extends the Collection interface and adds index-based operations like get(), set(), add(index, element), and remove(index). Major implementations include ArrayList (resizable array), LinkedList (doubly-linked list), and Vector (synchronized ArrayList). Understanding the performance characteristics and use cases of each implementation is crucial for choosing the right List type for specific scenarios.

## 2. Topic Definition

- **What**: Ordered collection interface allowing duplicates with index-based access and manipulation
- **Why**: Provides sequential data storage with random access capabilities; maintains insertion order; allows duplicate elements
- **How**: Through index-based operations (0-based indexing) and inherited Collection methods; different implementations optimize for different operations
- **When/Where**: When you need ordered data with duplicates, random access by index, or sequential processing
- **What If**:
  - ArrayList: Fast random access but slow insertions/deletions in middle
  - LinkedList: Fast insertions/deletions but slow random access
  - Vector: Thread-safe but with performance overhead
  - IndexOutOfBoundsException when accessing invalid indices
- **Examples**:
  - Student grades: `List<Integer> grades = new ArrayList<>(Arrays.asList(85, 92, 78, 85))`
  - Task queue: `List<Task> tasks = new LinkedList<>()`
  - Thread-safe list: `List<String> safeList = new Vector<>()`

## 3. Deep Dive with Examples

```java
// File: ListInterfaceDemo.java
import java.util.*;
import java.util.concurrent.*;

public class ListInterfaceDemo {
    public static void main(String[] args) {
        demonstrateListInterface();
        demonstrateArrayList();
        demonstrateLinkedList();
        demonstrateVector();
        demonstratePerformanceComparison();
        demonstrateListOperations();
        demonstrateListIterators();
        demonstrateThreadSafety();
    }
    
    static void demonstrateListInterface() {
        System.out.println("=== List Interface ===");
        
        // List characteristics
        System.out.println("LIST CHARACTERISTICS:");
        System.out.println("1. Ordered collection (maintains insertion order)");
        System.out.println("2. Allows duplicate elements");
        System.out.println("3. Provides index-based access (0-based)");
        System.out.println("4. Extends Collection interface");
        System.out.println("5. Supports positional operations");
        
        // Basic List operations
        System.out.println("\n--- Basic List Operations ---");
        List<String> fruits = new ArrayList<>();
        
        // Adding elements
        fruits.add("Apple");        // Add at end
        fruits.add("Banana");       // Add at end
        fruits.add(1, "Orange");    // Insert at index 1
        fruits.add("Apple");        // Duplicate allowed
        
        System.out.println("After additions: " + fruits);
        System.out.println("Size: " + fruits.size());
        
        // Accessing elements
        System.out.println("Element at index 0: " + fruits.get(0));
        System.out.println("Element at index 2: " + fruits.get(2));
        
        // Searching elements
        System.out.println("Index of 'Apple': " + fruits.indexOf("Apple"));
        System.out.println("Last index of 'Apple': " + fruits.lastIndexOf("Apple"));
        System.out.println("Contains 'Grape': " + fruits.contains("Grape"));
        
        // Modifying elements
        String oldValue = fruits.set(1, "Mango"); // Replace element at index 1
        System.out.println("Replaced '" + oldValue + "' with 'Mango': " + fruits);
        
        // Removing elements
        fruits.remove(0);           // Remove by index
        fruits.remove("Apple");     // Remove by value (first occurrence)
        System.out.println("After removals: " + fruits);
        
        // Sublist operations
        List<String> subList = fruits.subList(0, 2); // From index 0 to 1 (exclusive end)
        System.out.println("Sublist [0, 2): " + subList);
        
        // Important: subList is backed by original list
        subList.set(0, "Pineapple");
        System.out.println("After modifying sublist: " + fruits);
    }
    
    static void demonstrateArrayList() {
        System.out.println("\n=== ArrayList Implementation ===");
        
        System.out.println("ARRAYLIST CHARACTERISTICS:");
        System.out.println("- Resizable array implementation");
        System.out.println("- Fast random access O(1)");
        System.out.println("- Slow insertion/deletion in middle O(n)");
        System.out.println("- Good cache locality");
        System.out.println("- Default initial capacity: 10");
        System.out.println("- Growth factor: 50% (capacity * 1.5)");
        
        // ArrayList creation and capacity
        System.out.println("\n--- ArrayList Creation and Capacity ---");
        ArrayList<Integer> numbers = new ArrayList<>(); // Default capacity 10
        ArrayList<Integer> numbersWithCapacity = new ArrayList<>(100); // Initial capacity 100
        ArrayList<Integer> numbersFromCollection = new ArrayList<>(Arrays.asList(1, 2, 3));
        
        System.out.println("Default ArrayList: " + numbers);
        System.out.println("With initial capacity 100: " + numbersWithCapacity);
        System.out.println("From collection: " + numbersFromCollection);
        
        // Demonstrate dynamic resizing
        System.out.println("\n--- Dynamic Resizing ---");
        ArrayList<String> dynamicList = new ArrayList<>(2); // Small initial capacity
        
        for (int i = 0; i < 10; i++) {
            dynamicList.add("Element" + i);
            // ArrayList automatically grows when capacity is exceeded
        }
        System.out.println("ArrayList after adding 10 elements: " + dynamicList);
        System.out.println("Note: ArrayList automatically resized multiple times");
        
        // ArrayList-specific methods
        System.out.println("\n--- ArrayList-Specific Methods ---");
        ArrayList<String> arrayList = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        // Capacity management
        arrayList.ensureCapacity(20); // Ensure capacity without adding elements
        System.out.println("Ensured capacity of 20");
        
        arrayList.trimToSize(); // Reduce capacity to current size
        System.out.println("Trimmed to size: " + arrayList.size());
        
        // Bulk operations
        arrayList.removeRange(1, 3); // Remove elements from index 1 to 2 (protected method in ArrayList)
        // Note: removeRange is protected, shown for educational purposes
        
        // Performance characteristics demonstration
        demonstrateArrayListPerformance();
    }
    
    static void demonstrateArrayListPerformance() {
        System.out.println("\n--- ArrayList Performance Characteristics ---");
        
        ArrayList<Integer> list = new ArrayList<>();
        int size = 100000;
        
        // Test append performance (amortized O(1))
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            list.add(i);
        }
        long appendTime = System.nanoTime() - startTime;
        
        // Test random access performance O(1)
        startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            list.get(i % size);
        }
        long accessTime = System.nanoTime() - startTime;
        
        // Test insertion in middle performance O(n)
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            list.add(size / 2, -1); // Insert in middle
        }
        long insertTime = System.nanoTime() - startTime;
        
        System.out.printf("ArrayList Performance (size: %d):%n", size);
        System.out.printf("  Append %d elements: %.2f ms%n", size, appendTime / 1_000_000.0);
        System.out.printf("  Random access 10k times: %.2f ms%n", accessTime / 1_000_000.0);
        System.out.printf("  Insert 1k elements in middle: %.2f ms%n", insertTime / 1_000_000.0);
    }
    
    static void demonstrateLinkedList() {
        System.out.println("\n=== LinkedList Implementation ===");
        
        System.out.println("LINKEDLIST CHARACTERISTICS:");
        System.out.println("- Doubly-linked list implementation");
        System.out.println("- Implements both List and Deque interfaces");
        System.out.println("- Fast insertion/deletion O(1) at known positions");
        System.out.println("- Slow random access O(n)");
        System.out.println("- Higher memory overhead (node objects + pointers)");
        System.out.println("- No capacity limitations");
        
        // LinkedList creation
        System.out.println("\n--- LinkedList Creation ---");
        LinkedList<String> linkedList = new LinkedList<>();
        LinkedList<String> fromCollection = new LinkedList<>(Arrays.asList("X", "Y", "Z"));
        
        System.out.println("Empty LinkedList: " + linkedList);
        System.out.println("From collection: " + fromCollection);
        
        // LinkedList as List
        System.out.println("\n--- LinkedList as List ---");
        linkedList.add("First");
        linkedList.add("Second");
        linkedList.add(1, "Middle"); // Insert at index 1
        
        System.out.println("LinkedList operations: " + linkedList);
        System.out.println("Get element at index 1: " + linkedList.get(1));
        
        // LinkedList as Deque (Double-ended queue)
        System.out.println("\n--- LinkedList as Deque ---");
        LinkedList<Integer> deque = new LinkedList<>();
        
        // Add to both ends
        deque.addFirst(1);    // Add to beginning
        deque.addLast(3);     // Add to end
        deque.addFirst(0);    // Add to beginning
        deque.addLast(4);     // Add to end
        
        System.out.println("After adding to both ends: " + deque);
        
        // Remove from both ends
        Integer first = deque.removeFirst();
        Integer last = deque.removeLast();
        
        System.out.println("Removed first: " + first + ", last: " + last);
        System.out.println("Remaining: " + deque);
        
        // Peek operations (don't remove)
        System.out.println("Peek first: " + deque.peekFirst());
        System.out.println("Peek last: " + deque.peekLast());
        
        // Queue operations
        System.out.println("\n--- LinkedList as Queue ---");
        LinkedList<String> queue = new LinkedList<>();
        
        // Enqueue (add to rear)
        queue.offer("Task1");
        queue.offer("Task2");
        queue.offer("Task3");
        
        System.out.println("Queue: " + queue);
        
        // Dequeue (remove from front)
        while (!queue.isEmpty()) {
            String task = queue.poll();
            System.out.println("Processing: " + task + ", Remaining: " + queue);
        }
        
        // Stack operations
        System.out.println("\n--- LinkedList as Stack ---");
        LinkedList<String> stack = new LinkedList<>();
        
        // Push (add to front)
        stack.push("Bottom");
        stack.push("Middle");
        stack.push("Top");
        
        System.out.println("Stack: " + stack);
        
        // Pop (remove from front)
        while (!stack.isEmpty()) {
            String item = stack.pop();
            System.out.println("Popped: " + item + ", Remaining: " + stack);
        }
        
        // Performance characteristics
        demonstrateLinkedListPerformance();
    }
    
    static void demonstrateLinkedListPerformance() {
        System.out.println("\n--- LinkedList Performance Characteristics ---");
        
        LinkedList<Integer> list = new LinkedList<>();
        int size = 50000; // Smaller size due to O(n) operations
        
        // Test append performance O(1)
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            list.add(i);
        }
        long appendTime = System.nanoTime() - startTime;
        
        // Test random access performance O(n)
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            list.get(i % size);
        }
        long accessTime = System.nanoTime() - startTime;
        
        // Test insertion at beginning O(1)
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            list.addFirst(-1);
        }
        long insertTime = System.nanoTime() - startTime;
        
        System.out.printf("LinkedList Performance (size: %d):%n", size);
        System.out.printf("  Append %d elements: %.2f ms%n", size, appendTime / 1_000_000.0);
        System.out.printf("  Random access 1k times: %.2f ms%n", accessTime / 1_000_000.0);
        System.out.printf("  Insert 1k elements at beginning: %.2f ms%n", insertTime / 1_000_000.0);
    }
    
    static void demonstrateVector() {
        System.out.println("\n=== Vector Implementation ===");
        
        System.out.println("VECTOR CHARACTERISTICS:");
        System.out.println("- Legacy class (since JDK 1.0)");
        System.out.println("- Synchronized (thread-safe)");
        System.out.println("- Similar to ArrayList but with synchronization overhead");
        System.out.println("- Default growth factor: 100% (doubles capacity)");
        System.out.println("- Generally avoided in favor of ArrayList + synchronization");
        
        // Vector creation
        System.out.println("\n--- Vector Creation ---");
        Vector<String> vector = new Vector<>(); // Default capacity 10
        Vector<String> vectorWithCapacity = new Vector<>(5); // Initial capacity 5
        Vector<String> vectorWithIncrement = new Vector<>(5, 2); // Capacity 5, increment 2
        
        System.out.println("Default Vector: " + vector);
        System.out.println("With capacity 5: " + vectorWithCapacity);
        System.out.println("With capacity 5, increment 2: " + vectorWithIncrement);
        
        // Vector operations (similar to ArrayList)
        System.out.println("\n--- Vector Operations ---");
        vector.add("Element1");
        vector.add("Element2");
        vector.insertElementAt("Element0", 0); // Vector-specific method
        
        System.out.println("Vector after operations: " + vector);
        
        // Vector-specific methods
        System.out.println("\n--- Vector-Specific Methods ---");
        vector.addElement("Element3"); // Legacy add method
        
        System.out.println("First element: " + vector.firstElement());
        System.out.println("Last element: " + vector.lastElement());
        System.out.println("Element at index 1: " + vector.elementAt(1));
        
        // Capacity management
        System.out.println("Current capacity: " + vector.capacity());
        System.out.println("Current size: " + vector.size());
        
        vector.ensureCapacity(20);
        System.out.println("After ensuring capacity 20: " + vector.capacity());
        
        vector.trimToSize();
        System.out.println("After trim to size: " + vector.capacity());
        
        // Enumeration (legacy iteration)
        System.out.println("\n--- Legacy Enumeration ---");
        Enumeration<String> enumeration = vector.elements();
        System.out.print("Elements via Enumeration: ");
        while (enumeration.hasMoreElements()) {
            System.out.print(enumeration.nextElement() + " ");
        }
        System.out.println();
        
        // Thread safety demonstration
        demonstrateVectorThreadSafety();
    }
    
    static void demonstrateVectorThreadSafety() {
        System.out.println("\n--- Vector Thread Safety ---");
        
        Vector<Integer> vector = new Vector<>();
        
        // Multiple threads adding elements
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                vector.add(i);
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                vector.add(i);
            }
        });
        
        try {
            thread1.start();
            thread2.start();
            thread1.join();
            thread2.join();
            
            System.out.println("Vector size after concurrent additions: " + vector.size());
            System.out.println("Expected: 2000, Actual: " + vector.size());
            System.out.println("Vector maintained consistency due to synchronization");
            
        } catch (InterruptedException e) {
            System.err.println("Thread interrupted: " + e.getMessage());
        }
    }
    
    static void demonstratePerformanceComparison() {
        System.out.println("\n=== Performance Comparison ===");
        
        int size = 50000;
        
        // Initialize collections
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>();
        Vector<Integer> vector = new Vector<>();
        
        // Test 1: Sequential addition (append)
        System.out.println("--- Sequential Addition Performance ---");
        
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long arrayListAddTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        long linkedListAddTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            vector.add(i);
        }
        long vectorAddTime = System.nanoTime() - startTime;
        
        System.out.printf("Add %d elements:%n", size);
        System.out.printf("  ArrayList: %.2f ms%n", arrayListAddTime / 1_000_000.0);
        System.out.printf("  LinkedList: %.2f ms%n", linkedListAddTime / 1_000_000.0);
        System.out.printf("  Vector: %.2f ms%n", vectorAddTime / 1_000_000.0);
        
        // Test 2: Random access
        System.out.println("\n--- Random Access Performance ---");
        int accessCount = 10000;
        
        startTime = System.nanoTime();
        for (int i = 0; i < accessCount; i++) {
            arrayList.get(i % size);
        }
        long arrayListAccessTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < accessCount; i++) {
            linkedList.get(i % size);
        }
        long linkedListAccessTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < accessCount; i++) {
            vector.get(i % size);
        }
        long vectorAccessTime = System.nanoTime() - startTime;
        
        System.out.printf("Random access %d times:%n", accessCount);
        System.out.printf("  ArrayList: %.2f ms%n", arrayListAccessTime / 1_000_000.0);
        System.out.printf("  LinkedList: %.2f ms%n", linkedListAccessTime / 1_000_000.0);
        System.out.printf("  Vector: %.2f ms%n", vectorAccessTime / 1_000_000.0);
        
        // Performance summary
        System.out.println("\n--- Performance Summary ---");
        System.out.println("ArrayList: Best for random access and iteration");
        System.out.println("LinkedList: Best for frequent insertions/deletions");
        System.out.println("Vector: Similar to ArrayList but with synchronization overhead");
    }
    
    static void demonstrateListOperations() {
        System.out.println("\n=== Advanced List Operations ===");
        
        List<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Cherry", "Date", "Elderberry"));
        
        // Bulk operations
        System.out.println("--- Bulk Operations ---");
        System.out.println("Original list: " + list);
        
        List<String> toRemove = Arrays.asList("Banana", "Date");
        list.removeAll(toRemove);
        System.out.println("After removeAll: " + list);
        
        List<String> toRetain = Arrays.asList("Apple", "Cherry", "Fig");
        list.retainAll(toRetain);
        System.out.println("After retainAll: " + list);
        
        // List-specific operations
        System.out.println("\n--- List-Specific Operations ---");
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        // Replace all elements
        numbers.replaceAll(n -> n * 2);
        System.out.println("After replaceAll (multiply by 2): " + numbers);
        
        // Sort
        List<String> words = new ArrayList<>(Arrays.asList("zebra", "apple", "banana"));
        words.sort(String::compareTo);
        System.out.println("After sorting: " + words);
        
        // Reverse sort
        words.sort(Collections.reverseOrder());
        System.out.println("After reverse sorting: " + words);
        
        // Sublist operations
        System.out.println("\n--- Sublist Operations ---");
        List<Integer> originalList = new ArrayList<>(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
        List<Integer> subList = originalList.subList(2, 7); // Elements 2, 3, 4, 5, 6
        
        System.out.println("Original: " + originalList);
        System.out.println("Sublist [2, 7): " + subList);
        
        // Modify sublist (affects original)
        subList.set(0, 99);
        System.out.println("After modifying sublist: " + originalList);
        
        // Clear sublist (removes from original)
        subList.clear();
        System.out.println("After clearing sublist: " + originalList);
    }
    
    static void demonstrateListIterators() {
        System.out.println("\n=== List Iterators ===");
        
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        // Regular Iterator (forward only)
        System.out.println("--- Regular Iterator ---");
        Iterator<String> iterator = list.iterator();
        System.out.print("Forward iteration: ");
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
        
        // ListIterator (bidirectional)
        System.out.println("\n--- ListIterator (Bidirectional) ---");
        ListIterator<String> listIterator = list.listIterator();
        
        // Forward iteration with indices
        System.out.println("Forward with indices:");
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String element = listIterator.next();
            System.out.printf("  Index %d: %s%n", index, element);
        }
        
        // Backward iteration
        System.out.print("Backward iteration: ");
        while (listIterator.hasPrevious()) {
            System.out.print(listIterator.previous() + " ");
        }
        System.out.println();
        
        // ListIterator modifications
        System.out.println("\n--- ListIterator Modifications ---");
        ListIterator<String> modifyIterator = list.listIterator();
        
        while (modifyIterator.hasNext()) {
            String element = modifyIterator.next();
            if (element.equals("C")) {
                modifyIterator.set("MODIFIED_C"); // Replace current element
                modifyIterator.add("INSERTED"); // Insert after current
            }
        }
        
        System.out.println("After modifications: " + list);
        
        // Starting ListIterator at specific position
        System.out.println("\n--- ListIterator Starting at Position ---");
        ListIterator<String> positionIterator = list.listIterator(2); // Start at index 2
        System.out.println("Starting at index 2:");
        while (positionIterator.hasNext()) {
            System.out.println("  " + positionIterator.next());
        }
    }
    
    static void demonstrateThreadSafety() {
        System.out.println("\n=== Thread Safety in Lists ===");
        
        System.out.println("THREAD SAFETY OPTIONS:");
        System.out.println("1. Vector - Built-in synchronization (legacy)");
        System.out.println("2. Collections.synchronizedList() - Wrapper");
        System.out.println("3. CopyOnWriteArrayList - Concurrent collection");
        System.out.println("4. External synchronization");
        
        // Synchronized wrapper
        System.out.println("\n--- Synchronized Wrapper ---");
        List<String> unsafeList = new ArrayList<>();
        List<String> safeList = Collections.synchronizedList(unsafeList);
        
        System.out.println("Synchronized wrapper type: " + safeList.getClass().getSimpleName());
        
        // Important: Manual synchronization needed for iteration
        System.out.println("\nIMPORTANT: Manual synchronization needed for iteration:");
        System.out.println("synchronized(safeList) {");
        System.out.println("    for (String item : safeList) {");
        System.out.println("        // Process item safely");
        System.out.println("    }");
        System.out.println("}");
        
        // CopyOnWriteArrayList
        System.out.println("\n--- CopyOnWriteArrayList ---");
        List<String> cowList = new CopyOnWriteArrayList<>();
        cowList.add("Item1");
        cowList.add("Item2");
        
        System.out.println("CopyOnWriteArrayList: " + cowList);
        System.out.println("- Thread-safe for all operations");
        System.out.println("- Optimized for read-heavy scenarios");
        System.out.println("- Expensive writes (copies entire array)");
        System.out.println("- Iterators never throw ConcurrentModificationException");
        
        // Demonstrate concurrent modification safety
        System.out.println("\n--- Concurrent Modification Safety ---");
        for (String item : cowList) {
            System.out.println("Reading: " + item);
            cowList.add("NewItem"); // Safe to modify during iteration
        }
        System.out.println("Final CopyOnWriteArrayList: " + cowList);
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use ArrayList for frequent random access and when memory efficiency is important
- Use LinkedList for frequent insertions/deletions at beginning/middle and queue operations
- Use Collections.synchronizedList() or CopyOnWriteArrayList for thread safety
- Specify initial capacity for ArrayList when size is known to avoid resizing
- Use enhanced for-loop or streams for iteration when possible

**Don'ts:**
- Don't use Vector in new code (use ArrayList + synchronization instead)
- Don't access LinkedList elements by index in loops (use iterators)
- Don't modify list during iteration without using Iterator.remove()
- Don't assume thread safety unless explicitly documented
- Don't use raw types (avoid `List list = new ArrayList()`)

**Common Pitfalls:**
- ConcurrentModificationException when modifying list during iteration
- IndexOutOfBoundsException when accessing invalid indices
- Performance issues from using LinkedList for random access
- Memory leaks from not removing elements from lists
- Thread safety issues with ArrayList in concurrent environments

## 5. Summary

- **List interface** provides ordered collection with duplicates and index-based access
- **ArrayList**: Resizable array, fast random access O(1), slow insertions/deletions O(n)
- **LinkedList**: Doubly-linked list, fast insertions/deletions O(1), slow random access O(n)
- **Vector**: Legacy synchronized ArrayList with performance overhead
- **Classes implementing List**: ArrayList, LinkedList, Vector, Stack, CopyOnWriteArrayList
- **ListIterator** provides bidirectional iteration with modification capabilities
- **Thread safety** available through Vector, synchronized wrappers, or concurrent collections
- **Choose implementation** based on access patterns: ArrayList for reads, LinkedList for modifications

## 6. Tricky Interview Questions

1. **Implementation Comparison**: What is the difference between ArrayList and LinkedList? When would you use each?

2. **Legacy vs Modern**: What is the difference between ArrayList and Vector? Why is Vector not recommended for new code?

3. **Performance Analysis**: Compare the time complexity of get(), add(), and remove() operations for ArrayList vs LinkedList.

4. **Thread Safety**: How can ArrayList be synchronized without using Vector? What are the different approaches?

5. **Iterator Types**: What is the difference between Iterator and ListIterator? Show examples of bidirectional iteration.

6. **Memory Efficiency**: Which List implementation is most memory-efficient for storing large amounts of data? Explain why.

7. **Concurrent Modification**: What causes ConcurrentModificationException and how can you safely modify a list during iteration?

8. **Sublist Behavior**: What happens when you modify a sublist obtained from List.subList()? How does it affect the original list?

9. **Capacity Management**: How does ArrayList handle capacity growth? What's the difference between size() and capacity?

10. **Design Decision**: Why does LinkedList implement both List and Deque interfaces? Show examples of using LinkedList as a queue and stack.

11. **Classes Implementing List**: What are the classes implementing the List interface? Compare their characteristics and use cases.
