## 1. Topic Overview

The Set interface in Java represents a collection that contains no duplicate elements, modeling the mathematical set abstraction. It extends the Collection interface but adds the restriction that duplicate elements are not allowed, where duplicates are determined by the equals() method. Major implementations include HashSet (hash table), TreeSet (red-black tree), and LinkedHashSet (hash table with linked list). Each implementation offers different performance characteristics and ordering guarantees, making them suitable for different use cases.

## 2. Topic Definition

- **What**: Collection interface that prohibits duplicate elements and models mathematical set operations
- **Why**: Ensures uniqueness of elements; provides set operations like union, intersection; efficient membership testing
- **How**: Uses equals() method to determine duplicates; different implementations use different data structures for storage
- **When/Where**: When you need unique elements, set operations, or fast membership testing
- **What If**:
  - HashSet: Fast operations O(1) but no ordering guarantees
  - TreeSet: Sorted order but slower operations O(log n)
  - LinkedHashSet: Maintains insertion order with slightly slower operations than HashSet
  - Null handling varies by implementation
- **Examples**:
  - Unique user IDs: `Set<String> userIds = new HashSet<>()`
  - Sorted unique scores: `Set<Integer> scores = new TreeSet<>()`
  - Maintaining insertion order: `Set<String> orderedItems = new LinkedHashSet<>()`

## 3. Deep Dive with Examples

```java
// File: SetInterfaceDemo.java
import java.util.*;
import java.util.concurrent.ConcurrentSkipListSet;

public class SetInterfaceDemo {
    public static void main(String[] args) {
        demonstrateSetInterface();
        demonstrateHashSet();
        demonstrateTreeSet();
        demonstrateLinkedHashSet();
        demonstrateSetOperations();
        demonstratePerformanceComparison();
        demonstrateEqualsAndHashCode();
        demonstrateThreadSafety();
    }
    
    static void demonstrateSetInterface() {
        System.out.println("=== Set Interface ===");
        
        System.out.println("SET CHARACTERISTICS:");
        System.out.println("1. No duplicate elements allowed");
        System.out.println("2. Duplicates determined by equals() method");
        System.out.println("3. At most one null element (implementation dependent)");
        System.out.println("4. Models mathematical set abstraction");
        System.out.println("5. Extends Collection interface");
        
        // Basic Set operations
        System.out.println("\n--- Basic Set Operations ---");
        Set<String> colors = new HashSet<>();
        
        // Adding elements
        boolean added1 = colors.add("Red");
        boolean added2 = colors.add("Blue");
        boolean added3 = colors.add("Red"); // Duplicate - will be ignored
        
        System.out.println("Added 'Red': " + added1);      // true
        System.out.println("Added 'Blue': " + added2);     // true
        System.out.println("Added 'Red' again: " + added3); // false (duplicate)
        
        System.out.println("Set contents: " + colors);
        System.out.println("Set size: " + colors.size());
        
        // Membership testing
        System.out.println("Contains 'Red': " + colors.contains("Red"));
        System.out.println("Contains 'Green': " + colors.contains("Green"));
        
        // Removing elements
        boolean removed = colors.remove("Blue");
        System.out.println("Removed 'Blue': " + removed);
        System.out.println("Final set: " + colors);
        
        // Set vs List comparison
        System.out.println("\n--- Set vs List Comparison ---");
        List<String> list = Arrays.asList("A", "B", "A", "C", "B");
        Set<String> set = new HashSet<>(list);
        
        System.out.println("Original list: " + list);
        System.out.println("Set from list: " + set);
        System.out.println("List size: " + list.size() + ", Set size: " + set.size());
        System.out.println("Set automatically removed duplicates");
    }
    
    static void demonstrateHashSet() {
        System.out.println("\n=== HashSet Implementation ===");
        
        System.out.println("HASHSET CHARACTERISTICS:");
        System.out.println("- Hash table implementation");
        System.out.println("- Average O(1) for add, remove, contains");
        System.out.println("- No ordering guarantees");
        System.out.println("- Allows one null element");
        System.out.println("- Not synchronized (not thread-safe)");
        System.out.println("- Default initial capacity: 16, load factor: 0.75");
        
        // HashSet creation
        System.out.println("\n--- HashSet Creation ---");
        HashSet<Integer> hashSet = new HashSet<>(); // Default capacity
        HashSet<Integer> hashSetWithCapacity = new HashSet<>(32); // Initial capacity 32
        HashSet<Integer> hashSetWithLoadFactor = new HashSet<>(16, 0.8f); // Capacity 16, load factor 0.8
        HashSet<Integer> hashSetFromCollection = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        
        System.out.println("Default HashSet: " + hashSet);
        System.out.println("From collection: " + hashSetFromCollection);
        
        // Demonstrate no ordering
        System.out.println("\n--- No Ordering Guarantee ---");
        HashSet<String> fruits = new HashSet<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add("Date");
        fruits.add("Elderberry");
        
        System.out.println("HashSet (no guaranteed order): " + fruits);
        
        // Multiple iterations might show different orders
        System.out.println("Multiple iterations:");
        for (int i = 0; i < 3; i++) {
            System.out.print("  Iteration " + (i + 1) + ": ");
            for (String fruit : fruits) {
                System.out.print(fruit + " ");
            }
            System.out.println();
        }
        
        // Null handling
        System.out.println("\n--- Null Handling ---");
        HashSet<String> nullSet = new HashSet<>();
        nullSet.add("Element1");
        nullSet.add(null);
        nullSet.add("Element2");
        nullSet.add(null); // Duplicate null ignored
        
        System.out.println("HashSet with null: " + nullSet);
        System.out.println("Contains null: " + nullSet.contains(null));
        
        // Performance characteristics
        demonstrateHashSetPerformance();
    }
    
    static void demonstrateHashSetPerformance() {
        System.out.println("\n--- HashSet Performance ---");
        
        HashSet<Integer> hashSet = new HashSet<>();
        int size = 100000;
        
        // Test add performance
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        long addTime = System.nanoTime() - startTime;
        
        // Test contains performance
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashSet.contains(i);
        }
        long containsTime = System.nanoTime() - startTime;
        
        // Test remove performance
        startTime = System.nanoTime();
        for (int i = 0; i < size / 2; i++) {
            hashSet.remove(i);
        }
        long removeTime = System.nanoTime() - startTime;
        
        System.out.printf("HashSet Performance (size: %d):%n", size);
        System.out.printf("  Add %d elements: %.2f ms%n", size, addTime / 1_000_000.0);
        System.out.printf("  Contains check %d times: %.2f ms%n", size, containsTime / 1_000_000.0);
        System.out.printf("  Remove %d elements: %.2f ms%n", size / 2, removeTime / 1_000_000.0);
    }
    
    static void demonstrateTreeSet() {
        System.out.println("\n=== TreeSet Implementation ===");
        
        System.out.println("TREESET CHARACTERISTICS:");
        System.out.println("- Red-black tree (self-balancing BST) implementation");
        System.out.println("- O(log n) for add, remove, contains");
        System.out.println("- Elements stored in sorted order");
        System.out.println("- Elements must be Comparable or use custom Comparator");
        System.out.println("- Does not allow null elements");
        System.out.println("- Not synchronized (not thread-safe)");
        
        // TreeSet creation
        System.out.println("\n--- TreeSet Creation ---");
        TreeSet<Integer> treeSet = new TreeSet<>();
        TreeSet<String> treeSetFromCollection = new TreeSet<>(Arrays.asList("Zebra", "Apple", "Banana"));
        TreeSet<String> treeSetWithComparator = new TreeSet<>(Collections.reverseOrder());
        
        System.out.println("Empty TreeSet: " + treeSet);
        System.out.println("From collection (auto-sorted): " + treeSetFromCollection);
        
        // Demonstrate automatic sorting
        System.out.println("\n--- Automatic Sorting ---");
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(5);
        numbers.add(2);
        numbers.add(8);
        numbers.add(1);
        numbers.add(9);
        numbers.add(3);
        
        System.out.println("TreeSet (automatically sorted): " + numbers);
        
        // TreeSet with custom comparator
        System.out.println("\n--- Custom Comparator ---");
        treeSetWithComparator.add("Apple");
        treeSetWithComparator.add("Banana");
        treeSetWithComparator.add("Cherry");
        
        System.out.println("TreeSet with reverse order: " + treeSetWithComparator);
        
        // TreeSet-specific operations
        System.out.println("\n--- TreeSet-Specific Operations ---");
        TreeSet<Integer> sortedNumbers = new TreeSet<>(Arrays.asList(1, 3, 5, 7, 9, 11, 13, 15));
        
        System.out.println("Original TreeSet: " + sortedNumbers);
        System.out.println("First (lowest): " + sortedNumbers.first());
        System.out.println("Last (highest): " + sortedNumbers.last());
        System.out.println("Lower than 7: " + sortedNumbers.lower(7));  // Largest element < 7
        System.out.println("Floor of 8: " + sortedNumbers.floor(8));     // Largest element <= 8
        System.out.println("Ceiling of 8: " + sortedNumbers.ceiling(8)); // Smallest element >= 8
        System.out.println("Higher than 7: " + sortedNumbers.higher(7)); // Smallest element > 7
        
        // Range operations
        System.out.println("\n--- Range Operations ---");
        SortedSet<Integer> headSet = sortedNumbers.headSet(7);    // Elements < 7
        SortedSet<Integer> tailSet = sortedNumbers.tailSet(7);    // Elements >= 7
        SortedSet<Integer> subSet = sortedNumbers.subSet(5, 11);  // Elements >= 5 and < 11
        
        System.out.println("Head set (< 7): " + headSet);
        System.out.println("Tail set (>= 7): " + tailSet);
        System.out.println("Sub set [5, 11): " + subSet);
        
        // Poll operations (remove and return)
        System.out.println("\n--- Poll Operations ---");
        TreeSet<Integer> pollSet = new TreeSet<>(Arrays.asList(10, 20, 30, 40, 50));
        System.out.println("Original: " + pollSet);
        
        Integer first = pollSet.pollFirst(); // Remove and return first
        Integer last = pollSet.pollLast();   // Remove and return last
        
        System.out.println("Polled first: " + first + ", last: " + last);
        System.out.println("Remaining: " + pollSet);
        
        // Null handling
        System.out.println("\n--- Null Handling ---");
        try {
            TreeSet<String> nullTest = new TreeSet<>();
            nullTest.add(null); // This will throw NullPointerException
        } catch (NullPointerException e) {
            System.out.println("TreeSet does not allow null elements: " + e.getClass().getSimpleName());
        }
        
        // Custom objects with TreeSet
        demonstrateTreeSetWithCustomObjects();
    }
    
    static void demonstrateTreeSetWithCustomObjects() {
        System.out.println("\n--- TreeSet with Custom Objects ---");
        
        // Person class implements Comparable
        class Person implements Comparable<Person> {
            String name;
            int age;
            
            Person(String name, int age) {
                this.name = name;
                this.age = age;
            }
            
            @Override
            public int compareTo(Person other) {
                return Integer.compare(this.age, other.age); // Sort by age
            }
            
            @Override
            public String toString() {
                return name + "(" + age + ")";
            }
        }
        
        TreeSet<Person> people = new TreeSet<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Charlie", 35));
        people.add(new Person("David", 20));
        
        System.out.println("People sorted by age: " + people);
        
        // TreeSet with custom Comparator
        TreeSet<Person> peopleByName = new TreeSet<>(Comparator.comparing(p -> p.name));
        peopleByName.addAll(people);
        
        System.out.println("People sorted by name: " + peopleByName);
    }
    
    static void demonstrateLinkedHashSet() {
        System.out.println("\n=== LinkedHashSet Implementation ===");
        
        System.out.println("LINKEDHASHSET CHARACTERISTICS:");
        System.out.println("- Hash table + doubly-linked list implementation");
        System.out.println("- Maintains insertion order");
        System.out.println("- Slightly slower than HashSet due to linked list overhead");
        System.out.println("- O(1) for add, remove, contains (like HashSet)");
        System.out.println("- Allows one null element");
        System.out.println("- Not synchronized (not thread-safe)");
        
        // LinkedHashSet creation and insertion order
        System.out.println("\n--- Insertion Order Maintenance ---");
        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();
        
        linkedHashSet.add("First");
        linkedHashSet.add("Second");
        linkedHashSet.add("Third");
        linkedHashSet.add("Fourth");
        linkedHashSet.add("Second"); // Duplicate ignored, order unchanged
        
        System.out.println("LinkedHashSet (maintains insertion order): " + linkedHashSet);
        
        // Compare with HashSet
        HashSet<String> hashSet = new HashSet<>(linkedHashSet);
        System.out.println("Same elements in HashSet (no order guarantee): " + hashSet);
        
        // Iteration order consistency
        System.out.println("\n--- Consistent Iteration Order ---");
        System.out.println("Multiple iterations of LinkedHashSet:");
        for (int i = 0; i < 3; i++) {
            System.out.print("  Iteration " + (i + 1) + ": ");
            for (String item : linkedHashSet) {
                System.out.print(item + " ");
            }
            System.out.println();
        }
        
        // Performance comparison with HashSet
        System.out.println("\n--- Performance vs HashSet ---");
        int size = 50000;
        
        // LinkedHashSet performance
        LinkedHashSet<Integer> lhs = new LinkedHashSet<>();
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            lhs.add(i);
        }
        long lhsTime = System.nanoTime() - startTime;
        
        // HashSet performance
        HashSet<Integer> hs = new HashSet<>();
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hs.add(i);
        }
        long hsTime = System.nanoTime() - startTime;
        
        System.out.printf("Add %d elements:%n", size);
        System.out.printf("  LinkedHashSet: %.2f ms%n", lhsTime / 1_000_000.0);
        System.out.printf("  HashSet: %.2f ms%n", hsTime / 1_000_000.0);
        System.out.printf("  LinkedHashSet is %.1fx slower%n", (double) lhsTime / hsTime);
    }
    
    static void demonstrateSetOperations() {
        System.out.println("\n=== Set Operations ===");
        
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));
        
        System.out.println("Set 1: " + set1);
        System.out.println("Set 2: " + set2);
        
        // Union (addAll)
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union (set1 ∪ set2): " + union);
        
        // Intersection (retainAll)
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection (set1 ∩ set2): " + intersection);
        
        // Difference (removeAll)
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference (set1 - set2): " + difference);
        
        // Symmetric difference
        Set<Integer> symmetricDiff = new HashSet<>(set1);
        symmetricDiff.addAll(set2);
        Set<Integer> intersectionCopy = new HashSet<>(set1);
        intersectionCopy.retainAll(set2);
        symmetricDiff.removeAll(intersectionCopy);
        System.out.println("Symmetric difference (set1 ⊕ set2): " + symmetricDiff);
        
        // Subset checking
        Set<Integer> subset = new HashSet<>(Arrays.asList(2, 3));
        boolean isSubset = set1.containsAll(subset);
        System.out.println("Is {2, 3} subset of set1: " + isSubset);
        
        // Disjoint sets
        Set<Integer> disjointSet = new HashSet<>(Arrays.asList(10, 11, 12));
        boolean areDisjoint = Collections.disjoint(set1, disjointSet);
        System.out.println("Are set1 and {10, 11, 12} disjoint: " + areDisjoint);
    }
    
    static void demonstratePerformanceComparison() {
        System.out.println("\n=== Performance Comparison ===");
        
        int size = 100000;
        
        // Initialize sets
        HashSet<Integer> hashSet = new HashSet<>();
        TreeSet<Integer> treeSet = new TreeSet<>();
        LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();
        
        // Test addition performance
        System.out.println("--- Addition Performance ---");
        
        long startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        long hashSetAddTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            treeSet.add(i);
        }
        long treeSetAddTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            linkedHashSet.add(i);
        }
        long linkedHashSetAddTime = System.nanoTime() - startTime;
        
        System.out.printf("Add %d elements:%n", size);
        System.out.printf("  HashSet: %.2f ms%n", hashSetAddTime / 1_000_000.0);
        System.out.printf("  TreeSet: %.2f ms%n", treeSetAddTime / 1_000_000.0);
        System.out.printf("  LinkedHashSet: %.2f ms%n", linkedHashSetAddTime / 1_000_000.0);
        
        // Test lookup performance
        System.out.println("\n--- Lookup Performance ---");
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            hashSet.contains(i);
        }
        long hashSetLookupTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            treeSet.contains(i);
        }
        long treeSetLookupTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i < size; i++) {
            linkedHashSet.contains(i);
        }
        long linkedHashSetLookupTime = System.nanoTime() - startTime;
        
        System.out.printf("Lookup %d elements:%n", size);
        System.out.printf("  HashSet: %.2f ms%n", hashSetLookupTime / 1_000_000.0);
        System.out.printf("  TreeSet: %.2f ms%n", treeSetLookupTime / 1_000_000.0);
        System.out.printf("  LinkedHashSet: %.2f ms%n", linkedHashSetLookupTime / 1_000_000.0);
        
        // Summary
        System.out.println("\n--- Performance Summary ---");
        System.out.println("HashSet: Fastest for add/contains, no ordering");
        System.out.println("TreeSet: Slower but maintains sorted order");
        System.out.println("LinkedHashSet: Slightly slower than HashSet, maintains insertion order");
    }
    
    static void demonstrateEqualsAndHashCode() {
        System.out.println("\n=== Equals and HashCode in Sets ===");
        
        // Custom class without proper equals/hashCode
        class BadStudent {
            String name;
            int id;
            
            BadStudent(String name, int id) {
                this.name = name;
                this.id = id;
            }
            
            @Override
            public String toString() {
                return name + "(" + id + ")";
            }
            // Missing equals() and hashCode() - uses Object's implementation
        }
        
        // Custom class with proper equals/hashCode
        class GoodStudent {
            String name;
            int id;
            
            GoodStudent(String name, int id) {
                this.name = name;
                this.id = id;
            }
            
            @Override
            public boolean equals(Object obj) {
                if (this == obj) return true;
                if (obj == null || getClass() != obj.getClass()) return false;
                GoodStudent student = (GoodStudent) obj;
                return id == student.id && Objects.equals(name, student.name);
            }
            
            @Override
            public int hashCode() {
                return Objects.hash(name, id);
            }
            
            @Override
            public String toString() {
                return name + "(" + id + ")";
            }
        }
        
        // Demonstrate problem with bad equals/hashCode
        System.out.println("--- Without Proper equals/hashCode ---");
        Set<BadStudent> badSet = new HashSet<>();
        BadStudent student1 = new BadStudent("Alice", 123);
        BadStudent student2 = new BadStudent("Alice", 123); // Same data, different object
        
        badSet.add(student1);
        badSet.add(student2);
        
        System.out.println("Bad set size: " + badSet.size()); // Will be 2 (should be 1)
        System.out.println("Bad set contents: " + badSet);
        System.out.println("Contains student1: " + badSet.contains(student1));
        System.out.println("Contains student2: " + badSet.contains(student2));
        
        // Demonstrate proper equals/hashCode
        System.out.println("\n--- With Proper equals/hashCode ---");
        Set<GoodStudent> goodSet = new HashSet<>();
        GoodStudent goodStudent1 = new GoodStudent("Alice", 123);
        GoodStudent goodStudent2 = new GoodStudent("Alice", 123); // Same data, different object
        
        goodSet.add(goodStudent1);
        goodSet.add(goodStudent2);
        
        System.out.println("Good set size: " + goodSet.size()); // Will be 1 (correct)
        System.out.println("Good set contents: " + goodSet);
        System.out.println("Contains goodStudent1: " + goodSet.contains(goodStudent1));
        System.out.println("Contains goodStudent2: " + goodSet.contains(goodStudent2));
        
        System.out.println("\n--- Importance of hashCode/equals Contract ---");
        System.out.println("1. If two objects are equal (equals() returns true), they must have the same hashCode()");
        System.out.println("2. If two objects have the same hashCode(), they may or may not be equal");
        System.out.println("3. Consistent: multiple calls to hashCode() must return the same value");
        System.out.println("4. If equals() is overridden, hashCode() must also be overridden");
    }
    
    static void demonstrateThreadSafety() {
        System.out.println("\n=== Thread Safety in Sets ===");
        
        System.out.println("THREAD SAFETY OPTIONS:");
        System.out.println("1. Collections.synchronizedSet() - Wrapper");
        System.out.println("2. ConcurrentSkipListSet - Concurrent sorted set");
        System.out.println("3. CopyOnWriteArraySet - Concurrent set (expensive writes)");
        System.out.println("4. External synchronization");
        
        // Synchronized wrapper
        System.out.println("\n--- Synchronized Wrapper ---");
        Set<String> unsafeSet = new HashSet<>();
        Set<String> safeSet = Collections.synchronizedSet(unsafeSet);
        
        safeSet.add("Element1");
        safeSet.add("Element2");
        
        System.out.println("Synchronized set: " + safeSet);
        System.out.println("Type: " + safeSet.getClass().getSimpleName());
        
        // ConcurrentSkipListSet
        System.out.println("\n--- ConcurrentSkipListSet ---");
        Set<Integer> concurrentSet = new ConcurrentSkipListSet<>();
        concurrentSet.add(3);
        concurrentSet.add(1);
        concurrentSet.add(4);
        concurrentSet.add(2);
        
        System.out.println("ConcurrentSkipListSet: " + concurrentSet);
        System.out.println("- Thread-safe and sorted");
        System.out.println("- Based on skip list data structure");
        System.out.println("- O(log n) operations");
        
        // Important note about iteration
        System.out.println("\n--- Important: Iteration Synchronization ---");
        System.out.println("For Collections.synchronizedSet(), manual synchronization needed for iteration:");
        System.out.println("synchronized(safeSet) {");
        System.out.println("    for (String item : safeSet) {");
        System.out.println("        // Process item safely");
        System.out.println("    }");
        System.out.println("}");
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use HashSet for fast membership testing when order doesn't matter
- Use TreeSet when you need sorted unique elements
- Use LinkedHashSet when you need unique elements with insertion order
- Always override both equals() and hashCode() for custom objects in Sets
- Consider initial capacity for HashSet to avoid rehashing

**Don'ts:**
- Don't use TreeSet with objects that don't implement Comparable without providing Comparator
- Don't modify objects used as Set elements in ways that affect equals/hashCode
- Don't assume any ordering in HashSet
- Don't add null to TreeSet (throws NullPointerException)
- Don't use raw types (avoid `Set set = new HashSet()`)

**Common Pitfalls:**
- Violating equals/hashCode contract causing duplicate elements in HashSet
- ClassCastException in TreeSet when elements are not comparable
- NullPointerException when adding null to TreeSet
- Performance issues from using TreeSet when HashSet would suffice
- Thread safety issues in multi-threaded environments

## 5. Summary

- **Set interface** ensures no duplicate elements using equals() method for comparison
- **HashSet**: Fast O(1) operations, no ordering, allows one null element
- **TreeSet**: Sorted order O(log n) operations, no null elements, requires Comparable/Comparator
- **LinkedHashSet**: Maintains insertion order with O(1) operations, slight overhead over HashSet
- **Set operations**: Union (addAll), intersection (retainAll), difference (removeAll)
- **equals/hashCode contract** is crucial for proper Set behavior with custom objects
- **Thread safety** available through synchronized wrappers or concurrent implementations
- **Choose implementation** based on ordering needs and performance requirements

## 6. Tricky Interview Questions

1. **Set vs List**: What is the difference between List and Set? When would you use each?

2. **HashSet vs TreeSet**: What is the difference between HashSet and TreeSet? Compare their performance characteristics.

3. **Set vs Map**: What is the difference between Set and Map? How are they related?

4. **HashSet vs HashMap**: What is the difference between HashSet and HashMap? How does HashSet internally work?

5. **equals/hashCode**: What is the importance of hashCode() and equals() methods in Set implementations? Show what happens when they're not properly implemented.

6. **TreeSet Requirements**: Why does TreeSet require elements to be Comparable or provide a Comparator? What happens if you violate this?

7. **Null Handling**: Which Set implementations allow null elements and which don't? Explain why TreeSet doesn't allow null.

8. **Performance Analysis**: Compare the time complexity of add(), remove(), and contains() operations for HashSet, TreeSet, and LinkedHashSet.

9. **Set Operations**: How do you perform mathematical set operations (union, intersection, difference) using Java Set implementations?

10. **Thread Safety**: How do you make a Set thread-safe? Compare different approaches and their trade-offs.

11. **Memory Efficiency**: Which Set implementation is most memory-efficient? Consider both the data structure overhead and the objects stored.
