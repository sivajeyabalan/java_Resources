## 1. Topic Overview

- Mastering collectors unlocks powerful data aggregation with streams, including grouping, partitioning, mapping, and building custom collectors.

## 2 . Topic definition

- WHAT: Built-in collectors like `groupingBy`, `partitioningBy`, `mapping`, `flatMapping`, `teeing`, and writing custom `Collector`.
- WHY: Express complex aggregations concisely and efficiently.
- HOW: Compose collectors; understand mutable reduction; implement `Collector` with supplier/accumulator/combiner/finisher/characteristics.
- WHEN/WHERE: Reporting, analytics, transformation pipelines.
- WHAT IF: Misusing parallel with non-thread-safe collectors causes data races; excessive boxing/unboxing hurts performance.

## 3. Deep Dive with Examples

```java
import java.util.*;
import java.util.stream.*;

record Person(String city, int age) {}

class Grouping {
    public static void main(String[] args) {
        List<Person> people = List.of(new Person("BLR", 30), new Person("BLR", 25), new Person("HYD", 40));
        Map<String, Double> avgAgeByCity = people.stream()
            .collect(Collectors.groupingBy(Person::city, Collectors.averagingInt(Person::age)));
        System.out.println(avgAgeByCity);
    }
}
```

```java
// Partitioning and mapping
import java.util.*;
import java.util.stream.*;

class PartitionMap {
    public static void main(String[] args) {
        List<Integer> nums = List.of(1,2,3,4,5,6);
        Map<Boolean, List<String>> evenLabels = nums.stream()
            .collect(Collectors.partitioningBy(n -> n % 2 == 0, Collectors.mapping(n -> "N=" + n, Collectors.toList())));
        System.out.println(evenLabels);
    }
}
```

```java
// Custom collector: summing squares
import java.util.*;
import java.util.stream.*;

class SumSquaresCollector implements Collector<Integer, int[], Integer> {
    public Supplier<int[]> supplier() { return () -> new int[1]; }
    public BiConsumer<int[], Integer> accumulator() { return (a, x) -> a[0] += x * x; }
    public BinaryOperator<int[]> combiner() { return (a, b) -> { a[0] += b[0]; return a; }; }
    public Function<int[], Integer> finisher() { return a -> a[0]; }
    public Set<Characteristics> characteristics() { return EnumSet.noneOf(Characteristics.class); }
}

class CustomCollectorDemo {
    public static void main(String[] args) {
        int sumSquares = List.of(1,2,3,4).stream().collect(new SumSquaresCollector());
        System.out.println(sumSquares);
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer specialized collectors (e.g., `summingInt`) over generic `reduce`.
- Ensure collectors used in parallel are concurrent or combined safely.
- Avoid `groupingByConcurrent` unless map concurrency semantics are acceptable.
- Be mindful of memory when grouping large datasets; stream and limit when possible.

## 5. Summary

- Collectors provide composable, efficient aggregation; custom collectors cover special cases.

## 6. Tricky Interview Questions

1. Compare `reduce` vs `collect` for aggregations; when to choose each?
2. Show `groupingBy` + downstream collectors to compute multiple metrics.
3. How to write a parallel-safe custom collector?

