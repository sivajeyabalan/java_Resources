## 1. Topic Overview

- High-performance in-memory caching with Caffeine (modern) and Guava (legacy), covering eviction and expiration strategies.

## 2 . Topic definition

- WHAT: Local caches with size/time-based eviction, refresh, and statistics.
- WHY: Reduce latency and load for repeated expensive lookups.
- HOW: Build caches with policies; use `get(key, k -> loader)`; handle nulls and exceptions.
- WHEN/WHERE: Hot lookups, config, small reference datasets.

## 3. Deep Dive with Examples

```java
// Caffeine example
import com.github.benmanes.caffeine.cache.*;

class CaffeineDemo {
    public static void main(String[] args) {
        Cache<String, String> cache = Caffeine.newBuilder()
            .maximumSize(10_000)
            .expireAfterWrite(java.time.Duration.ofMinutes(10))
            .recordStats()
            .build();
        String v = cache.get("k", k -> expensive(k));
        System.out.println(v);
        System.out.println(cache.stats());
    }
    static String expensive(String k) { return "v:" + k; }
}
```

## 4. Best Practices & Pitfalls

- Choose bounded caches; avoid caching unbounded unique keys.
- Prefer `expireAfterWrite` or `expireAfterAccess` based on usage.
- Monitor hit ratios and evictions; tune sizes based on data and memory.

## 5. Summary

- Caffeine provides fast, feature-rich local caching suitable for many app use cases.

## 6. Tricky Interview Questions

1. How do you prevent cache stampede? Show `get(key, loader)` usage.
2. What metrics indicate a cache is effective or mis-sized?

