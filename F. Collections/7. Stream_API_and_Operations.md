## 1. Topic Overview

The Stream API, introduced in Java 8, provides a functional approach to processing collections of data. Streams represent a sequence of elements that support sequential and parallel aggregate operations. They work seamlessly with lambda expressions and method references to enable concise, readable, and efficient data processing. Streams are lazy (operations are not executed until a terminal operation is invoked) and can be processed in parallel for better performance on multi-core systems.

## 2. Topic Definition

- **What**: Functional-style operations on streams of elements, supporting sequential and parallel processing
- **Why**: Enables declarative programming, improves code readability, supports parallel processing, provides rich set of operations
- **How**: Through intermediate operations (filter, map, sorted) and terminal operations (collect, forEach, reduce)
- **When/Where**: Data processing, filtering, transformation, aggregation, parallel computation, functional programming
- **What If**:
  - Intermediate operations are lazy and return new streams
  - Terminal operations trigger execution and return results
  - Streams can only be consumed once
  - Parallel streams can improve performance for CPU-intensive operations
  - Operations can be chained for complex data processing pipelines
- **Examples**:
  - Filtering: `list.stream().filter(x -> x > 5).collect(Collectors.toList())`
  - Mapping: `names.stream().map(String::toUpperCase).forEach(System.out::println)`
  - Reducing: `numbers.stream().reduce(0, Integer::sum)`

## 3. Deep Dive with Examples

```java
// File: StreamAPIDemo.java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class StreamAPIDemo {
    public static void main(String[] args) {
        demonstrateStreamBasics();
        demonstrateStreamCreation();
        demonstrateIntermediateOperations();
        demonstrateTerminalOperations();
        demonstrateCollectors();
        demonstrateParallelStreams();
        demonstrateAdvancedStreamOperations();
    }
    
    static void demonstrateStreamBasics() {
        System.out.println("=== Stream API Basics ===");
        
        System.out.println("STREAM CHARACTERISTICS:");
        System.out.println("1. Sequence of elements from a source");
        System.out.println("2. Functional-style operations");
        System.out.println("3. Lazy evaluation (intermediate operations)");
        System.out.println("4. Can be consumed only once");
        System.out.println("5. Support for sequential and parallel processing");
        
        // Basic stream example
        System.out.println("\n--- Basic Stream Example ---");
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");
        
        // Traditional approach
        List<String> longNamesTraditional = new ArrayList<>();
        for (String name : names) {
            if (name.length() > 4) {
                longNamesTraditional.add(name.toUpperCase());
            }
        }
        Collections.sort(longNamesTraditional);
        System.out.println("Traditional approach: " + longNamesTraditional);
        
        // Stream approach
        List<String> longNamesStream = names.stream()
                                          .filter(name -> name.length() > 4)
                                          .map(String::toUpperCase)
                                          .sorted()
                                          .collect(Collectors.toList());
        System.out.println("Stream approach: " + longNamesStream);
        
        // Stream package location
        System.out.println("\n--- Stream API Package ---");
        System.out.println("Stream API classes and interfaces are in java.util.stream package");
        System.out.println("Main interfaces: Stream, IntStream, LongStream, DoubleStream");
        System.out.println("Main classes: Collectors, StreamSupport");
        
        // Method added to Collection interface
        System.out.println("\n--- Collection Interface Enhancement ---");
        System.out.println("stream() method was added to Collection interface for Stream API");
        System.out.println("Also parallelStream() method for parallel processing");
        
        // Demonstrate stream() method
        Stream<String> sequentialStream = names.stream();
        Stream<String> parallelStream = names.parallelStream();
        
        System.out.println("Sequential stream created from collection");
        System.out.println("Parallel stream created from collection");
    }
    
    static void demonstrateStreamCreation() {
        System.out.println("\n=== Stream Creation ===");
        
        // From collections
        System.out.println("--- From Collections ---");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Stream<Integer> fromList = numbers.stream();
        
        Set<String> stringSet = Set.of("A", "B", "C");
        Stream<String> fromSet = stringSet.stream();
        
        System.out.println("Streams created from List and Set");
        
        // From arrays
        System.out.println("\n--- From Arrays ---");
        String[] array = {"X", "Y", "Z"};
        Stream<String> fromArray = Arrays.stream(array);
        Stream<String> fromArrayRange = Arrays.stream(array, 1, 3); // Elements 1 to 2
        
        System.out.println("Array stream: " + fromArray.collect(Collectors.toList()));
        System.out.println("Array range stream: " + fromArrayRange.collect(Collectors.toList()));
        
        // Using Stream.of()
        System.out.println("\n--- Using Stream.of() ---");
        Stream<String> streamOf = Stream.of("One", "Two", "Three");
        Stream<Integer> intStreamOf = Stream.of(10, 20, 30, 40);
        
        System.out.println("Stream.of strings: " + streamOf.collect(Collectors.toList()));
        System.out.println("Stream.of integers: " + intStreamOf.collect(Collectors.toList()));
        
        // Empty streams
        System.out.println("\n--- Empty Streams ---");
        Stream<String> emptyStream = Stream.empty();
        Stream<Integer> emptyIntStream = Stream.<Integer>empty();
        
        System.out.println("Empty stream count: " + emptyStream.count());
        
        // Infinite streams
        System.out.println("\n--- Infinite Streams ---");
        
        // Stream.generate()
        Stream<Double> randomNumbers = Stream.generate(Math::random).limit(5);
        System.out.println("Random numbers: " + 
            randomNumbers.map(d -> String.format("%.3f", d)).collect(Collectors.toList()));
        
        // Stream.iterate()
        Stream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2).limit(10);
        System.out.println("Even numbers: " + evenNumbers.collect(Collectors.toList()));
        
        // Stream.iterate() with condition (Java 9+)
        Stream<Integer> numbersUntil100 = Stream.iterate(1, n -> n < 100, n -> n * 2);
        System.out.println("Powers of 2 < 100: " + numbersUntil100.collect(Collectors.toList()));
        
        // Primitive streams
        System.out.println("\n--- Primitive Streams ---");
        IntStream intStream = IntStream.range(1, 6); // 1 to 5
        IntStream intStreamClosed = IntStream.rangeClosed(1, 5); // 1 to 5 inclusive
        LongStream longStream = LongStream.of(100L, 200L, 300L);
        DoubleStream doubleStream = DoubleStream.of(1.1, 2.2, 3.3);
        
        System.out.println("IntStream range: " + intStream.boxed().collect(Collectors.toList()));
        System.out.println("IntStream rangeClosed: " + intStreamClosed.boxed().collect(Collectors.toList()));
        System.out.println("LongStream: " + longStream.boxed().collect(Collectors.toList()));
        System.out.println("DoubleStream: " + doubleStream.boxed().collect(Collectors.toList()));
    }
    
    static void demonstrateIntermediateOperations() {
        System.out.println("\n=== Intermediate Operations ===");
        
        System.out.println("INTERMEDIATE OPERATIONS:");
        System.out.println("- Return a new Stream");
        System.out.println("- Lazy evaluation (not executed until terminal operation)");
        System.out.println("- Can be chained together");
        System.out.println("- Examples: filter, map, sorted, distinct, limit, skip");
        
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry", "apple", "fig");
        
        // filter() - filters elements based on predicate
        System.out.println("\n--- filter() ---");
        List<String> longWords = words.stream()
                                     .filter(word -> word.length() > 5)
                                     .collect(Collectors.toList());
        System.out.println("Words longer than 5 chars: " + longWords);
        
        // map() - transforms elements
        System.out.println("\n--- map() ---");
        List<Integer> wordLengths = words.stream()
                                        .map(String::length)
                                        .collect(Collectors.toList());
        System.out.println("Word lengths: " + wordLengths);
        
        List<String> upperCaseWords = words.stream()
                                          .map(String::toUpperCase)
                                          .collect(Collectors.toList());
        System.out.println("Uppercase words: " + upperCaseWords);
        
        // flatMap() - flattens nested structures
        System.out.println("\n--- flatMap() ---");
        List<List<String>> nestedLists = Arrays.asList(
            Arrays.asList("a", "b"),
            Arrays.asList("c", "d", "e"),
            Arrays.asList("f")
        );
        
        List<String> flattened = nestedLists.stream()
                                           .flatMap(List::stream)
                                           .collect(Collectors.toList());
        System.out.println("Flattened: " + flattened);
        
        // distinct() - removes duplicates
        System.out.println("\n--- distinct() ---");
        List<String> uniqueWords = words.stream()
                                       .distinct()
                                       .collect(Collectors.toList());
        System.out.println("Unique words: " + uniqueWords);
        
        // sorted() - sorts elements
        System.out.println("\n--- sorted() ---");
        List<String> sortedWords = words.stream()
                                       .distinct()
                                       .sorted()
                                       .collect(Collectors.toList());
        System.out.println("Sorted words: " + sortedWords);
        
        List<String> sortedByLength = words.stream()
                                          .distinct()
                                          .sorted(Comparator.comparing(String::length))
                                          .collect(Collectors.toList());
        System.out.println("Sorted by length: " + sortedByLength);
        
        // limit() and skip()
        System.out.println("\n--- limit() and skip() ---");
        List<String> firstThree = words.stream()
                                      .limit(3)
                                      .collect(Collectors.toList());
        System.out.println("First 3 words: " + firstThree);
        
        List<String> skipTwo = words.stream()
                                   .skip(2)
                                   .collect(Collectors.toList());
        System.out.println("Skip first 2: " + skipTwo);
        
        // peek() - for debugging/side effects
        System.out.println("\n--- peek() ---");
        List<String> processed = words.stream()
                                     .filter(word -> word.length() > 4)
                                     .peek(word -> System.out.println("Filtered: " + word))
                                     .map(String::toUpperCase)
                                     .peek(word -> System.out.println("Mapped: " + word))
                                     .collect(Collectors.toList());
        System.out.println("Final result: " + processed);
        
        // Chaining operations
        System.out.println("\n--- Chaining Operations ---");
        List<String> complexProcessing = words.stream()
                                            .filter(word -> word.length() > 4)
                                            .map(String::toUpperCase)
                                            .distinct()
                                            .sorted()
                                            .limit(3)
                                            .collect(Collectors.toList());
        System.out.println("Complex processing result: " + complexProcessing);
    }
    
    static void demonstrateTerminalOperations() {
        System.out.println("\n=== Terminal Operations ===");
        
        System.out.println("TERMINAL OPERATIONS:");
        System.out.println("- Trigger the execution of stream pipeline");
        System.out.println("- Return a result or produce side effects");
        System.out.println("- Stream cannot be used after terminal operation");
        System.out.println("- Examples: collect, forEach, reduce, count, min, max");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // forEach() - performs action on each element
        System.out.println("\n--- forEach() ---");
        System.out.print("Numbers: ");
        numbers.stream().forEach(n -> System.out.print(n + " "));
        System.out.println();
        
        // count() - counts elements
        System.out.println("\n--- count() ---");
        long evenCount = numbers.stream()
                               .filter(n -> n % 2 == 0)
                               .count();
        System.out.println("Count of even numbers: " + evenCount);
        System.out.println("count() is a terminal operation");
        
        // min() and max()
        System.out.println("\n--- min() and max() ---");
        Optional<Integer> min = numbers.stream().min(Integer::compareTo);
        Optional<Integer> max = numbers.stream().max(Integer::compareTo);
        
        System.out.println("Minimum: " + min.orElse(0));
        System.out.println("Maximum: " + max.orElse(0));
        
        // findFirst() and findAny()
        System.out.println("\n--- findFirst() and findAny() ---");
        Optional<Integer> firstEven = numbers.stream()
                                           .filter(n -> n % 2 == 0)
                                           .findFirst();
        
        Optional<Integer> anyOdd = numbers.stream()
                                         .filter(n -> n % 2 == 1)
                                         .findAny();
        
        System.out.println("First even number: " + firstEven.orElse(-1));
        System.out.println("Any odd number: " + anyOdd.orElse(-1));
        
        // allMatch(), anyMatch(), noneMatch()
        System.out.println("\n--- Matching Operations ---");
        boolean allPositive = numbers.stream().allMatch(n -> n > 0);
        boolean anyGreaterThan5 = numbers.stream().anyMatch(n -> n > 5);
        boolean noneNegative = numbers.stream().noneMatch(n -> n < 0);
        
        System.out.println("All positive: " + allPositive);
        System.out.println("Any greater than 5: " + anyGreaterThan5);
        System.out.println("None negative: " + noneNegative);
        
        // reduce() - combines elements
        System.out.println("\n--- reduce() ---");
        
        // Sum using reduce
        Optional<Integer> sum = numbers.stream().reduce(Integer::sum);
        System.out.println("Sum using reduce: " + sum.orElse(0));
        
        // Sum with identity
        Integer sumWithIdentity = numbers.stream().reduce(0, Integer::sum);
        System.out.println("Sum with identity: " + sumWithIdentity);
        
        // Product using reduce
        Integer product = numbers.stream().reduce(1, (a, b) -> a * b);
        System.out.println("Product: " + product);
        
        // String concatenation
        List<String> words = Arrays.asList("Hello", "Stream", "API");
        String concatenated = words.stream().reduce("", (a, b) -> a + " " + b);
        System.out.println("Concatenated: " + concatenated.trim());
        
        // toArray()
        System.out.println("\n--- toArray() ---");
        Integer[] evenArray = numbers.stream()
                                    .filter(n -> n % 2 == 0)
                                    .toArray(Integer[]::new);
        System.out.println("Even numbers array: " + Arrays.toString(evenArray));
    }
    
    static void demonstrateCollectors() {
        System.out.println("\n=== Collectors ===");
        
        System.out.println("COLLECTORS:");
        System.out.println("- Used with collect() terminal operation");
        System.out.println("- Predefined collectors in Collectors class");
        System.out.println("- Can create custom collectors");
        System.out.println("- Examples: toList, toSet, toMap, groupingBy, partitioningBy");
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve", "Alice");
        
        // Basic collectors
        System.out.println("\n--- Basic Collectors ---");
        
        List<String> nameList = names.stream().collect(Collectors.toList());
        Set<String> nameSet = names.stream().collect(Collectors.toSet());
        
        System.out.println("To List: " + nameList);
        System.out.println("To Set: " + nameSet);
        
        // collect() method is used to store filtered results
        System.out.println("\n--- collect() for Storing Filtered Results ---");
        List<String> longNames = names.stream()
                                     .filter(name -> name.length() > 4)
                                     .collect(Collectors.toList());
        System.out.println("collect() stores filtered results: " + longNames);
        
        // Joining
        System.out.println("\n--- Joining ---");
        String joined = names.stream().collect(Collectors.joining(", "));
        String joinedWithPrefix = names.stream().collect(Collectors.joining(", ", "[", "]"));
        
        System.out.println("Joined: " + joined);
        System.out.println("Joined with prefix/suffix: " + joinedWithPrefix);
        
        // Counting
        System.out.println("\n--- Counting ---");
        Long count = names.stream().collect(Collectors.counting());
        System.out.println("Count using collector: " + count);
        
        // Statistical collectors
        System.out.println("\n--- Statistical Collectors ---");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        IntSummaryStatistics stats = numbers.stream()
                                           .collect(Collectors.summarizingInt(Integer::intValue));
        
        System.out.println("Statistics: " + stats);
        System.out.println("Average: " + stats.getAverage());
        System.out.println("Sum: " + stats.getSum());
        System.out.println("Min: " + stats.getMin());
        System.out.println("Max: " + stats.getMax());
        
        // groupingBy
        System.out.println("\n--- groupingBy ---");
        
        List<Person> people = Arrays.asList(
            new Person("Alice", 25, "Engineering"),
            new Person("Bob", 30, "Marketing"),
            new Person("Charlie", 35, "Engineering"),
            new Person("David", 28, "Marketing"),
            new Person("Eve", 32, "Sales")
        );
        
        Map<String, List<Person>> byDepartment = people.stream()
                                                      .collect(Collectors.groupingBy(Person::getDepartment));
        
        System.out.println("Grouped by department:");
        byDepartment.forEach((dept, persons) -> 
            System.out.println("  " + dept + ": " + persons.stream().map(Person::getName).collect(Collectors.toList())));
        
        // Nested grouping
        Map<String, Map<Integer, List<Person>>> nestedGrouping = people.stream()
                                                                       .collect(Collectors.groupingBy(
                                                                           Person::getDepartment,
                                                                           Collectors.groupingBy(p -> p.getAge() / 10 * 10)
                                                                       ));
        
        System.out.println("Nested grouping (department -> age group): " + nestedGrouping);
        
        // partitioningBy
        System.out.println("\n--- partitioningBy ---");
        Map<Boolean, List<Person>> partitioned = people.stream()
                                                       .collect(Collectors.partitioningBy(p -> p.getAge() >= 30));
        
        System.out.println("Partitioned by age >= 30:");
        System.out.println("  >= 30: " + partitioned.get(true).stream().map(Person::getName).collect(Collectors.toList()));
        System.out.println("  < 30: " + partitioned.get(false).stream().map(Person::getName).collect(Collectors.toList()));
        
        // toMap
        System.out.println("\n--- toMap ---");
        Map<String, Integer> nameToAge = people.stream()
                                              .collect(Collectors.toMap(Person::getName, Person::getAge));
        
        System.out.println("Name to age mapping: " + nameToAge);
        
        // Custom collector
        System.out.println("\n--- Custom Collector ---");
        String customResult = names.stream()
                                  .collect(Collector.of(
                                      StringBuilder::new,
                                      (sb, s) -> sb.append(s).append("|"),
                                      StringBuilder::append,
                                      sb -> sb.length() > 0 ? sb.substring(0, sb.length() - 1) : ""
                                  ));
        
        System.out.println("Custom collector result: " + customResult);
    }
    
    static void demonstrateParallelStreams() {
        System.out.println("\n=== Parallel Streams ===");
        
        System.out.println("PARALLEL STREAMS:");
        System.out.println("- Utilize multiple CPU cores");
        System.out.println("- Good for CPU-intensive operations");
        System.out.println("- May not always be faster (overhead)");
        System.out.println("- Use parallelStream() or parallel()");
        
        List<Integer> largeList = IntStream.rangeClosed(1, 1000000)
                                         .boxed()
                                         .collect(Collectors.toList());
        
        // Sequential processing
        System.out.println("\n--- Sequential vs Parallel Performance ---");
        
        long startTime = System.nanoTime();
        long sequentialSum = largeList.stream()
                                    .mapToLong(Integer::longValue)
                                    .sum();
        long sequentialTime = System.nanoTime() - startTime;
        
        // Parallel processing
        startTime = System.nanoTime();
        long parallelSum = largeList.parallelStream()
                                   .mapToLong(Integer::longValue)
                                   .sum();
        long parallelTime = System.nanoTime() - startTime;
        
        System.out.printf("Sequential sum: %d (%.2f ms)%n", sequentialSum, sequentialTime / 1_000_000.0);
        System.out.printf("Parallel sum: %d (%.2f ms)%n", parallelSum, parallelTime / 1_000_000.0);
        System.out.printf("Speedup: %.2fx%n", (double) sequentialTime / parallelTime);
        
        // When to use parallel streams
        System.out.println("\n--- When to Use Parallel Streams ---");
        System.out.println("✓ Large datasets");
        System.out.println("✓ CPU-intensive operations");
        System.out.println("✓ Independent operations (no shared state)");
        System.out.println("✗ Small datasets (overhead > benefit)");
        System.out.println("✗ I/O operations (not CPU-bound)");
        System.out.println("✗ Operations with side effects");
        
        // Parallel stream example with CPU-intensive operation
        System.out.println("\n--- CPU-Intensive Operation ---");
        
        List<Integer> numbers = Arrays.asList(35, 36, 37, 38, 39, 40, 41, 42);
        
        // Sequential
        startTime = System.nanoTime();
        List<Long> sequentialFactorials = numbers.stream()
                                                .map(StreamAPIDemo::factorial)
                                                .collect(Collectors.toList());
        long seqFactorialTime = System.nanoTime() - startTime;
        
        // Parallel
        startTime = System.nanoTime();
        List<Long> parallelFactorials = numbers.parallelStream()
                                             .map(StreamAPIDemo::factorial)
                                             .collect(Collectors.toList());
        long parFactorialTime = System.nanoTime() - startTime;
        
        System.out.printf("Sequential factorial calculation: %.2f ms%n", seqFactorialTime / 1_000_000.0);
        System.out.printf("Parallel factorial calculation: %.2f ms%n", parFactorialTime / 1_000_000.0);
        
        // Thread safety considerations
        System.out.println("\n--- Thread Safety Considerations ---");
        System.out.println("Parallel streams require thread-safe operations");
        System.out.println("Avoid shared mutable state");
        System.out.println("Use thread-safe collectors or reduction operations");
    }
    
    static void demonstrateAdvancedStreamOperations() {
        System.out.println("\n=== Advanced Stream Operations ===");
        
        // Stream pipeline optimization
        System.out.println("--- Stream Pipeline Optimization ---");
        
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry", "fig", "grape");
        
        // Efficient pipeline - filter early
        List<String> optimized = words.stream()
                                     .filter(word -> word.length() > 4) // Filter early
                                     .map(String::toUpperCase)
                                     .sorted()
                                     .collect(Collectors.toList());
        
        System.out.println("Optimized pipeline: " + optimized);
        
        // Stream reuse (not allowed)
        System.out.println("\n--- Stream Reuse ---");
        Stream<String> wordStream = words.stream();
        wordStream.filter(word -> word.length() > 4).forEach(System.out::println);
        
        try {
            // This will throw IllegalStateException
            wordStream.map(String::toUpperCase).forEach(System.out::println);
        } catch (IllegalStateException e) {
            System.out.println("Cannot reuse stream: " + e.getClass().getSimpleName());
        }
        
        // Lazy evaluation demonstration
        System.out.println("\n--- Lazy Evaluation ---");
        
        Stream<String> lazyStream = words.stream()
                                        .filter(word -> {
                                            System.out.println("Filtering: " + word);
                                            return word.length() > 5;
                                        })
                                        .map(word -> {
                                            System.out.println("Mapping: " + word);
                                            return word.toUpperCase();
                                        });
        
        System.out.println("Stream created but not executed yet...");
        System.out.println("Now executing with terminal operation:");
        
        List<String> result = lazyStream.collect(Collectors.toList());
        System.out.println("Result: " + result);
        
        // Short-circuiting operations
        System.out.println("\n--- Short-Circuiting Operations ---");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // findFirst() short-circuits
        Optional<Integer> firstEven = numbers.stream()
                                           .peek(n -> System.out.println("Processing: " + n))
                                           .filter(n -> n % 2 == 0)
                                           .findFirst();
        
        System.out.println("First even number: " + firstEven.orElse(-1));
        System.out.println("Notice: Processing stopped after finding first match");
        
        // limit() is also short-circuiting
        System.out.println("\nUsing limit() - also short-circuiting:");
        List<Integer> firstThreeEven = numbers.stream()
                                            .peek(n -> System.out.println("Checking: " + n))
                                            .filter(n -> n % 2 == 0)
                                            .limit(3)
                                            .collect(Collectors.toList());
        
        System.out.println("First three even numbers: " + firstThreeEven);
    }
    
    // Helper method for factorial calculation
    static long factorial(int n) {
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
    
    // Helper class for examples
    static class Person {
        private String name;
        private int age;
        private String department;
        
        public Person(String name, int age, String department) {
            this.name = name;
            this.age = age;
            this.department = department;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getDepartment() { return department; }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use streams for data processing pipelines with multiple operations
- Prefer method references over lambda expressions when they improve readability
- Use parallel streams for CPU-intensive operations on large datasets
- Filter early in the pipeline to reduce subsequent processing
- Use appropriate collectors for terminal operations

**Don'ts:**
- Don't reuse streams (they can only be consumed once)
- Don't use parallel streams for I/O operations or small datasets
- Don't modify shared mutable state in parallel stream operations
- Don't use streams for simple operations where traditional loops are clearer
- Don't ignore the performance implications of boxing/unboxing in primitive streams

**Common Pitfalls:**
- IllegalStateException when trying to reuse consumed streams
- Performance degradation from inappropriate use of parallel streams
- Thread safety issues in parallel stream operations with shared state
- Memory issues with infinite streams without proper limiting
- Debugging difficulties with complex stream pipelines

## 5. Summary

- **Stream API** provides functional-style operations on sequences of elements
- **Stream package**: Classes and interfaces are in `java.util.stream` package
- **Collection enhancement**: `stream()` method added to Collection interface for Stream API
- **Operations**: Intermediate (lazy) operations return streams; terminal operations return results
- **collect()**: Terminal operation used to store filtered/processed results into data structures
- **count()**: Terminal operation that returns the number of elements in the stream
- **Parallel streams**: Enable concurrent processing for performance improvements on large datasets
- **Lazy evaluation**: Intermediate operations are not executed until a terminal operation is called

## 6. Tricky Interview Questions

1. **Stream Package**: In which package can we find the Stream API classes and interfaces?

2. **Collection Enhancement**: Which method was added to the Collection interface to work with Stream API?

3. **Terminal vs Intermediate**: Is count() an intermediate operation or terminal operation? Explain the difference.

4. **Result Storage**: Which method is used to store the filtered results into a data structure?

5. **Filter Implementation**: Where can we find the implementation of the filter method? How does it work internally?

6. **Stream Reuse**: What happens when you try to use a stream twice? Show an example.

7. **Lazy Evaluation**: Explain lazy evaluation in streams. When are intermediate operations actually executed?

8. **Parallel Performance**: When should you use parallel streams? When should you avoid them?

9. **Short-Circuiting**: What are short-circuiting operations in streams? Give examples and explain their benefits.

10. **Collectors**: Compare these three approaches for collecting stream results:
    - `collect(Collectors.toList())`
    - `collect(Collectors.toSet())`
    - `toArray()`

11. **Stream Pipeline**: Design an efficient stream pipeline to find the top 3 longest unique words from a list, converted to uppercase. Explain the order of operations.
