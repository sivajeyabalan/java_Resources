## 1. Topic Overview

- Practical patterns for choosing and combining collections for common application scenarios.

## 2 . Topic definition

- WHAT: Recipes like multi-map, bi-map, LRU cache, frequency map, adjacency lists.
- WHY: Reusable solutions for frequent data-modeling needs.
- HOW: Compose standard collections or pick libraries when needed.
- WHEN/WHERE: Indexing, caching, graph modeling, analytics.
- WHAT IF: Over-optimizing structure choices complicates code; prefer clarity unless profiling dictates otherwise.

## 3. Deep Dive with Examples

```java
// Frequency map
import java.util.*;

class FrequencyMap {
    public static Map<String,Integer> count(List<String> words) {
        Map<String,Integer> freq = new HashMap<>();
        for (String w : words) freq.merge(w, 1, Integer::sum);
        return freq;
    }
}
```

```java
// Multi-map using Map<K, List<V>>
import java.util.*;

class MultiMap<K,V> {
    private final Map<K, List<V>> map = new HashMap<>();
    public void put(K k, V v) { map.computeIfAbsent(k, x -> new ArrayList<>()).add(v); }
    public List<V> get(K k) { return map.getOrDefault(k, List.of()); }
}
```

```java
// Adjacency list for graphs
import java.util.*;

class Graph {
    private final Map<Integer, List<Integer>> adj = new HashMap<>();
    public void connect(int u, int v) {
        adj.computeIfAbsent(u, x -> new ArrayList<>()).add(v);
        adj.computeIfAbsent(v, x -> new ArrayList<>()).add(u);
    }
}
```

## 4. Best Practices & Pitfalls

- Wrap composite collections behind small APIs to protect invariants.
- Use immutable views for read-only exposure.
- Consider third-party libraries (Guava `Multimap`, `BiMap`) if allowed.

## 5. Summary

- Common patterns can be built from core collections; small helper APIs improve correctness and clarity.

## 6. Tricky Interview Questions

1. Implement a multi-map with O(1) add and expected O(1) get.
2. Show an LRU cache in 10 lines using `LinkedHashMap`.

