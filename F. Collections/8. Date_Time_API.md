## 1. Topic Overview

The Java Date Time API, introduced in Java 8 (JSR-310), provides a comprehensive and immutable approach to handling dates, times, and time zones. It replaces the problematic legacy Date and Calendar classes with a more intuitive, thread-safe, and feature-rich API. Key classes include LocalDate, LocalTime, LocalDateTime, ZonedDateTime, and Instant. The API follows the ISO-8601 standard and provides excellent support for time zone handling, date arithmetic, and formatting/parsing operations.

## 2. Topic Definition

- **What**: Modern, immutable, and comprehensive API for date, time, and timezone operations in Java 8+
- **Why**: Replaces flawed legacy Date/Calendar classes; provides thread safety, immutability, and better API design
- **How**: Through immutable classes like LocalDate, LocalTime, LocalDateTime, ZonedDateTime with fluent method chaining
- **When/Where**: Any application dealing with dates, times, scheduling, logging, data processing, international applications
- **What If**:
  - All classes are immutable (operations return new instances)
  - Thread-safe by design (no synchronization needed)
  - Comprehensive timezone support with ZoneId and ZoneOffset
  - Rich formatting and parsing capabilities with DateTimeFormatter
  - Extensive date arithmetic and comparison methods
- **Examples**:
  - Current date: `LocalDate.now()`
  - Specific date: `LocalDate.of(2023, 12, 25)`
  - Date with time: `LocalDateTime.now()`
  - With timezone: `ZonedDateTime.now(ZoneId.of("America/New_York"))`

## 3. Deep Dive with Examples

```java
// File: DateTimeAPIDemo.java
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.*;
import java.util.*;

public class DateTimeAPIDemo {
    public static void main(String[] args) {
        demonstrateDateTimeBasics();
        demonstrateLocalDateTime();
        demonstrateZonedDateTime();
        demonstrateDateTimeFormatting();
        demonstrateDateArithmetic();
        demonstrateTimeZoneOperations();
        demonstrateAdvancedOperations();
    }
    
    static void demonstrateDateTimeBasics() {
        System.out.println("=== Date Time API Basics ===");
        
        System.out.println("DATE TIME API CHARACTERISTICS:");
        System.out.println("1. Immutable classes (thread-safe)");
        System.out.println("2. Fluent API design");
        System.out.println("3. ISO-8601 standard compliance");
        System.out.println("4. Comprehensive timezone support");
        System.out.println("5. Rich formatting and parsing");
        System.out.println("6. Extensive date arithmetic");
        
        // LocalDate - date without time
        System.out.println("\n--- LocalDate ---");
        LocalDate today = LocalDate.now();
        LocalDate specificDate = LocalDate.of(2023, 12, 25);
        LocalDate fromString = LocalDate.parse("2023-06-15");
        
        System.out.println("Today: " + today);
        System.out.println("Christmas 2023: " + specificDate);
        System.out.println("From string: " + fromString);
        
        // LocalTime - time without date
        System.out.println("\n--- LocalTime ---");
        LocalTime now = LocalTime.now();
        LocalTime specificTime = LocalTime.of(14, 30, 45);
        LocalTime fromStringTime = LocalTime.parse("09:15:30");
        
        System.out.println("Current time: " + now);
        System.out.println("Specific time: " + specificTime);
        System.out.println("From string: " + fromStringTime);
        
        // LocalDateTime - date and time without timezone
        System.out.println("\n--- LocalDateTime ---");
        LocalDateTime nowDateTime = LocalDateTime.now();
        LocalDateTime specificDateTime = LocalDateTime.of(2023, 12, 25, 10, 30, 0);
        LocalDateTime combined = LocalDate.of(2023, 6, 15).atTime(LocalTime.of(14, 30));
        
        System.out.println("Current date-time: " + nowDateTime);
        System.out.println("Specific date-time: " + specificDateTime);
        System.out.println("Combined date-time: " + combined);
        
        // Instant - point in time (UTC)
        System.out.println("\n--- Instant ---");
        Instant instant = Instant.now();
        Instant epochStart = Instant.ofEpochSecond(0);
        Instant fromMillis = Instant.ofEpochMilli(System.currentTimeMillis());
        
        System.out.println("Current instant: " + instant);
        System.out.println("Epoch start: " + epochStart);
        System.out.println("From millis: " + fromMillis);
        
        // Which class represents both date and time
        System.out.println("\n--- Class Representing Both Date and Time ---");
        System.out.println("LocalDateTime class represents both date and time");
        System.out.println("It does not include timezone information");
        System.out.println("For timezone-aware operations, use ZonedDateTime");
    }
    
    static void demonstrateLocalDateTime() {
        System.out.println("\n=== LocalDateTime Operations ===");
        
        LocalDateTime dateTime = LocalDateTime.of(2023, 6, 15, 14, 30, 45);
        System.out.println("Base date-time: " + dateTime);
        
        // Extracting components
        System.out.println("\n--- Extracting Components ---");
        System.out.println("Year: " + dateTime.getYear());
        System.out.println("Month: " + dateTime.getMonth());
        System.out.println("Month value: " + dateTime.getMonthValue());
        System.out.println("Day of month: " + dateTime.getDayOfMonth());
        System.out.println("Day of week: " + dateTime.getDayOfWeek());
        System.out.println("Day of year: " + dateTime.getDayOfYear());
        System.out.println("Hour: " + dateTime.getHour());
        System.out.println("Minute: " + dateTime.getMinute());
        System.out.println("Second: " + dateTime.getSecond());
        
        // Modifying date-time (returns new instance)
        System.out.println("\n--- Modifying Date-Time ---");
        LocalDateTime modified = dateTime
                .withYear(2024)
                .withMonth(12)
                .withDayOfMonth(25)
                .withHour(10)
                .withMinute(0)
                .withSecond(0);
        
        System.out.println("Original: " + dateTime);
        System.out.println("Modified: " + modified);
        System.out.println("Original unchanged (immutable): " + dateTime);
        
        // Adding and subtracting
        System.out.println("\n--- Adding and Subtracting ---");
        LocalDateTime future = dateTime
                .plusYears(1)
                .plusMonths(2)
                .plusDays(10)
                .plusHours(3)
                .plusMinutes(15);
        
        LocalDateTime past = dateTime
                .minusYears(1)
                .minusMonths(1)
                .minusDays(5)
                .minusHours(2)
                .minusMinutes(30);
        
        System.out.println("Future: " + future);
        System.out.println("Past: " + past);
        
        // Comparisons
        System.out.println("\n--- Comparisons ---");
        LocalDateTime other = LocalDateTime.of(2023, 6, 15, 16, 0, 0);
        
        System.out.println("Is before: " + dateTime.isBefore(other));
        System.out.println("Is after: " + dateTime.isAfter(other));
        System.out.println("Is equal: " + dateTime.isEqual(other));
        System.out.println("Compare to: " + dateTime.compareTo(other));
        
        // Converting to other types
        System.out.println("\n--- Converting to Other Types ---");
        LocalDate dateOnly = dateTime.toLocalDate();
        LocalTime timeOnly = dateTime.toLocalTime();
        
        System.out.println("Date only: " + dateOnly);
        System.out.println("Time only: " + timeOnly);
    }
    
    static void demonstrateZonedDateTime() {
        System.out.println("\n=== ZonedDateTime Operations ===");
        
        // Creating ZonedDateTime
        System.out.println("--- Creating ZonedDateTime ---");
        ZonedDateTime nowInSystemZone = ZonedDateTime.now();
        ZonedDateTime nowInNY = ZonedDateTime.now(ZoneId.of("America/New_York"));
        ZonedDateTime nowInTokyo = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
        
        System.out.println("System zone: " + nowInSystemZone);
        System.out.println("New York: " + nowInNY);
        System.out.println("Tokyo: " + nowInTokyo);
        
        // How to get current time zone details
        System.out.println("\n--- Current Time Zone Details ---");
        ZoneId systemZone = ZoneId.systemDefault();
        System.out.println("System default zone: " + systemZone);
        System.out.println("Zone display name: " + systemZone.getDisplayName(TextStyle.FULL, Locale.getDefault()));
        
        // Available zones
        System.out.println("\nSample available zones:");
        ZoneId.getAvailableZoneIds().stream()
              .filter(zone -> zone.contains("America") || zone.contains("Europe"))
              .sorted()
              .limit(10)
              .forEach(zone -> System.out.println("  " + zone));
        
        // Converting between zones
        System.out.println("\n--- Converting Between Zones ---");
        ZonedDateTime utcTime = ZonedDateTime.now(ZoneOffset.UTC);
        ZonedDateTime londonTime = utcTime.withZoneSameInstant(ZoneId.of("Europe/London"));
        ZonedDateTime tokyoTime = utcTime.withZoneSameInstant(ZoneId.of("Asia/Tokyo"));
        
        System.out.println("UTC: " + utcTime);
        System.out.println("London: " + londonTime);
        System.out.println("Tokyo: " + tokyoTime);
        
        // Daylight Saving Time handling
        System.out.println("\n--- Daylight Saving Time ---");
        ZoneId newYorkZone = ZoneId.of("America/New_York");
        
        // Before DST change (Standard Time)
        ZonedDateTime beforeDST = ZonedDateTime.of(2023, 3, 11, 1, 30, 0, 0, newYorkZone);
        // After DST change (Daylight Time)  
        ZonedDateTime afterDST = ZonedDateTime.of(2023, 3, 12, 3, 30, 0, 0, newYorkZone);
        
        System.out.println("Before DST: " + beforeDST);
        System.out.println("After DST: " + afterDST);
        System.out.println("Offset before: " + beforeDST.getOffset());
        System.out.println("Offset after: " + afterDST.getOffset());
        
        // Working with Instant
        System.out.println("\n--- Working with Instant ---");
        Instant instant = Instant.now();
        ZonedDateTime fromInstant = instant.atZone(ZoneId.of("Europe/Paris"));
        
        System.out.println("Instant: " + instant);
        System.out.println("In Paris: " + fromInstant);
    }
    
    static void demonstrateDateTimeFormatting() {
        System.out.println("\n=== Date Time Formatting ===");
        
        LocalDateTime dateTime = LocalDateTime.of(2023, 6, 15, 14, 30, 45);
        
        // Predefined formatters
        System.out.println("--- Predefined Formatters ---");
        System.out.println("ISO_LOCAL_DATE: " + dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE));
        System.out.println("ISO_LOCAL_TIME: " + dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME));
        System.out.println("ISO_LOCAL_DATE_TIME: " + dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        
        // Custom formatters
        System.out.println("\n--- Custom Formatters ---");
        DateTimeFormatter customFormatter1 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
        DateTimeFormatter customFormatter2 = DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy 'at' h:mm a");
        DateTimeFormatter customFormatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
        
        System.out.println("Custom 1: " + dateTime.format(customFormatter1));
        System.out.println("Custom 2: " + dateTime.format(customFormatter2));
        System.out.println("Custom 3: " + dateTime.format(customFormatter3));
        
        // Locale-specific formatting
        System.out.println("\n--- Locale-Specific Formatting ---");
        DateTimeFormatter germanFormatter = DateTimeFormatter.ofPattern("dd. MMMM yyyy", Locale.GERMAN);
        DateTimeFormatter frenchFormatter = DateTimeFormatter.ofPattern("EEEE d MMMM yyyy", Locale.FRENCH);
        
        System.out.println("German: " + dateTime.format(germanFormatter));
        System.out.println("French: " + dateTime.format(frenchFormatter));
        
        // Parsing from strings
        System.out.println("\n--- Parsing from Strings ---");
        
        try {
            LocalDate parsedDate = LocalDate.parse("15/06/2023", DateTimeFormatter.ofPattern("dd/MM/yyyy"));
            LocalTime parsedTime = LocalTime.parse("2:30 PM", DateTimeFormatter.ofPattern("h:mm a"));
            LocalDateTime parsedDateTime = LocalDateTime.parse("2023-06-15T14:30:45");
            
            System.out.println("Parsed date: " + parsedDate);
            System.out.println("Parsed time: " + parsedTime);
            System.out.println("Parsed date-time: " + parsedDateTime);
            
        } catch (DateTimeParseException e) {
            System.out.println("Parse error: " + e.getMessage());
        }
        
        // ZonedDateTime formatting
        System.out.println("\n--- ZonedDateTime Formatting ---");
        ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of("America/New_York"));
        
        DateTimeFormatter zonedFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss z");
        DateTimeFormatter zonedFormatter2 = DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy h:mm a VV");
        
        System.out.println("Zoned 1: " + zonedDateTime.format(zonedFormatter));
        System.out.println("Zoned 2: " + zonedDateTime.format(zonedFormatter2));
    }
    
    static void demonstrateDateArithmetic() {
        System.out.println("\n=== Date Arithmetic ===");
        
        LocalDate startDate = LocalDate.of(2023, 1, 1);
        LocalDate endDate = LocalDate.of(2023, 12, 31);
        
        System.out.println("Start date: " + startDate);
        System.out.println("End date: " + endDate);
        
        // Period - for date-based amounts
        System.out.println("\n--- Period (Date-based) ---");
        Period period = Period.between(startDate, endDate);
        
        System.out.println("Period between: " + period);
        System.out.println("Years: " + period.getYears());
        System.out.println("Months: " + period.getMonths());
        System.out.println("Days: " + period.getDays());
        System.out.println("Total months: " + period.toTotalMonths());
        
        // Adding periods
        LocalDate futureDate = startDate.plus(Period.ofYears(2).plusMonths(6).plusDays(15));
        System.out.println("Future date: " + futureDate);
        
        // Duration - for time-based amounts
        System.out.println("\n--- Duration (Time-based) ---");
        LocalDateTime start = LocalDateTime.of(2023, 6, 15, 10, 0, 0);
        LocalDateTime end = LocalDateTime.of(2023, 6, 15, 16, 30, 45);
        
        Duration duration = Duration.between(start, end);
        
        System.out.println("Start: " + start);
        System.out.println("End: " + end);
        System.out.println("Duration: " + duration);
        System.out.println("Hours: " + duration.toHours());
        System.out.println("Minutes: " + duration.toMinutes());
        System.out.println("Seconds: " + duration.getSeconds());
        
        // Adding durations
        LocalDateTime futureTime = start.plus(Duration.ofHours(3).plusMinutes(30));
        System.out.println("Future time: " + futureTime);
        
        // ChronoUnit for calculations
        System.out.println("\n--- ChronoUnit Calculations ---");
        long daysBetween = ChronoUnit.DAYS.between(startDate, endDate);
        long hoursBetween = ChronoUnit.HOURS.between(start, end);
        long minutesBetween = ChronoUnit.MINUTES.between(start, end);
        
        System.out.println("Days between: " + daysBetween);
        System.out.println("Hours between: " + hoursBetween);
        System.out.println("Minutes between: " + minutesBetween);
        
        // Temporal adjusters
        System.out.println("\n--- Temporal Adjusters ---");
        LocalDate today = LocalDate.now();
        
        LocalDate firstDayOfMonth = today.with(TemporalAdjusters.firstDayOfMonth());
        LocalDate lastDayOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());
        LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
        LocalDate firstMondayOfMonth = today.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
        
        System.out.println("Today: " + today);
        System.out.println("First day of month: " + firstDayOfMonth);
        System.out.println("Last day of month: " + lastDayOfMonth);
        System.out.println("Next Monday: " + nextMonday);
        System.out.println("First Monday of month: " + firstMondayOfMonth);
        
        // Custom temporal adjuster
        TemporalAdjuster nextWorkingDay = temporal -> {
            LocalDate date = LocalDate.from(temporal);
            DayOfWeek dayOfWeek = date.getDayOfWeek();
            
            if (dayOfWeek == DayOfWeek.FRIDAY) {
                return date.plusDays(3); // Skip weekend
            } else if (dayOfWeek == DayOfWeek.SATURDAY) {
                return date.plusDays(2);
            } else {
                return date.plusDays(1);
            }
        };
        
        LocalDate nextWorking = today.with(nextWorkingDay);
        System.out.println("Next working day: " + nextWorking);
    }
    
    static void demonstrateTimeZoneOperations() {
        System.out.println("\n=== Time Zone Operations ===");
        
        // Working with offsets
        System.out.println("--- Working with Offsets ---");
        ZoneOffset utcOffset = ZoneOffset.UTC;
        ZoneOffset plusFiveOffset = ZoneOffset.of("+05:00");
        ZoneOffset minusEightOffset = ZoneOffset.of("-08:00");
        
        System.out.println("UTC offset: " + utcOffset);
        System.out.println("+5 hours offset: " + plusFiveOffset);
        System.out.println("-8 hours offset: " + minusEightOffset);
        
        // OffsetDateTime
        OffsetDateTime offsetDateTime = OffsetDateTime.now(plusFiveOffset);
        System.out.println("OffsetDateTime: " + offsetDateTime);
        
        // Converting between different representations
        System.out.println("\n--- Converting Between Representations ---");
        
        // Start with LocalDateTime
        LocalDateTime localDateTime = LocalDateTime.of(2023, 6, 15, 14, 30, 0);
        System.out.println("LocalDateTime: " + localDateTime);
        
        // Convert to ZonedDateTime
        ZonedDateTime zonedDateTime = localDateTime.atZone(ZoneId.of("America/New_York"));
        System.out.println("ZonedDateTime: " + zonedDateTime);
        
        // Convert to Instant
        Instant instant = zonedDateTime.toInstant();
        System.out.println("Instant: " + instant);
        
        // Convert to OffsetDateTime
        OffsetDateTime offsetDT = zonedDateTime.toOffsetDateTime();
        System.out.println("OffsetDateTime: " + offsetDT);
        
        // Back to LocalDateTime in different zone
        LocalDateTime localInTokyo = instant.atZone(ZoneId.of("Asia/Tokyo")).toLocalDateTime();
        System.out.println("LocalDateTime in Tokyo: " + localInTokyo);
        
        // Time zone rules
        System.out.println("\n--- Time Zone Rules ---");
        ZoneId newYorkZone = ZoneId.of("America/New_York");
        ZoneRules rules = newYorkZone.getRules();
        
        System.out.println("Is fixed offset: " + rules.isFixedOffset());
        System.out.println("Standard offset: " + rules.getStandardOffset(instant));
        
        // DST transitions
        List<ZoneOffsetTransition> transitions = rules.getTransitions();
        if (!transitions.isEmpty()) {
            ZoneOffsetTransition lastTransition = transitions.get(transitions.size() - 1);
            System.out.println("Last DST transition: " + lastTransition);
        }
    }
    
    static void demonstrateAdvancedOperations() {
        System.out.println("\n=== Advanced Operations ===");
        
        // Working with different calendar systems
        System.out.println("--- Different Calendar Systems ---");
        
        // Japanese calendar
        JapaneseDate japaneseDate = JapaneseDate.now();
        System.out.println("Japanese date: " + japaneseDate);
        
        // Hijrah calendar (Islamic)
        HijrahDate hijrahDate = HijrahDate.now();
        System.out.println("Hijrah date: " + hijrahDate);
        
        // Converting between calendar systems
        LocalDate localDate = LocalDate.from(japaneseDate);
        System.out.println("Converted to LocalDate: " + localDate);
        
        // Clock abstraction
        System.out.println("\n--- Clock Abstraction ---");
        
        Clock systemClock = Clock.systemDefaultZone();
        Clock utcClock = Clock.systemUTC();
        Clock fixedClock = Clock.fixed(Instant.parse("2023-06-15T12:00:00Z"), ZoneOffset.UTC);
        
        System.out.println("System clock: " + LocalDateTime.now(systemClock));
        System.out.println("UTC clock: " + LocalDateTime.now(utcClock));
        System.out.println("Fixed clock: " + LocalDateTime.now(fixedClock));
        
        // Useful for testing
        Clock testClock = Clock.offset(systemClock, Duration.ofHours(2));
        System.out.println("Test clock (+2 hours): " + LocalDateTime.now(testClock));
        
        // Year, Month, DayOfWeek enums
        System.out.println("\n--- Date Time Enums ---");
        
        Year currentYear = Year.now();
        System.out.println("Current year: " + currentYear);
        System.out.println("Is leap year: " + currentYear.isLeap());
        System.out.println("Length: " + currentYear.length() + " days");
        
        Month june = Month.JUNE;
        System.out.println("June: " + june);
        System.out.println("June length: " + june.length(false) + " days");
        System.out.println("June display name: " + june.getDisplayName(TextStyle.FULL, Locale.getDefault()));
        
        DayOfWeek friday = DayOfWeek.FRIDAY;
        System.out.println("Friday: " + friday);
        System.out.println("Friday value: " + friday.getValue());
        System.out.println("Friday display name: " + friday.getDisplayName(TextStyle.FULL, Locale.getDefault()));
        
        // Queries
        System.out.println("\n--- Temporal Queries ---");
        
        LocalDateTime dateTime = LocalDateTime.now();
        
        // Built-in queries
        LocalDate dateFromQuery = dateTime.query(TemporalQueries.localDate());
        LocalTime timeFromQuery = dateTime.query(TemporalQueries.localTime());
        
        System.out.println("Date from query: " + dateFromQuery);
        System.out.println("Time from query: " + timeFromQuery);
        
        // Custom query
        TemporalQuery<String> dayTypeQuery = temporal -> {
            DayOfWeek day = DayOfWeek.from(temporal);
            return (day == DayOfWeek.SATURDAY || day == DayOfWeek.SUNDAY) ? "Weekend" : "Weekday";
        };
        
        String dayType = dateTime.query(dayTypeQuery);
        System.out.println("Day type: " + dayType);
        
        // Legacy interoperability
        System.out.println("\n--- Legacy Interoperability ---");
        
        // Convert to legacy Date
        Date legacyDate = Date.from(Instant.now());
        System.out.println("Legacy Date: " + legacyDate);
        
        // Convert from legacy Date
        Instant instantFromLegacy = legacyDate.toInstant();
        LocalDateTime localFromLegacy = LocalDateTime.ofInstant(instantFromLegacy, ZoneId.systemDefault());
        System.out.println("LocalDateTime from legacy: " + localFromLegacy);
        
        // Calendar conversion
        Calendar calendar = Calendar.getInstance();
        Instant instantFromCalendar = calendar.toInstant();
        ZonedDateTime zonedFromCalendar = ZonedDateTime.ofInstant(instantFromCalendar, ZoneId.systemDefault());
        System.out.println("ZonedDateTime from Calendar: " + zonedFromCalendar);
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use LocalDate for dates without time, LocalDateTime for date-time without timezone, ZonedDateTime for timezone-aware operations
- Always specify timezone explicitly when working with ZonedDateTime
- Use DateTimeFormatter for consistent date/time formatting and parsing
- Leverage immutability - all operations return new instances
- Use Period for date-based calculations, Duration for time-based calculations

**Don'ts:**
- Don't use legacy Date and Calendar classes in new code
- Don't assume LocalDateTime represents a specific instant in time (no timezone)
- Don't ignore timezone when converting between different date-time representations
- Don't modify date-time objects (they're immutable)
- Don't use string concatenation for date formatting (use DateTimeFormatter)

**Common Pitfalls:**
- Confusion between LocalDateTime (no timezone) and ZonedDateTime (with timezone)
- Daylight Saving Time issues when not handling timezone transitions properly
- Parsing errors when format patterns don't match input strings exactly
- Performance issues from creating many DateTimeFormatter instances (cache them)
- Incorrect calculations when mixing Period and Duration operations

## 5. Summary

- **Date Time API** provides immutable, thread-safe classes for date and time operations
- **LocalDateTime** class represents both date and time without timezone information
- **Current timezone details** can be obtained using `ZoneId.systemDefault()` and related methods
- **Comprehensive classes**: LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Instant, Period, Duration
- **Formatting and parsing** through DateTimeFormatter with pattern-based and locale-aware options
- **Timezone support** via ZoneId, ZoneOffset, and ZonedDateTime for international applications
- **Date arithmetic** using Period (date-based), Duration (time-based), and ChronoUnit calculations
- **Legacy interoperability** allows conversion between new API and old Date/Calendar classes

## 6. Tricky Interview Questions

1. **Date Time Class**: Which class represents both date and time? What's the difference between LocalDateTime and ZonedDateTime?

2. **Timezone Details**: How do you get the current time zone details? Show different ways to work with timezones.

3. **Immutability**: How does immutability in the Date Time API affect operations? Show examples of date arithmetic.

4. **Formatting**: How do you format dates in different locales? Create custom date format patterns.

5. **Parsing**: How do you safely parse date strings with different formats? Handle parsing exceptions.

6. **Period vs Duration**: What's the difference between Period and Duration? When would you use each?

7. **Timezone Conversion**: How do you convert a LocalDateTime to different timezones? Show the complete process.

8. **DST Handling**: How does the API handle Daylight Saving Time transitions? Show examples.

9. **Legacy Integration**: How do you convert between the new Date Time API and legacy Date/Calendar classes?

10. **Performance**: What are the performance considerations when using DateTimeFormatter? How do you optimize date/time operations?

11. **Temporal Adjusters**: How do you use TemporalAdjusters for complex date calculations? Create a custom adjuster.
