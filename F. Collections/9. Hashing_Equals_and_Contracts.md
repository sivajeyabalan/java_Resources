## 1. Topic Overview

- Hash-based collections (`HashMap`, `HashSet`) rely on consistent `equals`/`hashCode` contracts for correctness and performance. Violations cause lost entries, duplicates, or lookup failures.

## 2 . Topic definition

- WHAT: `equals` defines logical equality; `hashCode` maps equal objects to the same bucket; contracts: reflexive, symmetric, transitive, consistent, and Null inequality.
- WHY: Hash containers use `hashCode` to find buckets and `equals` to resolve collisions. Inconsistent implementations break retrieval.
- HOW: Use immutable fields for equality; include the same fields in both `equals` and `hashCode`.
- WHEN/WHERE: Override in value objects used as keys or in sets. Avoid mutating key fields after insertion.
- WHAT IF: Changing equality-relevant fields after adding to a map causes the entry to be “lost.”
- EXAMPLES: Proper overrides using `Objects.equals`/`Objects.hash`.

## 3. Deep Dive with Examples

```java
import java.util.*;

public final class Customer {
    private final String id;        // immutable identity
    private final String email;

    public Customer(String id, String email) {
        this.id = id;
        this.email = email;
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Customer)) return false;
        Customer that = (Customer) o;
        return Objects.equals(id, that.id) && Objects.equals(email, that.email);
    }

    @Override public int hashCode() {
        return Objects.hash(id, email);
    }
}
```

```java
// Pitfall: mutable key
import java.util.*;

class MutableKey {
    String code; // mutable
    @Override public boolean equals(Object o) { return o instanceof MutableKey mk && Objects.equals(code, mk.code); }
    @Override public int hashCode() { return Objects.hash(code); }
}

class Demo {
    public static void main(String[] args) {
        Map<MutableKey, String> map = new HashMap<>();
        MutableKey k = new MutableKey();
        k.code = "A";
        map.put(k, "value");
        k.code = "B"; // mutation breaks hash position
        System.out.println(map.get(k)); // null: lost due to moved bucket
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer immutable keys; avoid mutating fields used in `equals`/`hashCode` after insertion.
- Keep `equals`/`hashCode` consistent and use the same fields.
- Align `compareTo` with `equals` for sorted collections; otherwise sets may hold "duplicates".
- Cache hash codes for large immutable objects only if profiling shows benefit.

## 5. Summary

- Correct, consistent equality and hashing are essential for hash-based collections and sorted sets/maps.

## 6. Tricky Interview Questions

1. Can two unequal objects have the same `hashCode`? Effects?
2. What happens if `hashCode` uses fields that `equals` ignores?
3. Why do mutated keys disappear from `HashMap`? Demonstrate.
4. Why should `compareTo` be consistent with `equals`? What breaks if not?

