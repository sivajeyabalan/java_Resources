## 1. Topic Overview

- Concurrent collections provide thread-safe performance with scalable algorithms; blocking queues support producer–consumer patterns without `wait/notify`.

## 2 . Topic definition

- WHAT: `ConcurrentHashMap`, `CopyOnWriteArrayList`, `ConcurrentLinkedQueue`, `BlockingQueue` (`ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue`, `SynchronousQueue`).
- WHY: Avoid global locks and contention; enable non-blocking or segmented concurrency.
- HOW: Use compute/merge methods; use `BlockingQueue` for handoff/back-pressure; choose structures based on read/write patterns.
- WHEN/WHERE: High read concurrency maps, subscription lists, pipelines with bounded queues.
- WHAT IF: Using `CopyOnWriteArrayList` for write-heavy workloads is slow; `ConcurrentHashMap` values are not locked—protect invariants externally.

## 3. Deep Dive with Examples

```java
import java.util.concurrent.*;

public class WordCount {
    private final ConcurrentHashMap<String, Integer> counts = new ConcurrentHashMap<>();

    public void addWord(String w) {
        counts.merge(w, 1, Integer::sum);
    }
}
```

```java
// Producer-consumer with BlockingQueue
import java.util.concurrent.*;

public class Pipeline {
    private final BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);

    public void produce(String item) throws InterruptedException { queue.put(item); }
    public String consume() throws InterruptedException { return queue.take(); }
}
```

```java
// CopyOnWriteArrayList: iteration without ConcurrentModificationException
import java.util.concurrent.CopyOnWriteArrayList;

class Subscribers {
    private final CopyOnWriteArrayList<String> subs = new CopyOnWriteArrayList<>();
    public void add(String s) { subs.add(s); }
    public void broadcast(String msg) { for (String s : subs) {/* send */} }
}
```

## 4. Best Practices & Pitfalls

- Use `merge`, `computeIfAbsent`, and `compute` to avoid race-prone read-modify-write.
- Choose bounded `BlockingQueue` for back-pressure; `SynchronousQueue` for handoff.
- Avoid external iteration over `ConcurrentHashMap` to enforce invariants; use atomic methods.
- `CopyOnWriteArrayList` is ideal for many reads/few writes and small elements.

## 5. Summary

- Concurrent collections scale under contention; blocking queues simplify coordination safely.

## 6. Tricky Interview Questions

1. Explain how `ConcurrentHashMap` avoids global locking. What changed since Java 8?
2. When would you prefer `SynchronousQueue` over a bounded queue?
3. Why can `CopyOnWriteArrayList` be inefficient for large elements or frequent writes?

