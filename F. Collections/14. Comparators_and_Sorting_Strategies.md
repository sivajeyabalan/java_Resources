## 1. Topic Overview

- Comparators define custom ordering for sorting collections and priority structures; chaining enables multi-key sorts.

## 2 . Topic definition

- WHAT: `Comparator<T>` functional interface with factory methods: `comparing`, `thenComparing`, `reverseOrder`, `nullsFirst/Last`.
- WHY: Control sort order, handle nulls, multi-field orderings.
- HOW: Build comparators fluently; ensure transitivity and consistency with equals when required.
- WHEN/WHERE: Sorting lists, TreeSet/TreeMap keys, priority queues.
- WHAT IF: Inconsistent comparators break sorted sets/maps and can cause `IllegalArgumentException`.

## 3. Deep Dive with Examples

```java
import java.util.*;

record Employee(String dept, String name, Integer age) {}

class SortDemo {
    public static void main(String[] args) {
        List<Employee> list = new ArrayList<>(List.of(
            new Employee("A", "Ram", 30),
            new Employee("B", "Zia", 25),
            new Employee("A", "Ann", 25)));

        list.sort(Comparator.comparing(Employee::dept)
            .thenComparing(Employee::age)
            .thenComparing(Employee::name, Comparator.nullsLast(Comparator.naturalOrder())));
        System.out.println(list);
    }
}
```

```java
// TreeMap with custom comparator
import java.util.*;

class TreeMapDemo {
    public static void main(String[] args) {
        Comparator<String> byLenThenAlpha = Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder());
        Map<String, Integer> map = new TreeMap<>(byLenThenAlpha);
        map.put("ccc", 3); map.put("a", 1); map.put("bb", 2);
        System.out.println(map);
    }
}
```

## 4. Best Practices & Pitfalls

- Keep comparators transitive; avoid dynamic comparators that change with external mutable state.
- Use `nullsFirst/Last` explicitly when nulls can appear.
- Align comparator with equality if used in sets/maps to avoid duplicates.

## 5. Summary

- Fluent comparator APIs enable clear, robust sorting and ordering strategies.

## 6. Tricky Interview Questions

1. Demonstrate multi-key sorting with null-safe fields.
2. Explain why inconsistent comparators break `TreeSet` uniqueness.
3. How to sort large data efficientlyâ€”when to use partial sorts/top-k vs full sort?

