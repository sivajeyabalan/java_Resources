## 1. Topic Overview

- Advanced stream operations and parallelism: when they help, when they hurt, and how to use them safely.

## 2 . Topic definition

- WHAT: Intermediate ops (flatMap, distinct, sorted, peek), terminal ops (collect, reduce), parallel streams, spliterators.
- WHY: Express complex transformations declaratively; leverage multicore safely.
- HOW: Choose proper intermediate operations; avoid shared mutable state; understand parallel overhead and data source characteristics.
- WHEN/WHERE: CPU-bound, stateless operations on large, easily splittable data; avoid on small data or blocking IO.
- WHAT IF: Parallel streams with stateful lambdas cause races; unordered vs ordered semantics affect performance.

## 3. Deep Dive with Examples

```java
import java.util.*;
import java.util.stream.*;

class FlatMapDistinct {
    public static void main(String[] args) {
        List<String> words = List.of("a b", "b c", "c d");
        List<String> unique = words.stream()
            .flatMap(s -> Arrays.stream(s.split(" ")))
            .distinct()
            .sorted()
            .collect(Collectors.toList());
        System.out.println(unique);
    }
}
```

```java
// Reduction and associativity
import java.util.*;
import java.util.stream.*;

class ReduceDemo {
    public static void main(String[] args) {
        int sum = List.of(1,2,3,4).stream().reduce(0, Integer::sum);
        System.out.println(sum);
    }
}
```

```java
// Parallel pitfalls
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

class ParallelPitfalls {
    static int sideEffect = 0;
    public static void main(String[] args) {
        // BAD: shared mutable state with parallel stream
        IntStream.range(0, 1_000_000).parallel().forEach(i -> sideEffect++); // data race
        System.out.println(sideEffect); // unpredictable

        // GOOD: use reduction
        int sum = IntStream.range(0, 1_000_000).parallel().sum();
        System.out.println(sum);
    }
}
```

Guidelines for parallel streams:
- Source should be splittable (arrays, `ArrayList`, ranges) and large enough to amortize overhead.
- Stateless, non-blocking, associative operations only.
- Control parallelism via `ForkJoinPool.commonPool()` or supply your own (advanced).

## 4. Best Practices & Pitfalls

- Avoid `peek` for logic; use it only for debugging.
- Use `unordered()` to relax ordering when safe for speedups.
- Never mutate external state inside stream operations; use collectors/reduction.
- Avoid parallel on IO-bound or synchronized data sources.

## 5. Summary

- Streams are powerful; parallelism demands associative, stateless operations and suitable data sources.

## 6. Tricky Interview Questions

1. Why must reduction operations be associative for parallel streams?
2. When does `unordered()` help performance?
3. Show a data race caused by side effects in a parallel stream and fix it.

