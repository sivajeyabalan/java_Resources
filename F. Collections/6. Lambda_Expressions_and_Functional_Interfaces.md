## 1. Topic Overview

Lambda expressions, introduced in Java 8, provide a concise way to represent anonymous functions and enable functional programming paradigms. They work seamlessly with functional interfaces (interfaces with exactly one abstract method) and are extensively used with the Collections Framework and Stream API. Key functional interfaces include Function, Predicate, Consumer, and Supplier. Method references provide an even more concise syntax for lambda expressions that simply call existing methods.

## 2. Topic Definition

- **What**: Concise syntax for anonymous functions that implement functional interfaces; method references provide shorthand notation
- **Why**: Enable functional programming, reduce boilerplate code, improve code readability, support parallel processing
- **How**: Lambda syntax `(parameters) -> expression/block`; method references use `::` operator; work with functional interfaces
- **When/Where**: Stream operations, event handling, callback functions, collection processing, parallel programming
- **What If**:
  - Lambda expressions can capture variables from enclosing scope (effectively final)
  - Method references have 4 types: static, instance, constructor, arbitrary object
  - Functional interfaces can have default and static methods
  - Lambda expressions enable lazy evaluation and parallel processing
- **Examples**:
  - Lambda: `list.forEach(item -> System.out.println(item))`
  - Method reference: `list.forEach(System.out::println)`
  - Predicate: `list.removeIf(s -> s.isEmpty())`

## 3. Deep Dive with Examples

```java
// File: LambdaExpressionsDemo.java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

public class LambdaExpressionsDemo {
    public static void main(String[] args) {
        demonstrateLambdaSyntax();
        demonstrateFunctionalInterfaces();
        demonstrateMethodReferences();
        demonstrateBuiltInFunctionalInterfaces();
        demonstrateLambdaWithCollections();
        demonstrateVariableCapture();
        demonstrateAdvancedLambdaUsage();
    }
    
    static void demonstrateLambdaSyntax() {
        System.out.println("=== Lambda Expression Syntax ===");
        
        System.out.println("LAMBDA CHARACTERISTICS:");
        System.out.println("1. Anonymous functions (no name)");
        System.out.println("2. Can be passed as arguments");
        System.out.println("3. Concise syntax: (parameters) -> expression/block");
        System.out.println("4. Type inference for parameters");
        System.out.println("5. Can capture variables from enclosing scope");
        
        // Traditional anonymous inner class
        System.out.println("\n--- Traditional vs Lambda Syntax ---");
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // Traditional anonymous inner class
        Collections.sort(names, new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                return a.compareTo(b);
            }
        });
        System.out.println("Sorted with anonymous class: " + names);
        
        // Lambda expression - same functionality
        names = Arrays.asList("David", "Charlie", "Bob", "Alice"); // Reset
        Collections.sort(names, (a, b) -> a.compareTo(b));
        System.out.println("Sorted with lambda: " + names);
        
        // Even more concise with method reference
        names = Arrays.asList("David", "Charlie", "Bob", "Alice"); // Reset
        Collections.sort(names, String::compareTo);
        System.out.println("Sorted with method reference: " + names);
        
        // Lambda syntax variations
        System.out.println("\n--- Lambda Syntax Variations ---");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // No parameters
        Runnable task1 = () -> System.out.println("No parameters");
        
        // Single parameter (parentheses optional)
        Consumer<String> printer1 = s -> System.out.println(s);
        Consumer<String> printer2 = (s) -> System.out.println(s);
        
        // Multiple parameters
        BinaryOperator<Integer> adder = (a, b) -> a + b;
        
        // Block body with return statement
        Function<String, Integer> lengthCalculator = (String s) -> {
            System.out.println("Calculating length of: " + s);
            return s.length();
        };
        
        // Type inference
        Function<String, Integer> lengthCalc2 = s -> s.length(); // Type inferred
        
        System.out.println("Lambda variations demonstrated");
        System.out.println("Length of 'Hello': " + lengthCalculator.apply("Hello"));
    }
    
    static void demonstrateFunctionalInterfaces() {
        System.out.println("\n=== Functional Interfaces ===");
        
        System.out.println("FUNCTIONAL INTERFACE RULES:");
        System.out.println("1. Exactly one abstract method (SAM - Single Abstract Method)");
        System.out.println("2. Can have default and static methods");
        System.out.println("3. @FunctionalInterface annotation (optional but recommended)");
        System.out.println("4. Lambda expressions implement functional interfaces");
        
        // Custom functional interface
        System.out.println("\n--- Custom Functional Interface ---");
        
        @FunctionalInterface
        interface Calculator {
            int calculate(int a, int b);
            
            // Default method allowed
            default void printResult(int a, int b) {
                System.out.println("Result: " + calculate(a, b));
            }
            
            // Static method allowed
            static void info() {
                System.out.println("Calculator functional interface");
            }
        }
        
        // Lambda implementations
        Calculator addition = (a, b) -> a + b;
        Calculator multiplication = (a, b) -> a * b;
        Calculator subtraction = (a, b) -> a - b;
        
        System.out.println("Addition: " + addition.calculate(10, 5));
        System.out.println("Multiplication: " + multiplication.calculate(10, 5));
        System.out.println("Subtraction: " + subtraction.calculate(10, 5));
        
        addition.printResult(8, 3); // Using default method
        Calculator.info(); // Using static method
        
        // Functional interface with generics
        System.out.println("\n--- Generic Functional Interface ---");
        
        @FunctionalInterface
        interface Processor<T, R> {
            R process(T input);
        }
        
        Processor<String, Integer> stringLength = s -> s.length();
        Processor<String, String> upperCase = s -> s.toUpperCase();
        Processor<List<String>, Integer> listSize = list -> list.size();
        
        System.out.println("String length: " + stringLength.process("Hello World"));
        System.out.println("Upper case: " + upperCase.process("hello world"));
        System.out.println("List size: " + listSize.process(Arrays.asList("A", "B", "C")));
        
        // How many abstract methods can be in functional interface
        System.out.println("\n--- Functional Interface Validation ---");
        System.out.println("Functional interfaces can have exactly 1 abstract method");
        System.out.println("They can have multiple default and static methods");
        System.out.println("@FunctionalInterface annotation helps catch violations at compile time");
    }
    
    static void demonstrateMethodReferences() {
        System.out.println("\n=== Method References ===");
        
        System.out.println("METHOD REFERENCE TYPES:");
        System.out.println("1. Static method reference: ClassName::staticMethod");
        System.out.println("2. Instance method reference: object::instanceMethod");
        System.out.println("3. Constructor reference: ClassName::new");
        System.out.println("4. Arbitrary object method reference: ClassName::instanceMethod");
        
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
        
        // Type 1: Static method reference
        System.out.println("\n--- Static Method Reference ---");
        
        // Lambda: s -> Integer.parseInt(s)
        // Method reference: Integer::parseInt
        List<String> numberStrings = Arrays.asList("1", "2", "3", "4", "5");
        List<Integer> numbers = numberStrings.stream()
                                           .map(Integer::parseInt) // Static method reference
                                           .collect(Collectors.toList());
        System.out.println("Parsed numbers: " + numbers);
        
        // Type 2: Instance method reference
        System.out.println("\n--- Instance Method Reference ---");
        
        String prefix = "Item: ";
        Function<String, String> prefixer = prefix::concat; // Instance method reference
        
        List<String> prefixedWords = words.stream()
                                        .map(prefixer)
                                        .collect(Collectors.toList());
        System.out.println("Prefixed words: " + prefixedWords);
        
        // Type 3: Constructor reference
        System.out.println("\n--- Constructor Reference ---");
        
        // Lambda: () -> new ArrayList<>()
        // Method reference: ArrayList::new
        Supplier<List<String>> listSupplier = ArrayList::new;
        List<String> newList = listSupplier.get();
        newList.add("Created with constructor reference");
        System.out.println("New list: " + newList);
        
        // Constructor with parameters
        Function<String, StringBuilder> sbCreator = StringBuilder::new;
        StringBuilder sb = sbCreator.apply("Hello");
        System.out.println("StringBuilder: " + sb);
        
        // Type 4: Arbitrary object method reference
        System.out.println("\n--- Arbitrary Object Method Reference ---");
        
        // Lambda: (s1, s2) -> s1.compareToIgnoreCase(s2)
        // Method reference: String::compareToIgnoreCase
        List<String> sortedWords = words.stream()
                                      .sorted(String::compareToIgnoreCase)
                                      .collect(Collectors.toList());
        System.out.println("Sorted words (ignore case): " + sortedWords);
        
        // Which operator is used in method reference
        System.out.println("\n--- Method Reference Operator ---");
        System.out.println("The :: (double colon) operator is used in method references");
        System.out.println("It separates the class/object from the method name");
        
        // Demonstrate all 4 types together
        System.out.println("\n--- All Method Reference Types ---");
        
        class Person {
            private String name;
            
            public Person(String name) { this.name = name; }
            public String getName() { return name; }
            public static int compareByLength(Person p1, Person p2) {
                return p1.name.length() - p2.name.length();
            }
            @Override
            public String toString() { return name; }
        }
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // 1. Static method reference
        Comparator<Person> lengthComparator = Person::compareByLength;
        
        // 2. Instance method reference
        Person alice = new Person("Alice");
        Predicate<String> startsWithA = alice.getName()::startsWith;
        
        // 3. Constructor reference
        Function<String, Person> personCreator = Person::new;
        
        // 4. Arbitrary object method reference
        Function<Person, String> nameExtractor = Person::getName;
        
        List<Person> people = names.stream()
                                  .map(personCreator) // Constructor reference
                                  .sorted(lengthComparator) // Static method reference
                                  .collect(Collectors.toList());
        
        System.out.println("People sorted by name length: " + people);
    }
    
    static void demonstrateBuiltInFunctionalInterfaces() {
        System.out.println("\n=== Built-in Functional Interfaces ===");
        
        System.out.println("COMMON FUNCTIONAL INTERFACES (java.util.function):");
        System.out.println("1. Function<T,R> - Takes T, returns R");
        System.out.println("2. Predicate<T> - Takes T, returns boolean");
        System.out.println("3. Consumer<T> - Takes T, returns void");
        System.out.println("4. Supplier<T> - Takes nothing, returns T");
        
        // Function<T, R>
        System.out.println("\n--- Function<T, R> ---");
        Function<String, Integer> stringLength = s -> s.length();
        Function<Integer, String> intToString = i -> "Number: " + i;
        
        System.out.println("String length: " + stringLength.apply("Hello World"));
        System.out.println("Int to string: " + intToString.apply(42));
        
        // Function composition
        Function<String, String> lengthToString = stringLength.andThen(intToString);
        System.out.println("Composed function: " + lengthToString.apply("Java"));
        
        // Predicate<T>
        System.out.println("\n--- Predicate<T> ---");
        Predicate<String> isEmpty = s -> s.isEmpty();
        Predicate<String> isLong = s -> s.length() > 5;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        
        List<String> testStrings = Arrays.asList("", "Hi", "Hello", "Java Programming");
        
        System.out.println("Empty strings: " + 
            testStrings.stream().filter(isEmpty).collect(Collectors.toList()));
        System.out.println("Long strings: " + 
            testStrings.stream().filter(isLong).collect(Collectors.toList()));
        
        // Predicate composition
        Predicate<String> notEmptyAndLong = isEmpty.negate().and(isLong);
        System.out.println("Not empty and long: " + 
            testStrings.stream().filter(notEmptyAndLong).collect(Collectors.toList()));
        
        // Consumer<T>
        System.out.println("\n--- Consumer<T> ---");
        Consumer<String> printer = s -> System.out.println("Processing: " + s);
        Consumer<String> logger = s -> System.out.println("LOG: " + s);
        
        List<String> items = Arrays.asList("Item1", "Item2", "Item3");
        items.forEach(printer);
        
        // Consumer chaining
        Consumer<String> printerAndLogger = printer.andThen(logger);
        System.out.println("Chained consumer:");
        printerAndLogger.accept("Test Item");
        
        // Supplier<T>
        System.out.println("\n--- Supplier<T> ---");
        Supplier<String> randomString = () -> "Random-" + Math.random();
        Supplier<List<String>> listSupplier = ArrayList::new;
        Supplier<Integer> randomInt = () -> (int)(Math.random() * 100);
        
        System.out.println("Random string: " + randomString.get());
        System.out.println("New list: " + listSupplier.get());
        System.out.println("Random int: " + randomInt.get());
        
        // Which functional interface for no input but output expected
        System.out.println("\n--- Supplier for No Input, Output Expected ---");
        System.out.println("Supplier<T> is used when no input but output is expected");
        System.out.println("Example: () -> new Date(), () -> Math.random()");
        
        // Specialized functional interfaces
        System.out.println("\n--- Specialized Functional Interfaces ---");
        
        // Primitive specializations (avoid boxing)
        IntFunction<String> intToStr = i -> "Value: " + i;
        IntPredicate isPositive = i -> i > 0;
        IntConsumer intPrinter = i -> System.out.println("Int: " + i);
        IntSupplier randomIntSupplier = () -> (int)(Math.random() * 100);
        
        System.out.println("Int function: " + intToStr.apply(42));
        System.out.println("Is 5 positive: " + isPositive.test(5));
        intPrinter.accept(100);
        System.out.println("Random int: " + randomIntSupplier.getAsInt());
        
        // Binary operators
        BinaryOperator<Integer> adder = (a, b) -> a + b;
        BinaryOperator<String> concatenator = (a, b) -> a + " " + b;
        
        System.out.println("Addition: " + adder.apply(5, 3));
        System.out.println("Concatenation: " + concatenator.apply("Hello", "World"));
        
        // Unary operators
        UnaryOperator<String> upperCase = s -> s.toUpperCase();
        UnaryOperator<Integer> square = n -> n * n;
        
        System.out.println("Upper case: " + upperCase.apply("hello"));
        System.out.println("Square: " + square.apply(5));
    }
    
    static void demonstrateLambdaWithCollections() {
        System.out.println("\n=== Lambda with Collections ===");
        
        List<String> fruits = new ArrayList<>(Arrays.asList("apple", "banana", "cherry", "date", "elderberry"));
        
        // forEach with lambda
        System.out.println("--- forEach with Lambda ---");
        System.out.print("Fruits: ");
        fruits.forEach(fruit -> System.out.print(fruit + " "));
        System.out.println();
        
        // removeIf with lambda
        System.out.println("\n--- removeIf with Lambda ---");
        List<String> fruitsCopy = new ArrayList<>(fruits);
        fruitsCopy.removeIf(fruit -> fruit.startsWith("a"));
        System.out.println("After removing fruits starting with 'a': " + fruitsCopy);
        
        // replaceAll with lambda
        System.out.println("\n--- replaceAll with Lambda ---");
        fruitsCopy.replaceAll(fruit -> fruit.toUpperCase());
        System.out.println("After converting to uppercase: " + fruitsCopy);
        
        // sort with lambda
        System.out.println("\n--- sort with Lambda ---");
        List<String> sortedFruits = new ArrayList<>(fruits);
        sortedFruits.sort((a, b) -> Integer.compare(a.length(), b.length()));
        System.out.println("Sorted by length: " + sortedFruits);
        
        // Map operations with lambda
        System.out.println("\n--- Map Operations with Lambda ---");
        Map<String, Integer> fruitLengths = new HashMap<>();
        fruits.forEach(fruit -> fruitLengths.put(fruit, fruit.length()));
        
        System.out.println("Fruit lengths: " + fruitLengths);
        
        // Map compute operations
        fruitLengths.compute("apple", (key, val) -> val == null ? 1 : val * 2);
        System.out.println("After compute on 'apple': " + fruitLengths);
        
        fruitLengths.computeIfAbsent("fig", key -> key.length());
        System.out.println("After computeIfAbsent for 'fig': " + fruitLengths);
        
        // Map forEach
        System.out.println("Map entries:");
        fruitLengths.forEach((key, value) -> 
            System.out.printf("  %s: %d characters%n", key, value));
        
        // Collection related features in Java 8
        System.out.println("\n--- Collection Related Features in Java 8 ---");
        System.out.println("1. Lambda expressions for functional programming");
        System.out.println("2. Method references for concise syntax");
        System.out.println("3. Stream API for data processing");
        System.out.println("4. Default methods in interfaces");
        System.out.println("5. forEach, removeIf, replaceAll methods in collections");
        System.out.println("6. Functional interfaces in java.util.function package");
    }
    
    static void demonstrateVariableCapture() {
        System.out.println("\n=== Variable Capture in Lambdas ===");
        
        System.out.println("VARIABLE CAPTURE RULES:");
        System.out.println("1. Local variables must be effectively final");
        System.out.println("2. Instance variables can be modified");
        System.out.println("3. Static variables can be modified");
        System.out.println("4. Parameters are effectively final");
        
        // Effectively final local variables
        System.out.println("\n--- Effectively Final Variables ---");
        
        String prefix = "Item: "; // Effectively final
        int multiplier = 2; // Effectively final
        
        List<String> items = Arrays.asList("A", "B", "C");
        
        // Lambda can capture effectively final variables
        items.forEach(item -> System.out.println(prefix + item));
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        numbers.forEach(n -> System.out.println(n * multiplier));
        
        // This would cause compilation error:
        // multiplier = 3; // Cannot modify captured variable
        
        // Instance and static variable capture
        System.out.println("\n--- Instance and Static Variables ---");
        
        class Counter {
            private int instanceCount = 0;
            private static int staticCount = 0;
            
            public void processItems(List<String> items) {
                items.forEach(item -> {
                    instanceCount++; // OK - instance variable
                    staticCount++;   // OK - static variable
                    System.out.println("Processing: " + item + 
                                     " (instance: " + instanceCount + 
                                     ", static: " + staticCount + ")");
                });
            }
        }
        
        Counter counter = new Counter();
        counter.processItems(Arrays.asList("X", "Y", "Z"));
        
        // Workaround for modifying local variables
        System.out.println("\n--- Workaround for Local Variable Modification ---");
        
        // Use array or wrapper class
        int[] localCounter = {0};
        List<String> words = Arrays.asList("one", "two", "three");
        
        words.forEach(word -> {
            localCounter[0]++; // Modifying array content (not the array reference)
            System.out.println(localCounter[0] + ": " + word);
        });
        
        // Using AtomicInteger for thread-safe modification
        java.util.concurrent.atomic.AtomicInteger atomicCounter = 
            new java.util.concurrent.atomic.AtomicInteger(0);
        
        words.forEach(word -> {
            int count = atomicCounter.incrementAndGet();
            System.out.println("Atomic " + count + ": " + word);
        });
    }
    
    static void demonstrateAdvancedLambdaUsage() {
        System.out.println("\n=== Advanced Lambda Usage ===");
        
        // Higher-order functions
        System.out.println("--- Higher-Order Functions ---");
        
        // Function that returns a function
        Function<String, Function<String, String>> createPrefixer = prefix -> 
            text -> prefix + text;
        
        Function<String, String> errorPrefixer = createPrefixer.apply("ERROR: ");
        Function<String, String> infoPrefixer = createPrefixer.apply("INFO: ");
        
        System.out.println(errorPrefixer.apply("Something went wrong"));
        System.out.println(infoPrefixer.apply("Process completed"));
        
        // Function that takes a function as parameter
        static <T> void processWithFunction(List<T> list, Function<T, String> processor) {
            list.forEach(item -> System.out.println(processor.apply(item)));
        }
        
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);
        processWithFunction(nums, n -> "Number: " + n);
        processWithFunction(nums, n -> "Square: " + (n * n));
        
        // Currying example
        System.out.println("\n--- Currying ---");
        
        // Traditional method with multiple parameters
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        
        // Curried version - function returning function
        Function<Integer, Function<Integer, Integer>> curriedAdd = a -> b -> a + b;
        
        Function<Integer, Integer> add5 = curriedAdd.apply(5);
        System.out.println("5 + 3 = " + add5.apply(3));
        System.out.println("5 + 7 = " + add5.apply(7));
        
        // Partial application
        System.out.println("\n--- Partial Application ---");
        
        // Create specialized functions from general ones
        Function<String, Function<String, String>> createFormatter = 
            format -> value -> String.format(format, value);
        
        Function<String, String> percentFormatter = createFormatter.apply("%.2f%%");
        Function<String, String> currencyFormatter = createFormatter.apply("$%s");
        
        System.out.println("Percentage: " + percentFormatter.apply("85.67"));
        System.out.println("Currency: " + currencyFormatter.apply("123.45"));
        
        // Lambda with exception handling
        System.out.println("\n--- Exception Handling in Lambdas ---");
        
        List<String> numberStrings = Arrays.asList("1", "2", "invalid", "4", "5");
        
        // Wrapper function for exception handling
        Function<String, Integer> safeParseInt = s -> {
            try {
                return Integer.parseInt(s);
            } catch (NumberFormatException e) {
                System.out.println("Invalid number: " + s);
                return 0;
            }
        };
        
        List<Integer> parsedNumbers = numberStrings.stream()
                                                  .map(safeParseInt)
                                                  .collect(Collectors.toList());
        
        System.out.println("Safely parsed numbers: " + parsedNumbers);
    }
    
    // Helper method for higher-order function demonstration
    static <T> void processWithFunction(List<T> list, Function<T, String> processor) {
        list.forEach(item -> System.out.println(processor.apply(item)));
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use lambda expressions to reduce boilerplate code and improve readability
- Prefer method references when they make code more readable
- Use appropriate functional interfaces from java.util.function package
- Keep lambda expressions short and focused on single responsibility
- Use @FunctionalInterface annotation for custom functional interfaces

**Don'ts:**
- Don't modify captured local variables (they must be effectively final)
- Don't use lambdas for complex logic (extract to separate methods)
- Don't ignore exception handling in lambda expressions
- Don't overuse lambdas where traditional approaches are clearer
- Don't create functional interfaces when built-in ones suffice

**Common Pitfalls:**
- Compilation errors when trying to modify captured local variables
- Performance overhead from excessive lambda creation in tight loops
- Debugging difficulties with complex lambda expressions
- Memory leaks from capturing references to large objects
- ClassCastException when lambda types don't match expected functional interface

## 5. Summary

- **Lambda expressions** provide concise syntax for anonymous functions using `(parameters) -> expression/block`
- **Functional interfaces** have exactly one abstract method and can be implemented by lambda expressions
- **Method references** use `::` operator and have 4 types: static, instance, constructor, arbitrary object
- **Built-in functional interfaces**: Function, Predicate, Consumer, Supplier with specialized variants
- **Variable capture**: Local variables must be effectively final; instance/static variables can be modified
- **Collections integration**: forEach, removeIf, replaceAll, sort methods work seamlessly with lambdas
- **Java 8 features**: Lambda expressions, method references, Stream API, default methods, functional interfaces

## 6. Tricky Interview Questions

1. **Lambda Operator**: Which operator is used with lambda expressions? Show different lambda syntax variations.

2. **Method Reference Operator**: Which operator is used in method reference? What are the 4 types of method reference?

3. **Functional Interface**: How many abstract methods can be present in a functional interface? Can it have default and static methods?

4. **Variable Capture**: What happens when you try to modify a local variable inside a lambda expression? How can you work around this limitation?

5. **Supplier Interface**: Which functional interface can be used when there is no input but an output is expected? Give examples.

6. **Collections Features**: What are the Collection-related features introduced in Java 8? How do they work with lambda expressions?

7. **Performance**: Compare the performance of lambda expressions vs anonymous inner classes. When would you choose each?

8. **Exception Handling**: How do you handle checked exceptions in lambda expressions? Show a practical example.

9. **Method Reference Types**: Explain the difference between these method references:
   - `String::valueOf`
   - `System.out::println`
   - `ArrayList::new`
   - `String::length`

10. **Higher-Order Functions**: How do you create a function that returns another function? Show an example of currying with lambda expressions.

11. **Debugging**: What challenges might you face when debugging lambda expressions? How can you make them more debuggable?
