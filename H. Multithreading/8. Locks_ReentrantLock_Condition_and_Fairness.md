## 1. Topic Overview

- `java.util.concurrent.locks` provides explicit lock classes like `ReentrantLock` and `Condition` for finer-grained control beyond `synchronized`/`wait`/`notify`.

## 2 . Topic definition

- WHAT: `ReentrantLock` is a mutual exclusion lock with reentrancy, fairness options, and rich features (`tryLock`, interruptible lock acquisition). `Condition` is like multiple wait-sets per lock.
- WHY: Need timed/interruptible acquisition, multiple conditions, or fairness guarantees not possible with intrinsic locks.
- HOW: Acquire with `lock()` or `tryLock()`, release in `finally`. Create conditions with `newCondition()` and use `await()/signal()/signalAll()`.
- WHEN/WHERE: Use in complex coordination, timeouts, responsiveness to interrupts, or to prevent starvation.
- WHAT IF: Forgetting `unlock()` leads to deadlocks; signaling wrong condition causes hangs; using non-fair lock may starve threads.

## 3. Deep Dive with Examples

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class BoundedBufferLock<T> {
    private final Queue<T> queue = new LinkedList<>();
    private final int capacity;
    private final ReentrantLock lock = new ReentrantLock(true); // fair
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();

    public BoundedBufferLock(int capacity) {
        this.capacity = capacity;
    }

    public void put(T item) throws InterruptedException {
        lock.lockInterruptibly();
        try {
            while (queue.size() == capacity) {
                notFull.await();
            }
            queue.add(item);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await();
            }
            T item = queue.remove();
            notFull.signal();
            return item;
        } finally {
            lock.unlock();
        }
    }

    public boolean offer(T item, long nanosTimeout) throws InterruptedException {
        long nanos = nanosTimeout;
        lock.lock();
        try {
            while (queue.size() == capacity) {
                if (nanos <= 0L) return false;
                nanos = notFull.awaitNanos(nanos);
            }
            queue.add(item);
            notEmpty.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }
}
```

## 4. Best Practices & Pitfalls

- Always pair `lock()` with `unlock()` in `finally`.
- Use `lockInterruptibly()` for responsiveness; `tryLock(timeout)` to avoid deadlock.
- Prefer separate `Condition`s per condition predicate (e.g., notFull/notEmpty).
- Fair locks reduce throughput; use only when starvation is a risk.
- Avoid mixing intrinsic and explicit locks on the same state.

## 5. Summary

- `ReentrantLock` adds fairness, interruptible/timed acquisition; `Condition` offers multiple wait-sets.
- Use explicit locks for advanced coordination needs.

## 6. Tricky Interview Questions

1. Compare `synchronized` with `ReentrantLock` feature-by-feature.
2. When does fairness matter? How does it impact throughput?
3. Difference between `await()` and `wait()` semantics, especially regarding interrupts and timeouts.
4. How to avoid deadlocks using `tryLock` with timeout? Show pattern.
5. Can you signal on one condition but await on another? What happens?
6. Why might explicit locks be slower than intrinsic locks in uncontended cases?

