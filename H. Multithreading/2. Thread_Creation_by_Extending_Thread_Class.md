## 1. Topic Overview

Creating threads by extending the Thread class is one of the two primary methods for implementing multithreading in Java. This approach involves creating a new class that inherits from the Thread class and overriding the run() method to define the thread's behavior. While this method is straightforward and commonly used in educational contexts, it has limitations in terms of design flexibility since Java supports only single inheritance. Understanding this approach is essential for grasping thread fundamentals and comparing it with the Runnable interface approach.

## 2. Topic Definition

- **What**: Method of creating threads by extending the Thread class and overriding the run() method
- **Why**: Simple approach for thread creation, direct access to Thread methods, straightforward implementation
- **How**: Create a class extending Thread, override run() method, instantiate and call start() method
- **When/Where**: Simple threading scenarios, when you need direct access to Thread methods, educational purposes
- **What If**:
  - Advantages: Simple implementation, direct access to Thread methods, clear inheritance relationship
  - Disadvantages: Limited by single inheritance, less flexible than Runnable, tight coupling
  - Design issues: Violates composition over inheritance principle
- **Examples**:
  - Basic: `class MyThread extends Thread { public void run() { ... } }`
  - Usage: `MyThread t = new MyThread(); t.start();`

## 3. Deep Dive with Examples

```java
// File: ThreadByExtensionDemo.java
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Comprehensive demonstration of creating threads by extending Thread class
 */
public class ThreadByExtensionDemo {
    
    public static void main(String[] args) {
        demonstrateBasicThreadExtension();
        demonstrateThreadWithParameters();
        demonstrateMultipleThreads();
        demonstrateThreadInheritance();
        demonstrateThreadMethods();
        demonstrateAdvantagesAndDisadvantages();
        demonstrateBestPractices();
    }
    
    static void demonstrateBasicThreadExtension() {
        System.out.println("=== Basic Thread Extension ===");
        
        System.out.println("STEPS TO CREATE THREAD BY EXTENDING THREAD CLASS:");
        System.out.println("1. Create a class that extends Thread");
        System.out.println("2. Override the run() method");
        System.out.println("3. Create an instance of your class");
        System.out.println("4. Call the start() method");
        
        // Basic example
        System.out.println("\n--- Basic Example ---");
        
        SimpleThread simpleThread = new SimpleThread();
        System.out.println("Thread created: " + simpleThread.getName());
        System.out.println("Thread state before start: " + simpleThread.getState());
        
        simpleThread.start();
        
        try {
            simpleThread.join(); // Wait for thread to complete
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Thread state after completion: " + simpleThread.getState());
    }
    
    static void demonstrateThreadWithParameters() {
        System.out.println("\n=== Thread with Parameters ===");
        
        System.out.println("PASSING PARAMETERS TO THREAD:");
        System.out.println("1. Use constructor to pass parameters");
        System.out.println("2. Store parameters as instance variables");
        System.out.println("3. Use parameters in run() method");
        
        // Thread with parameters
        System.out.println("\n--- Parameterized Thread Example ---");
        
        ParameterizedThread paramThread1 = new ParameterizedThread("Worker-1", 5);
        ParameterizedThread paramThread2 = new ParameterizedThread("Worker-2", 3);
        
        paramThread1.start();
        paramThread2.start();
        
        try {
            paramThread1.join();
            paramThread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Both parameterized threads completed");
    }
    
    static void demonstrateMultipleThreads() {
        System.out.println("\n=== Multiple Threads ===");
        
        System.out.println("CREATING MULTIPLE THREADS:");
        System.out.println("1. Create multiple instances of your Thread class");
        System.out.println("2. Start each thread independently");
        System.out.println("3. Use join() to wait for all threads to complete");
        
        // Multiple threads example
        System.out.println("\n--- Multiple Threads Example ---");
        
        Thread[] threads = new Thread[5];
        
        // Create and start multiple threads
        for (int i = 0; i < 5; i++) {
            threads[i] = new CounterThread("Counter-" + (i + 1), 3);
            threads[i].start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("All counter threads completed");
    }
    
    static void demonstrateThreadInheritance() {
        System.out.println("\n=== Thread Inheritance ===");
        
        System.out.println("INHERITANCE CONSIDERATIONS:");
        System.out.println("1. Your class inherits all Thread methods");
        System.out.println("2. Can override other Thread methods if needed");
        System.out.println("3. Limited by single inheritance constraint");
        System.out.println("4. Cannot extend other classes");
        
        // Demonstrate inheritance
        System.out.println("\n--- Inheritance Example ---");
        
        CustomThread customThread = new CustomThread("CustomThread");
        
        // Demonstrate inherited methods
        System.out.println("Thread name: " + customThread.getName());
        System.out.println("Thread priority: " + customThread.getPriority());
        System.out.println("Thread ID: " + customThread.getId());
        System.out.println("Is daemon: " + customThread.isDaemon());
        
        customThread.start();
        
        try {
            customThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate inheritance limitation
        System.out.println("\n--- Inheritance Limitation ---");
        System.out.println("Problem: Cannot extend another class");
        System.out.println("Example: class MyThread extends Thread, SomeOtherClass { } // Compilation error");
        System.out.println("Solution: Use Runnable interface instead");
    }
    
    static void demonstrateThreadMethods() {
        System.out.println("\n=== Thread Methods Access ===");
        
        System.out.println("ACCESS TO THREAD METHODS:");
        System.out.println("1. Direct access to Thread class methods");
        System.out.println("2. Can call methods like getName(), getId(), getPriority()");
        System.out.println("3. Can set thread properties directly");
        System.out.println("4. Can interrupt, join, sleep from within the thread");
        
        // Demonstrate thread methods
        System.out.println("\n--- Thread Methods Example ---");
        
        ThreadMethodsDemo thread = new ThreadMethodsDemo("MethodsDemo");
        
        // Set thread properties
        thread.setPriority(Thread.MAX_PRIORITY);
        thread.setDaemon(false);
        
        System.out.println("Thread properties:");
        System.out.println("- Name: " + thread.getName());
        System.out.println("- Priority: " + thread.getPriority());
        System.out.println("- Is daemon: " + thread.isDaemon());
        System.out.println("- Thread group: " + thread.getThreadGroup().getName());
        
        thread.start();
        
        try {
            thread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateAdvantagesAndDisadvantages() {
        System.out.println("\n=== Advantages and Disadvantages ===");
        
        System.out.println("ADVANTAGES OF EXTENDING THREAD:");
        System.out.println("1. Simple and straightforward implementation");
        System.out.println("2. Direct access to Thread class methods");
        System.out.println("3. Clear inheritance relationship");
        System.out.println("4. Easy to understand for beginners");
        System.out.println("5. Can override other Thread methods if needed");
        
        System.out.println("\nDISADVANTAGES OF EXTENDING THREAD:");
        System.out.println("1. Limited by single inheritance constraint");
        System.out.println("2. Cannot extend other classes");
        System.out.println("3. Less flexible than Runnable approach");
        System.out.println("4. Violates composition over inheritance principle");
        System.out.println("5. Tight coupling with Thread class");
        
        // Demonstrate the inheritance problem
        System.out.println("\n--- Inheritance Problem Demonstration ---");
        
        System.out.println("Scenario: What if you need to extend another class?");
        System.out.println("Example: class DatabaseThread extends Thread, DatabaseConnection { }");
        System.out.println("Result: Compilation error - multiple inheritance not allowed");
        System.out.println("Solution: Use Runnable interface instead");
        
        // Show Runnable alternative
        System.out.println("\n--- Runnable Alternative ---");
        System.out.println("Better approach:");
        System.out.println("class DatabaseThread extends DatabaseConnection implements Runnable { }");
        System.out.println("Thread thread = new Thread(new DatabaseThread());");
    }
    
    static void demonstrateBestPractices() {
        System.out.println("\n=== Best Practices ===");
        
        System.out.println("BEST PRACTICES FOR THREAD EXTENSION:");
        System.out.println("1. Override run() method properly");
        System.out.println("2. Handle InterruptedException correctly");
        System.out.println("3. Use meaningful thread names");
        System.out.println("4. Consider thread safety for shared data");
        System.out.println("5. Clean up resources in finally blocks");
        
        // Demonstrate best practices
        System.out.println("\n--- Best Practices Example ---");
        
        BestPracticesThread bestThread = new BestPracticesThread("BestPractices");
        bestThread.start();
        
        try {
            Thread.sleep(2000); // Let thread run for a bit
            bestThread.interrupt(); // Demonstrate interruption
            bestThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Best practices demonstration completed");
    }
}

// ========== THREAD CLASSES BY EXTENSION ==========

/**
 * Basic thread created by extending Thread class
 */
class SimpleThread extends Thread {
    public SimpleThread() {
        super("SimpleThread"); // Set thread name
    }
    
    @Override
    public void run() {
        System.out.println("Hello from " + getName() + "!");
        
        for (int i = 1; i <= 5; i++) {
            System.out.println(getName() + " - Count: " + i);
            try {
                Thread.sleep(500); // Simulate work
            } catch (InterruptedException e) {
                System.out.println(getName() + " was interrupted");
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println(getName() + " completed");
    }
}

/**
 * Thread with parameters passed through constructor
 */
class ParameterizedThread extends Thread {
    private String workerName;
    private int workCount;
    
    public ParameterizedThread(String workerName, int workCount) {
        super(workerName);
        this.workerName = workerName;
        this.workCount = workCount;
    }
    
    @Override
    public void run() {
        System.out.println(workerName + " started with " + workCount + " tasks");
        
        for (int i = 1; i <= workCount; i++) {
            System.out.println(workerName + " - Task " + i + "/" + workCount);
            try {
                Thread.sleep(1000); // Simulate work
            } catch (InterruptedException e) {
                System.out.println(workerName + " was interrupted");
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println(workerName + " completed all tasks");
    }
}

/**
 * Thread that demonstrates counter functionality
 */
class CounterThread extends Thread {
    private int count;
    private static AtomicInteger sharedCounter = new AtomicInteger(0);
    
    public CounterThread(String name, int count) {
        super(name);
        this.count = count;
    }
    
    @Override
    public void run() {
        System.out.println(getName() + " starting with count: " + count);
        
        for (int i = 1; i <= count; i++) {
            int currentShared = sharedCounter.incrementAndGet();
            System.out.println(getName() + " - Local: " + i + ", Shared: " + currentShared);
            
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                System.out.println(getName() + " was interrupted");
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println(getName() + " finished");
    }
}

/**
 * Custom thread that demonstrates inheritance features
 */
class CustomThread extends Thread {
    public CustomThread(String name) {
        super(name);
    }
    
    @Override
    public void run() {
        System.out.println("CustomThread " + getName() + " running");
        
        // Demonstrate access to inherited methods
        System.out.println("Thread info:");
        System.out.println("- Name: " + getName());
        System.out.println("- ID: " + getId());
        System.out.println("- Priority: " + getPriority());
        System.out.println("- State: " + getState());
        System.out.println("- Is alive: " + isAlive());
        
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("CustomThread " + getName() + " completed");
    }
}

/**
 * Thread that demonstrates access to Thread methods
 */
class ThreadMethodsDemo extends Thread {
    public ThreadMethodsDemo(String name) {
        super(name);
    }
    
    @Override
    public void run() {
        System.out.println("ThreadMethodsDemo " + getName() + " started");
        
        // Demonstrate various thread methods
        System.out.println("Current thread methods demonstration:");
        
        // Sleep method
        try {
            System.out.println("Sleeping for 1 second...");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            System.out.println("Sleep was interrupted");
            Thread.currentThread().interrupt();
        }
        
        // Yield method
        System.out.println("Yielding CPU...");
        Thread.yield();
        
        // Check if interrupted
        if (Thread.currentThread().isInterrupted()) {
            System.out.println("Thread was interrupted");
            return;
        }
        
        System.out.println("ThreadMethodsDemo " + getName() + " completed");
    }
}

/**
 * Thread demonstrating best practices
 */
class BestPracticesThread extends Thread {
    private boolean shouldStop = false;
    
    public BestPracticesThread(String name) {
        super(name);
    }
    
    @Override
    public void run() {
        System.out.println("BestPracticesThread " + getName() + " started");
        
        try {
            // Best practice: Check interruption status
            while (!shouldStop && !Thread.currentThread().isInterrupted()) {
                System.out.println(getName() + " - Working...");
                
                // Best practice: Handle InterruptedException properly
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    System.out.println(getName() + " - Interrupted during sleep");
                    Thread.currentThread().interrupt(); // Restore interrupt status
                    break;
                }
                
                // Simulate some work
                doWork();
            }
        } finally {
            // Best practice: Clean up resources
            cleanup();
        }
        
        System.out.println("BestPracticesThread " + getName() + " completed");
    }
    
    private void doWork() {
        // Simulate work
        for (int i = 0; i < 100000; i++) {
            Math.random();
        }
    }
    
    private void cleanup() {
        System.out.println(getName() + " - Cleaning up resources");
    }
    
    public void requestStop() {
        shouldStop = true;
    }
}

// ========== DEMONSTRATION OF INHERITANCE LIMITATIONS ==========

/**
 * Example showing why extending Thread can be problematic
 */
class InheritanceProblemDemo {
    
    public static void demonstrateInheritanceProblem() {
        System.out.println("\n=== Inheritance Problem Demonstration ===");
        
        System.out.println("PROBLEM: Single Inheritance Limitation");
        System.out.println();
        System.out.println("What if you need to extend another class?");
        System.out.println();
        System.out.println("Example scenario:");
        System.out.println("class DatabaseConnection { }");
        System.out.println("class MyThread extends Thread { }");
        System.out.println();
        System.out.println("What if MyThread needs to be a DatabaseConnection too?");
        System.out.println("class MyThread extends Thread, DatabaseConnection { } // ERROR!");
        System.out.println();
        System.out.println("SOLUTION: Use Runnable interface");
        System.out.println("class MyThread extends DatabaseConnection implements Runnable { }");
        System.out.println("Thread thread = new Thread(new MyThread());");
        
        // Demonstrate the solution
        System.out.println("\n--- Runnable Solution Example ---");
        
        DatabaseThread dbThread = new DatabaseThread();
        Thread thread = new Thread(dbThread, "DatabaseThread");
        
        System.out.println("Thread created using Runnable approach");
        System.out.println("DatabaseThread extends DatabaseConnection and implements Runnable");
        
        thread.start();
        
        try {
            thread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

/**
 * Example of a class that needs to extend another class
 */
class DatabaseConnection {
    protected String connectionString;
    
    public DatabaseConnection() {
        this.connectionString = "jdbc:mysql://localhost:3306/mydb";
    }
    
    public void connect() {
        System.out.println("Connecting to database: " + connectionString);
    }
    
    public void disconnect() {
        System.out.println("Disconnecting from database");
    }
}

/**
 * Thread that extends DatabaseConnection and implements Runnable
 * This demonstrates the Runnable solution to the inheritance problem
 */
class DatabaseThread extends DatabaseConnection implements Runnable {
    @Override
    public void run() {
        System.out.println("DatabaseThread " + Thread.currentThread().getName() + " started");
        
        // Can use DatabaseConnection methods
        connect();
        
        try {
            Thread.sleep(1000); // Simulate database work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        disconnect();
        
        System.out.println("DatabaseThread " + Thread.currentThread().getName() + " completed");
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Override the run() method properly with your thread logic
- Handle InterruptedException correctly by restoring interrupt status
- Use meaningful thread names for debugging
- Consider thread safety when accessing shared data
- Clean up resources in finally blocks

**Don'ts:**
- Don't call run() method directly - use start() method
- Don't start a thread multiple times
- Don't ignore InterruptedException
- Don't rely on thread priorities for critical functionality
- Don't use stop() method (deprecated and unsafe)

**Common Pitfalls:**
- Calling run() instead of start() method
- Starting a thread multiple times (IllegalThreadStateException)
- Not handling InterruptedException properly
- Inheritance limitations when needing to extend other classes
- Tight coupling with Thread class

## 5. Summary

- **Thread Extension** involves creating a class that extends Thread and overrides the run() method
- **Implementation Steps**: Extend Thread → Override run() → Create instance → Call start()
- **Advantages**: Simple implementation, direct access to Thread methods, clear inheritance
- **Disadvantages**: Single inheritance limitation, less flexible than Runnable, tight coupling
- **Inheritance Problem**: Cannot extend other classes due to single inheritance constraint
- **Runnable Alternative**: Better approach for classes that need to extend other classes
- **Best Practices**: Proper exception handling, meaningful names, resource cleanup

## 6. Tricky Interview Questions

1. **Thread Creation**: How do you create a thread by extending Thread class? What are the steps involved?

2. **Inheritance Limitation**: What is the main disadvantage of extending Thread class? How do you solve this problem?

3. **start() vs run()**: What happens if you call run() method directly instead of start() method when extending Thread?

4. **Multiple Inheritance**: Why can't you extend Thread class if you need to extend another class? Show the solution.

5. **Thread Methods**: What Thread class methods are directly accessible when extending Thread? Give examples.

6. **Thread Safety**: How do you ensure thread safety when extending Thread class? What are the considerations?

7. **Resource Management**: How do you properly manage resources and cleanup when extending Thread class?

8. **Exception Handling**: How do you handle InterruptedException when extending Thread class? Why is it important?

9. **Thread Lifecycle**: How does extending Thread class affect the thread lifecycle? What methods can you override?

10. **Design Patterns**: Why is extending Thread class considered less flexible than implementing Runnable? Explain with examples.

11. **Performance**: Are there any performance differences between extending Thread and implementing Runnable?

12. **Best Practices**: What are the best practices when creating threads by extending Thread class? What should you avoid?
