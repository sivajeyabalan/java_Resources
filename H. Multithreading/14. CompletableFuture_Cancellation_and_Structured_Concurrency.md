## 1. Topic Overview

- Robust async with `CompletableFuture`: cancellation, timeouts, and structured concurrency patterns.

## 2 . Topic definition

- WHAT: Cancelling futures, enforcing timeouts, composing with cancellation propagation, structuring lifetimes of tasks.
- WHY: Avoid runaway tasks, resource leaks, and orphaned work.
- HOW: `orTimeout`, `completeOnTimeout`, `cancel(true)`, compose with `handle` and track child tasks; use custom executors.
- WHEN/WHERE: Service aggregations, parallel fetches, external calls.

## 3. Deep Dive with Examples

```java
import java.util.concurrent.*;

class CancelDemo {
    public static void main(String[] args) {
        CompletableFuture<String> f = new CompletableFuture<>();
        f.cancel(true);
        System.out.println(f.isCancelled());
    }
}
```

```java
// Timeout and fallback
CompletableFuture<String> v = CompletableFuture.supplyAsync(() -> slow())
    .orTimeout(1, java.util.concurrent.TimeUnit.SECONDS)
    .exceptionally(ex -> "fallback");
```

```java
// Structured pattern: collect and cancel on first success
java.util.List<CompletableFuture<String>> tasks = java.util.List.of(callA(), callB(), callC());
CompletableFuture<Object> any = CompletableFuture.anyOf(tasks.toArray(new CompletableFuture[0]));
String result = (String) any.thenApply(r -> { tasks.forEach(t -> t.cancel(true)); return r; }).join();
```

## 4. Best Practices & Pitfalls

- Propagate cancellation to child tasks; ensure executors are sized for workload.
- Combine with `ExecutorService` timeouts and HTTP client timeouts for full-path control.
- Avoid blocking operations in common pool; use dedicated pools for IO.

## 5. Summary

- Handling cancellation and timeouts is essential for resilient async systems.

## 6. Tricky Interview Questions

1. How do you propagate cancellation through a composed future graph?
2. Difference between `orTimeout` and `completeOnTimeout` in failure semantics.

