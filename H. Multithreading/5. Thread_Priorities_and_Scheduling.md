## 1. Topic Overview

Thread priorities in Java provide a way to influence thread scheduling by the JVM, though they are not guaranteed to work as expected across all platforms. Thread priorities range from 1 (MIN_PRIORITY) to 10 (MAX_PRIORITY), with 5 (NORM_PRIORITY) being the default. Thread scheduling determines which thread gets CPU time and when, but it's largely platform-dependent and should not be relied upon for critical functionality. Understanding thread priorities helps developers understand thread behavior and make informed decisions about thread management.

## 2. Topic Definition

- **What**: Thread priorities are integer values (1-10) that hint to the JVM scheduler about thread execution preference
- **Why**: Influence thread scheduling, give preference to important threads, optimize performance for critical tasks
- **How**: Through setPriority() method, Thread.MIN_PRIORITY, Thread.NORM_PRIORITY, Thread.MAX_PRIORITY constants
- **When/Where**: When you want to influence thread scheduling, performance-critical applications, real-time systems
- **What If**:
  - High priority: Thread gets more CPU time (platform-dependent)
  - Low priority: Thread gets less CPU time (platform-dependent)
  - No guarantee: Scheduler may ignore priorities completely
- **Examples**:
  - Setting: `thread.setPriority(Thread.MAX_PRIORITY)`
  - Getting: `int priority = thread.getPriority()`

## 3. Deep Dive with Examples

```java
// File: ThreadPrioritiesDemo.java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Comprehensive demonstration of thread priorities and scheduling
 */
public class ThreadPrioritiesDemo {
    
    public static void main(String[] args) {
        demonstrateThreadPriorities();
        demonstratePriorityLevels();
        demonstratePriorityInheritance();
        demonstratePriorityEffects();
        demonstrateSchedulingBehavior();
        demonstratePriorityLimitations();
        demonstrateBestPractices();
    }
    
    static void demonstrateThreadPriorities() {
        System.out.println("=== Thread Priorities ===");
        
        System.out.println("THREAD PRIORITY LEVELS:");
        System.out.println("1. MIN_PRIORITY = 1 (lowest priority)");
        System.out.println("2. NORM_PRIORITY = 5 (default priority)");
        System.out.println("3. MAX_PRIORITY = 10 (highest priority)");
        System.out.println("4. Range: 1 to 10 (inclusive)");
        
        // Demonstrate priority constants
        System.out.println("\n--- Priority Constants ---");
        System.out.println("MIN_PRIORITY: " + Thread.MIN_PRIORITY);
        System.out.println("NORM_PRIORITY: " + Thread.NORM_PRIORITY);
        System.out.println("MAX_PRIORITY: " + Thread.MAX_PRIORITY);
        
        // Demonstrate setting and getting priorities
        System.out.println("\n--- Setting and Getting Priorities ---");
        
        Thread priorityThread = new Thread(() -> {
            System.out.println("Thread priority: " + Thread.currentThread().getPriority());
        }, "PriorityThread");
        
        System.out.println("Default priority: " + priorityThread.getPriority());
        
        priorityThread.setPriority(Thread.MAX_PRIORITY);
        System.out.println("After setting MAX_PRIORITY: " + priorityThread.getPriority());
        
        priorityThread.setPriority(Thread.MIN_PRIORITY);
        System.out.println("After setting MIN_PRIORITY: " + priorityThread.getPriority());
        
        priorityThread.setPriority(7); // Custom priority
        System.out.println("After setting custom priority 7: " + priorityThread.getPriority());
        
        priorityThread.start();
        
        try {
            priorityThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstratePriorityLevels() {
        System.out.println("\n=== Priority Levels Demonstration ===");
        
        System.out.println("DEMONSTRATING DIFFERENT PRIORITY LEVELS:");
        
        // Create threads with different priorities
        Thread[] threads = new Thread[5];
        int[] priorities = {Thread.MIN_PRIORITY, 3, Thread.NORM_PRIORITY, 7, Thread.MAX_PRIORITY};
        String[] names = {"MinPriority", "LowPriority", "NormalPriority", "HighPriority", "MaxPriority"};
        
        for (int i = 0; i < 5; i++) {
            final int index = i;
            threads[i] = new Thread(() -> {
                System.out.println(names[index] + " thread started with priority: " + 
                                 Thread.currentThread().getPriority());
                
                // Simulate work
                for (int j = 0; j < 5; j++) {
                    System.out.println(names[index] + " - Iteration: " + j);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
                
                System.out.println(names[index] + " thread completed");
            }, names[index]);
            
            threads[i].setPriority(priorities[i]);
        }
        
        // Start all threads
        for (Thread thread : threads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("All priority threads completed");
    }
    
    static void demonstratePriorityInheritance() {
        System.out.println("\n=== Priority Inheritance ===");
        
        System.out.println("PRIORITY INHERITANCE:");
        System.out.println("1. Child threads inherit priority from parent thread");
        System.out.println("2. Main thread has NORM_PRIORITY by default");
        System.out.println("3. Thread groups can have different priorities");
        System.out.println("4. Priority inheritance affects thread scheduling");
        
        // Demonstrate priority inheritance
        System.out.println("\n--- Priority Inheritance Demonstration ---");
        
        System.out.println("Main thread priority: " + Thread.currentThread().getPriority());
        
        // Create thread with default priority
        Thread defaultThread = new Thread(() -> {
            System.out.println("Default thread priority: " + Thread.currentThread().getPriority());
            
            // Create child thread
            Thread childThread = new Thread(() -> {
                System.out.println("Child thread priority: " + Thread.currentThread().getPriority());
            }, "ChildThread");
            
            childThread.start();
            
            try {
                childThread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "DefaultThread");
        
        defaultThread.start();
        
        try {
            defaultThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate priority change
        System.out.println("\n--- Priority Change Demonstration ---");
        
        Thread parentThread = new Thread(() -> {
            System.out.println("Parent thread priority: " + Thread.currentThread().getPriority());
            
            // Change priority
            Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
            System.out.println("Parent thread priority after change: " + Thread.currentThread().getPriority());
            
            // Create child thread after priority change
            Thread childThread = new Thread(() -> {
                System.out.println("Child thread priority: " + Thread.currentThread().getPriority());
            }, "ChildThread");
            
            childThread.start();
            
            try {
                childThread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "ParentThread");
        
        parentThread.start();
        
        try {
            parentThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstratePriorityEffects() {
        System.out.println("\n=== Priority Effects ===");
        
        System.out.println("PRIORITY EFFECTS:");
        System.out.println("1. Higher priority threads get more CPU time");
        System.out.println("2. Lower priority threads get less CPU time");
        System.out.println("3. Effects are platform-dependent");
        System.out.println("4. Not guaranteed to work on all systems");
        
        // Demonstrate priority effects
        System.out.println("\n--- Priority Effects Demonstration ---");
        
        AtomicInteger highPriorityCount = new AtomicInteger(0);
        AtomicInteger lowPriorityCount = new AtomicInteger(0);
        
        // High priority thread
        Thread highPriorityThread = new Thread(() -> {
            System.out.println("High priority thread started");
            
            for (int i = 0; i < 1000; i++) {
                highPriorityCount.incrementAndGet();
                // Simulate work
                for (int j = 0; j < 1000; j++) {
                    Math.random();
                }
            }
            
            System.out.println("High priority thread completed");
        }, "HighPriorityThread");
        
        // Low priority thread
        Thread lowPriorityThread = new Thread(() -> {
            System.out.println("Low priority thread started");
            
            for (int i = 0; i < 1000; i++) {
                lowPriorityCount.incrementAndGet();
                // Simulate work
                for (int j = 0; j < 1000; j++) {
                    Math.random();
                }
            }
            
            System.out.println("Low priority thread completed");
        }, "LowPriorityThread");
        
        // Set priorities
        highPriorityThread.setPriority(Thread.MAX_PRIORITY);
        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);
        
        System.out.println("High priority thread priority: " + highPriorityThread.getPriority());
        System.out.println("Low priority thread priority: " + lowPriorityThread.getPriority());
        
        // Start threads
        highPriorityThread.start();
        lowPriorityThread.start();
        
        // Wait for completion
        try {
            highPriorityThread.join();
            lowPriorityThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("High priority thread count: " + highPriorityCount.get());
        System.out.println("Low priority thread count: " + lowPriorityCount.get());
        System.out.println("Note: Results may vary depending on platform and system load");
    }
    
    static void demonstrateSchedulingBehavior() {
        System.out.println("\n=== Scheduling Behavior ===");
        
        System.out.println("THREAD SCHEDULING BEHAVIOR:");
        System.out.println("1. Preemptive scheduling (most common)");
        System.out.println("2. Cooperative scheduling (some platforms)");
        System.out.println("3. Time-sliced scheduling");
        System.out.println("4. Priority-based scheduling");
        
        // Demonstrate scheduling behavior
        System.out.println("\n--- Scheduling Behavior Demonstration ---");
        
        System.out.println("Creating threads with different priorities to observe scheduling...");
        
        Thread[] threads = new Thread[3];
        int[] priorities = {Thread.MIN_PRIORITY, Thread.NORM_PRIORITY, Thread.MAX_PRIORITY};
        String[] names = {"MinPriority", "NormalPriority", "MaxPriority"};
        
        for (int i = 0; i < 3; i++) {
            final int index = i;
            threads[i] = new Thread(() -> {
                System.out.println(names[index] + " thread started");
                
                // Simulate work with different intensities
                for (int j = 0; j < 10; j++) {
                    System.out.println(names[index] + " - Work: " + j);
                    
                    // Different work intensities
                    int workIntensity = (index + 1) * 100000;
                    for (int k = 0; k < workIntensity; k++) {
                        Math.random();
                    }
                }
                
                System.out.println(names[index] + " thread completed");
            }, names[index]);
            
            threads[i].setPriority(priorities[i]);
        }
        
        // Start threads
        for (Thread thread : threads) {
            thread.start();
        }
        
        // Wait for completion
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Scheduling behavior demonstration completed");
    }
    
    static void demonstratePriorityLimitations() {
        System.out.println("\n=== Priority Limitations ===");
        
        System.out.println("PRIORITY LIMITATIONS:");
        System.out.println("1. Platform-dependent behavior");
        System.out.println("2. Scheduler may ignore priorities");
        System.out.println("3. Not suitable for real-time applications");
        System.out.println("4. Can cause thread starvation");
        System.out.println("5. Difficult to predict behavior");
        
        // Demonstrate limitations
        System.out.println("\n--- Priority Limitations Demonstration ---");
        
        System.out.println("Creating threads with extreme priority differences...");
        
        // Very high priority thread
        Thread veryHighPriorityThread = new Thread(() -> {
            System.out.println("Very high priority thread started");
            
            for (int i = 0; i < 5; i++) {
                System.out.println("Very high priority - Iteration: " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("Very high priority thread completed");
        }, "VeryHighPriorityThread");
        
        // Very low priority thread
        Thread veryLowPriorityThread = new Thread(() -> {
            System.out.println("Very low priority thread started");
            
            for (int i = 0; i < 5; i++) {
                System.out.println("Very low priority - Iteration: " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("Very low priority thread completed");
        }, "VeryLowPriorityThread");
        
        // Set extreme priorities
        veryHighPriorityThread.setPriority(Thread.MAX_PRIORITY);
        veryLowPriorityThread.setPriority(Thread.MIN_PRIORITY);
        
        System.out.println("Very high priority thread priority: " + veryHighPriorityThread.getPriority());
        System.out.println("Very low priority thread priority: " + veryLowPriorityThread.getPriority());
        
        // Start threads
        veryHighPriorityThread.start();
        veryLowPriorityThread.start();
        
        // Wait for completion
        try {
            veryHighPriorityThread.join();
            veryLowPriorityThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Priority limitations demonstration completed");
        System.out.println("Note: Behavior may vary significantly across different platforms");
    }
    
    static void demonstrateBestPractices() {
        System.out.println("\n=== Best Practices ===");
        
        System.out.println("BEST PRACTICES FOR THREAD PRIORITIES:");
        System.out.println("1. Don't rely on priorities for critical functionality");
        System.out.println("2. Use priorities as hints, not guarantees");
        System.out.println("3. Test priority behavior on target platform");
        System.out.println("4. Avoid extreme priority differences");
        System.out.println("5. Use modern concurrency utilities instead");
        System.out.println("6. Consider thread starvation issues");
        System.out.println("7. Use proper synchronization instead of priorities");
        
        // Demonstrate best practices
        System.out.println("\n--- Best Practices Example ---");
        
        System.out.println("Instead of relying on priorities, use proper synchronization:");
        
        // Example: Using synchronized blocks instead of priorities
        Object lock = new Object();
        AtomicInteger counter = new AtomicInteger(0);
        
        Thread[] synchronizedThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            synchronizedThreads[i] = new Thread(() -> {
                synchronized (lock) {
                    System.out.println("Thread " + threadId + " acquired lock");
                    
                    // Simulate work
                    for (int j = 0; j < 3; j++) {
                        int count = counter.incrementAndGet();
                        System.out.println("Thread " + threadId + " - Count: " + count);
                        try {
                            Thread.sleep(200);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            break;
                        }
                    }
                    
                    System.out.println("Thread " + threadId + " releasing lock");
                }
            }, "SynchronizedThread-" + threadId);
        }
        
        // Start threads
        for (Thread thread : synchronizedThreads) {
            thread.start();
        }
        
        // Wait for completion
        for (Thread thread : synchronizedThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Best practices demonstration completed");
        
        // Demonstrate modern alternatives
        System.out.println("\n--- Modern Alternatives ---");
        
        System.out.println("Modern alternatives to thread priorities:");
        System.out.println("1. ExecutorService with different thread pools");
        System.out.println("2. CompletableFuture for asynchronous operations");
        System.out.println("3. Fork/Join framework for parallel processing");
        System.out.println("4. Concurrent collections and utilities");
        System.out.println("5. Semaphores and other synchronization primitives");
        
        // ExecutorService example
        System.out.println("\n--- ExecutorService Example ---");
        
        ExecutorService highPriorityExecutor = Executors.newFixedThreadPool(2);
        ExecutorService lowPriorityExecutor = Executors.newFixedThreadPool(2);
        
        // Submit tasks to different executors
        highPriorityExecutor.submit(() -> {
            System.out.println("High priority task executed in: " + Thread.currentThread().getName());
        });
        
        lowPriorityExecutor.submit(() -> {
            System.out.println("Low priority task executed in: " + Thread.currentThread().getName());
        });
        
        // Shutdown executors
        highPriorityExecutor.shutdown();
        lowPriorityExecutor.shutdown();
        
        try {
            highPriorityExecutor.awaitTermination(1, TimeUnit.SECONDS);
            lowPriorityExecutor.awaitTermination(1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Modern alternatives demonstration completed");
    }
}

// ========== HELPER CLASSES ==========

/**
 * Thread demonstrating priority behavior
 */
class PriorityDemoThread extends Thread {
    private String threadName;
    private int workCount;
    private AtomicInteger sharedCounter;
    
    public PriorityDemoThread(String threadName, int workCount, AtomicInteger sharedCounter) {
        super(threadName);
        this.threadName = threadName;
        this.workCount = workCount;
        this.sharedCounter = sharedCounter;
    }
    
    @Override
    public void run() {
        System.out.println(threadName + " started with priority: " + getPriority());
        
        for (int i = 0; i < workCount; i++) {
            int count = sharedCounter.incrementAndGet();
            System.out.println(threadName + " - Work: " + i + ", Shared count: " + count);
            
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println(threadName + " completed");
    }
}

/**
 * Thread demonstrating priority inheritance
 */
class PriorityInheritanceThread extends Thread {
    private String threadName;
    
    public PriorityInheritanceThread(String threadName) {
        super(threadName);
        this.threadName = threadName;
    }
    
    @Override
    public void run() {
        System.out.println(threadName + " started with priority: " + getPriority());
        
        // Create child thread
        Thread childThread = new Thread(() -> {
            System.out.println("Child thread of " + threadName + " started with priority: " + 
                             Thread.currentThread().getPriority());
            
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("Child thread of " + threadName + " completed");
        }, "ChildOf" + threadName);
        
        childThread.start();
        
        try {
            childThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println(threadName + " completed");
    }
}

/**
 * Thread demonstrating priority effects
 */
class PriorityEffectsThread extends Thread {
    private String threadName;
    private AtomicInteger counter;
    private int iterations;
    
    public PriorityEffectsThread(String threadName, AtomicInteger counter, int iterations) {
        super(threadName);
        this.threadName = threadName;
        this.counter = counter;
        this.iterations = iterations;
    }
    
    @Override
    public void run() {
        System.out.println(threadName + " started with priority: " + getPriority());
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < iterations; i++) {
            counter.incrementAndGet();
            
            // Simulate work
            for (int j = 0; j < 1000; j++) {
                Math.random();
            }
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println(threadName + " completed " + iterations + " iterations in " + 
                         (endTime - startTime) + " ms");
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use priorities as hints, not guarantees
- Test priority behavior on target platform
- Use modern concurrency utilities when possible
- Use proper synchronization instead of relying on priorities
- Consider thread starvation issues

**Don'ts:**
- Don't rely on priorities for critical functionality
- Don't use extreme priority differences
- Don't expect consistent behavior across platforms
- Don't use priorities as the only synchronization mechanism
- Don't ignore thread starvation issues

**Common Pitfalls:**
- Assuming priorities work consistently across platforms
- Using priorities for critical functionality
- Creating thread starvation with extreme priorities
- Ignoring platform-specific behavior
- Not testing priority behavior on target platform

## 5. Summary

- **Thread Priorities** range from 1 (MIN_PRIORITY) to 10 (MAX_PRIORITY), with 5 (NORM_PRIORITY) as default
- **Priority Setting** uses setPriority() method and Thread priority constants
- **Priority Inheritance** means child threads inherit priority from parent threads
- **Priority Effects** are platform-dependent and not guaranteed
- **Scheduling Behavior** varies across platforms and may ignore priorities
- **Limitations** include platform dependency, potential thread starvation, and unpredictable behavior
- **Best Practices** recommend using priorities as hints and preferring modern concurrency utilities

## 6. Tricky Interview Questions

1. **Thread Priorities**: What are the different priority levels in Java? How do you set and get thread priorities?

2. **Priority Inheritance**: How does priority inheritance work in Java? Give examples of priority inheritance.

3. **Priority Effects**: What are the effects of setting different thread priorities? Are these effects guaranteed?

4. **Scheduling Behavior**: How does thread scheduling work in Java? What factors influence thread scheduling?

5. **Priority Limitations**: What are the limitations of thread priorities? Why shouldn't you rely on them for critical functionality?

6. **Platform Dependency**: Why are thread priorities platform-dependent? How does this affect application behavior?

7. **Thread Starvation**: What is thread starvation? How can thread priorities cause thread starvation?

8. **Modern Alternatives**: What are the modern alternatives to thread priorities? How do they compare?

9. **Priority Constants**: What are the Thread priority constants? How do you use them effectively?

10. **Synchronization vs Priorities**: When should you use synchronization instead of thread priorities? Give examples.

11. **Real-time Applications**: Why are thread priorities not suitable for real-time applications? What are the alternatives?

12. **Best Practices**: What are the best practices for using thread priorities? What should you avoid?
