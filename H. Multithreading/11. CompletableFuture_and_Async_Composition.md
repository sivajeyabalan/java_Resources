## 1. Topic Overview

- `CompletableFuture` enables building asynchronous pipelines with composition, timeouts, and error handling without manual thread management.

## 2 . Topic definition

- WHAT: A future that can be completed programmatically and supports functional composition (`thenApply`, `thenCompose`, `allOf`, `anyOf`).
- WHY: Simplifies async flows, parallel fetching, and non-blocking transformations.
- HOW: Supply tasks asynchronously, compose stages, combine results, handle exceptions (`exceptionally`, `handle`). Use custom executors when needed.
- WHEN/WHERE: Service aggregation, I/O-bound operations, UI responsiveness, background tasks.
- WHAT IF: Blocking within common pool harms throughput; forgetting `join()/get()` or terminal operations may leave tasks unfinished.

## 3. Deep Dive with Examples

```java
import java.util.concurrent.*;

public class CfBasics {
    public static void main(String[] args) {
        CompletableFuture<Integer> f = CompletableFuture.supplyAsync(() -> compute(21))
            .thenApply(x -> x * 2) // transform
            .exceptionally(ex -> 0); // fallback

        System.out.println(f.join());
    }

    static int compute(int x) { return x; }
}
```

```java
// Composition: thenCompose for dependent async calls
import java.util.concurrent.*;

class ComposeExample {
    static CompletableFuture<String> fetchUser(int id) { return CompletableFuture.supplyAsync(() -> "user-" + id); }
    static CompletableFuture<String> fetchOrders(String user) { return CompletableFuture.supplyAsync(() -> user + "-orders"); }

    public static void main(String[] args) {
        String result = fetchUser(1)
            .thenCompose(ComposeExample::fetchOrders)
            .join();
        System.out.println(result);
    }
}
```

```java
// Combining: thenCombine and allOf
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class CombineExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> 32);
        int sum = f1.thenCombine(f2, Integer::sum).join();
        System.out.println(sum);

        List<CompletableFuture<Integer>> list = Stream.of(1,2,3,4)
            .map(i -> CompletableFuture.supplyAsync(() -> i * i))
            .collect(Collectors.toList());
        CompletableFuture<Void> all = CompletableFuture.allOf(list.toArray(new CompletableFuture[0]));
        List<Integer> squares = all.thenApply(v -> list.stream().map(CompletableFuture::join).collect(Collectors.toList())).join();
        System.out.println(squares);
    }
}
```

```java
// Timeouts and default executor
import java.time.Duration;
import java.util.concurrent.*;

class TimeoutExample {
    public static void main(String[] args) {
        ExecutorService ioPool = Executors.newFixedThreadPool(50);
        try {
            String v = CompletableFuture.supplyAsync(() -> slow(), ioPool)
                .orTimeout(2, TimeUnit.SECONDS)
                .exceptionally(ex -> "fallback")
                .join();
            System.out.println(v);
        } finally {
            ioPool.shutdown();
        }
    }

    static String slow() {
        try { Thread.sleep(3000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        return "done";
    }
}
```

## 4. Best Practices & Pitfalls

- Prefer non-blocking chains; avoid `get()` earlyâ€”use composition.
- Provide dedicated executors for blocking I/O; avoid overloading common fork-join pool.
- Use `handle` for centralized error mapping; use `allOf` and join results safely.
- Add timeouts (`orTimeout`, `completeOnTimeout`) and cancellation propagation if needed.

## 5. Summary

- `CompletableFuture` enables expressive async pipelines with composition, combination, and robust error handling.

## 6. Tricky Interview Questions

1. Difference between `thenApply`, `thenCompose`, and `thenCombine` with examples.
2. How to parallelize N tasks and collect results while handling partial failures?
3. How do `orTimeout` and `completeOnTimeout` differ? When to use each?
4. When should you provide a custom executor to `supplyAsync`/`runAsync`?
5. Show how to cancel a pipeline and propagate cancellation downstream.

