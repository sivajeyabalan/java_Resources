## 1. Topic Overview

Thread controlling mechanisms in Java provide ways to manage thread execution, synchronization, and lifecycle. These mechanisms include methods like start(), run(), join(), interrupt(), sleep(), yield(), and various synchronization techniques. Understanding thread control is crucial for building robust multithreaded applications, managing thread lifecycle, handling thread communication, and ensuring proper resource management. Thread control mechanisms help developers coordinate multiple threads, prevent race conditions, and create responsive applications.

## 2. Topic Definition

- **What**: Methods and techniques used to control thread execution, lifecycle, and synchronization in Java
- **Why**: Manage thread behavior, coordinate multiple threads, prevent race conditions, ensure proper resource management
- **How**: Through Thread class methods, synchronization mechanisms, interrupt handling, and lifecycle management
- **When/Where**: Multithreaded applications, thread coordination, resource sharing, concurrent programming
- **What If**:
  - Without control: Race conditions, deadlocks, resource conflicts, unpredictable behavior
  - With proper control: Synchronized execution, coordinated threads, predictable behavior
  - Improper control: Thread starvation, deadlocks, data corruption
- **Examples**:
  - Control: `thread.start()`, `thread.join()`, `thread.interrupt()`
  - Synchronization: `synchronized` blocks, `wait()`, `notify()`

## 3. Deep Dive with Examples

```java
// File: ThreadControlMechanismsDemo.java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Comprehensive demonstration of thread controlling mechanisms and lifecycle
 */
public class ThreadControlMechanismsDemo {
    
    public static void main(String[] args) {
        demonstrateThreadLifecycle();
        demonstrateStartVsRun();
        demonstrateJoinMethod();
        demonstrateInterruptMechanism();
        demonstrateSleepMethod();
        demonstrateYieldMethod();
        demonstrateThreadStates();
        demonstrateSynchronizationControl();
        demonstrateThreadCommunication();
        demonstrateBestPractices();
    }
    
    static void demonstrateThreadLifecycle() {
        System.out.println("=== Thread Lifecycle ===");
        
        System.out.println("THREAD LIFECYCLE STATES:");
        System.out.println("1. NEW - Thread created but not started");
        System.out.println("2. RUNNABLE - Thread is executing or ready to execute");
        System.out.println("3. BLOCKED - Thread waiting for monitor lock");
        System.out.println("4. WAITING - Thread waiting indefinitely for another thread");
        System.out.println("5. TIMED_WAITING - Thread waiting for specified time");
        System.out.println("6. TERMINATED - Thread has completed execution");
        
        // Demonstrate lifecycle
        System.out.println("\n--- Thread Lifecycle Demonstration ---");
        
        Thread lifecycleThread = new Thread(() -> {
            System.out.println("Thread started: " + Thread.currentThread().getState());
            
            try {
                Thread.sleep(1000); // TIMED_WAITING state
                System.out.println("Thread after sleep: " + Thread.currentThread().getState());
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted: " + Thread.currentThread().getState());
                Thread.currentThread().interrupt();
            }
            
            System.out.println("Thread completing: " + Thread.currentThread().getState());
        }, "LifecycleThread");
        
        System.out.println("Thread state before start: " + lifecycleThread.getState());
        
        lifecycleThread.start();
        
        // Monitor state changes
        Thread.State previousState = lifecycleThread.getState();
        while (lifecycleThread.isAlive()) {
            Thread.State currentState = lifecycleThread.getState();
            if (currentState != previousState) {
                System.out.println("Thread state changed: " + previousState + " -> " + currentState);
                previousState = currentState;
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final thread state: " + lifecycleThread.getState());
        
        try {
            lifecycleThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateStartVsRun() {
        System.out.println("\n=== start() vs run() Method ===");
        
        System.out.println("DIFFERENCE BETWEEN start() AND run():");
        System.out.println("- start(): Creates new thread and calls run() in that thread");
        System.out.println("- run(): Executes code in current thread (no new thread)");
        System.out.println("- Never call run() directly when you want a new thread");
        
        // Demonstrate start() method
        System.out.println("\n--- Using start() Method ---");
        
        Thread startThread = new Thread(() -> {
            System.out.println("Thread using start(): " + Thread.currentThread().getName());
            System.out.println("Thread ID: " + Thread.currentThread().getId());
            System.out.println("Is new thread: " + (Thread.currentThread() != Thread.currentThread()));
        }, "StartThread");
        
        System.out.println("Calling start() method:");
        startThread.start();
        
        try {
            startThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate run() method
        System.out.println("\n--- Using run() Method Directly ---");
        
        Thread runThread = new Thread(() -> {
            System.out.println("Thread using run(): " + Thread.currentThread().getName());
            System.out.println("Thread ID: " + Thread.currentThread().getId());
            System.out.println("Is main thread: " + Thread.currentThread().getName().equals("main"));
        }, "RunThread");
        
        System.out.println("Calling run() method directly:");
        runThread.run(); // This runs in main thread, not new thread
        
        // Demonstrate the problem
        System.out.println("\n--- Problem Demonstration ---");
        
        System.out.println("What happens if you call run() instead of start()?");
        System.out.println("1. Code executes in current thread (usually main thread)");
        System.out.println("2. No new thread is created");
        System.out.println("3. Sequential execution instead of concurrent");
        System.out.println("4. Thread object remains in NEW state");
        
        Thread problemThread = new Thread(() -> {
            System.out.println("This should run in a new thread");
        }, "ProblemThread");
        
        System.out.println("Thread state before run(): " + problemThread.getState());
        problemThread.run(); // Wrong way
        System.out.println("Thread state after run(): " + problemThread.getState());
        
        System.out.println("Thread state before start(): " + problemThread.getState());
        problemThread.start(); // Correct way
        try {
            problemThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("Thread state after start(): " + problemThread.getState());
    }
    
    static void demonstrateJoinMethod() {
        System.out.println("\n=== join() Method ===");
        
        System.out.println("JOIN METHOD PURPOSE:");
        System.out.println("1. Wait for a thread to complete execution");
        System.out.println("2. Block current thread until target thread finishes");
        System.out.println("3. Ensure proper thread coordination");
        System.out.println("4. Prevent main thread from exiting prematurely");
        
        // Basic join demonstration
        System.out.println("\n--- Basic join() Demonstration ---");
        
        Thread worker1 = new Thread(() -> {
            System.out.println("Worker 1 started");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("Worker 1 completed");
        }, "Worker1");
        
        Thread worker2 = new Thread(() -> {
            System.out.println("Worker 2 started");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("Worker 2 completed");
        }, "Worker2");
        
        worker1.start();
        worker2.start();
        
        System.out.println("Main thread waiting for workers...");
        
        try {
            worker1.join(); // Wait for worker1 to complete
            System.out.println("Worker 1 finished, continuing...");
            
            worker2.join(); // Wait for worker2 to complete
            System.out.println("Worker 2 finished, continuing...");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("All workers completed, main thread continuing");
        
        // Join with timeout
        System.out.println("\n--- join() with Timeout ---");
        
        Thread timeoutThread = new Thread(() -> {
            try {
                Thread.sleep(5000); // Sleep for 5 seconds
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("Timeout thread completed");
        }, "TimeoutThread");
        
        timeoutThread.start();
        
        try {
            System.out.println("Waiting for timeout thread with 2 second timeout...");
            boolean finished = timeoutThread.join(2000); // Wait max 2 seconds
            
            if (finished) {
                System.out.println("Timeout thread completed within timeout");
            } else {
                System.out.println("Timeout thread did not complete within timeout");
                System.out.println("Timeout thread is still alive: " + timeoutThread.isAlive());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Wait for timeout thread to complete
        try {
            timeoutThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateInterruptMechanism() {
        System.out.println("\n=== Interrupt Mechanism ===");
        
        System.out.println("INTERRUPT MECHANISM:");
        System.out.println("1. interrupt() - Sets interrupt flag on thread");
        System.out.println("2. isInterrupted() - Checks if thread is interrupted");
        System.out.println("3. interrupted() - Checks and clears interrupt flag");
        System.out.println("4. InterruptedException - Thrown by blocking methods when interrupted");
        
        // Basic interrupt demonstration
        System.out.println("\n--- Basic Interrupt Demonstration ---");
        
        Thread interruptibleThread = new Thread(() -> {
            System.out.println("Interruptible thread started");
            
            try {
                for (int i = 0; i < 10; i++) {
                    if (Thread.currentThread().isInterrupted()) {
                        System.out.println("Thread was interrupted, stopping...");
                        break;
                    }
                    System.out.println("Working... " + i);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted via InterruptedException");
                Thread.currentThread().interrupt(); // Restore interrupt status
            }
            
            System.out.println("Interruptible thread completed");
        }, "InterruptibleThread");
        
        interruptibleThread.start();
        
        try {
            Thread.sleep(1500); // Let thread run for a bit
            System.out.println("Interrupting thread...");
            interruptibleThread.interrupt(); // Interrupt the thread
            interruptibleThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Interrupt status demonstration
        System.out.println("\n--- Interrupt Status Demonstration ---");
        
        Thread statusThread = new Thread(() -> {
            System.out.println("Status thread started");
            
            // Check interrupt status
            System.out.println("Initial interrupt status: " + Thread.currentThread().isInterrupted());
            
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("Interrupted during sleep");
                System.out.println("Interrupt status after InterruptedException: " + 
                                 Thread.currentThread().isInterrupted());
                Thread.currentThread().interrupt(); // Restore interrupt status
                System.out.println("Interrupt status after restore: " + 
                                 Thread.currentThread().isInterrupted());
            }
            
            System.out.println("Status thread completed");
        }, "StatusThread");
        
        statusThread.start();
        
        try {
            Thread.sleep(500);
            statusThread.interrupt();
            statusThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // interrupted() vs isInterrupted()
        System.out.println("\n--- interrupted() vs isInterrupted() ---");
        
        System.out.println("Difference between interrupted() and isInterrupted():");
        System.out.println("- interrupted(): Checks and clears interrupt flag (static method)");
        System.out.println("- isInterrupted(): Checks interrupt flag without clearing (instance method)");
        
        Thread interruptedDemoThread = new Thread(() -> {
            System.out.println("Interrupted demo thread started");
            
            // Set interrupt flag
            Thread.currentThread().interrupt();
            System.out.println("Interrupt flag set");
            
            // Check with isInterrupted() - doesn't clear flag
            System.out.println("isInterrupted(): " + Thread.currentThread().isInterrupted());
            System.out.println("isInterrupted() again: " + Thread.currentThread().isInterrupted());
            
            // Check with interrupted() - clears flag
            System.out.println("interrupted(): " + Thread.interrupted());
            System.out.println("interrupted() again: " + Thread.interrupted());
            System.out.println("isInterrupted() after interrupted(): " + Thread.currentThread().isInterrupted());
            
            System.out.println("Interrupted demo thread completed");
        }, "InterruptedDemoThread");
        
        interruptedDemoThread.start();
        
        try {
            interruptedDemoThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateSleepMethod() {
        System.out.println("\n=== sleep() Method ===");
        
        System.out.println("SLEEP METHOD PURPOSE:");
        System.out.println("1. Pause thread execution for specified time");
        System.out.println("2. Give other threads chance to execute");
        System.out.println("3. Simulate work or delays");
        System.out.println("4. Can be interrupted by other threads");
        
        // Basic sleep demonstration
        System.out.println("\n--- Basic sleep() Demonstration ---");
        
        Thread sleepThread = new Thread(() -> {
            System.out.println("Sleep thread started");
            
            try {
                System.out.println("Sleeping for 2 seconds...");
                Thread.sleep(2000);
                System.out.println("Sleep completed");
            } catch (InterruptedException e) {
                System.out.println("Sleep was interrupted");
                Thread.currentThread().interrupt();
            }
            
            System.out.println("Sleep thread completed");
        }, "SleepThread");
        
        sleepThread.start();
        
        try {
            Thread.sleep(1000); // Let thread start
            System.out.println("Main thread: Sleep thread is sleeping");
            sleepThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Sleep with interruption
        System.out.println("\n--- Sleep with Interruption ---");
        
        Thread interruptibleSleepThread = new Thread(() -> {
            System.out.println("Interruptible sleep thread started");
            
            try {
                System.out.println("Sleeping for 5 seconds...");
                Thread.sleep(5000);
                System.out.println("Sleep completed normally");
            } catch (InterruptedException e) {
                System.out.println("Sleep was interrupted after " + 
                                 (5000 - System.currentTimeMillis() % 5000) + " ms");
                Thread.currentThread().interrupt();
            }
            
            System.out.println("Interruptible sleep thread completed");
        }, "InterruptibleSleepThread");
        
        interruptibleSleepThread.start();
        
        try {
            Thread.sleep(2000); // Let thread sleep for 2 seconds
            System.out.println("Interrupting sleep thread...");
            interruptibleSleepThread.interrupt();
            interruptibleSleepThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Sleep vs busy waiting
        System.out.println("\n--- Sleep vs Busy Waiting ---");
        
        System.out.println("Sleep vs Busy Waiting:");
        System.out.println("- sleep(): Thread gives up CPU, other threads can run");
        System.out.println("- Busy waiting: Thread keeps CPU busy, wastes resources");
        
        Thread sleepDemoThread = new Thread(() -> {
            System.out.println("Sleep demo thread started");
            
            long startTime = System.currentTimeMillis();
            
            try {
                Thread.sleep(1000); // Sleep for 1 second
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            long endTime = System.currentTimeMillis();
            System.out.println("Sleep demo thread completed in " + (endTime - startTime) + " ms");
        }, "SleepDemoThread");
        
        Thread busyWaitThread = new Thread(() -> {
            System.out.println("Busy wait thread started");
            
            long startTime = System.currentTimeMillis();
            
            // Busy waiting (bad practice)
            while (System.currentTimeMillis() - startTime < 1000) {
                // Do nothing, just waste CPU
            }
            
            long endTime = System.currentTimeMillis();
            System.out.println("Busy wait thread completed in " + (endTime - startTime) + " ms");
        }, "BusyWaitThread");
        
        sleepDemoThread.start();
        busyWaitThread.start();
        
        try {
            sleepDemoThread.join();
            busyWaitThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateYieldMethod() {
        System.out.println("\n=== yield() Method ===");
        
        System.out.println("YIELD METHOD PURPOSE:");
        System.out.println("1. Hint to scheduler that current thread is willing to yield CPU");
        System.out.println("2. Give other threads chance to execute");
        System.out.println("3. Not guaranteed to work - scheduler may ignore");
        System.out.println("4. Should be used sparingly");
        
        // Basic yield demonstration
        System.out.println("\n--- Basic yield() Demonstration ---");
        
        Thread yieldThread = new Thread(() -> {
            System.out.println("Yield thread started");
            
            for (int i = 0; i < 5; i++) {
                System.out.println("Yield thread - Iteration: " + i);
                Thread.yield(); // Hint to scheduler
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("Yield thread completed");
        }, "YieldThread");
        
        Thread normalThread = new Thread(() -> {
            System.out.println("Normal thread started");
            
            for (int i = 0; i < 5; i++) {
                System.out.println("Normal thread - Iteration: " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("Normal thread completed");
        }, "NormalThread");
        
        yieldThread.start();
        normalThread.start();
        
        try {
            yieldThread.join();
            normalThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Yield effectiveness demonstration
        System.out.println("\n--- Yield Effectiveness Demonstration ---");
        
        System.out.println("Note: yield() effectiveness depends on:");
        System.out.println("1. Operating system scheduler");
        System.out.println("2. Number of CPU cores");
        System.out.println("3. Thread priorities");
        System.out.println("4. System load");
        
        Thread highPriorityThread = new Thread(() -> {
            Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
            System.out.println("High priority thread started");
            
            for (int i = 0; i < 3; i++) {
                System.out.println("High priority - Iteration: " + i);
                Thread.yield();
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("High priority thread completed");
        }, "HighPriorityThread");
        
        Thread lowPriorityThread = new Thread(() -> {
            Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
            System.out.println("Low priority thread started");
            
            for (int i = 0; i < 3; i++) {
                System.out.println("Low priority - Iteration: " + i);
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("Low priority thread completed");
        }, "LowPriorityThread");
        
        highPriorityThread.start();
        lowPriorityThread.start();
        
        try {
            highPriorityThread.join();
            lowPriorityThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateThreadStates() {
        System.out.println("\n=== Thread States Detail ===");
        
        System.out.println("DETAILED THREAD STATES:");
        
        // NEW state
        System.out.println("\n--- NEW State ---");
        Thread newThread = new Thread(() -> System.out.println("Running"));
        System.out.println("NEW thread state: " + newThread.getState());
        
        // RUNNABLE state
        System.out.println("\n--- RUNNABLE State ---");
        Thread runnableThread = new Thread(() -> {
            System.out.println("Thread is RUNNABLE: " + Thread.currentThread().getState());
            // Simulate some work
            for (int i = 0; i < 1000000; i++) {
                Math.random();
            }
        });
        runnableThread.start();
        
        try {
            Thread.sleep(50); // Give thread time to run
            System.out.println("Thread state while running: " + runnableThread.getState());
            runnableThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // BLOCKED state demonstration
        System.out.println("\n--- BLOCKED State ---");
        Object lock = new Object();
        
        Thread blockingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(2000); // Hold lock for 2 seconds
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Got the lock!");
            }
        });
        
        blockingThread.start();
        waitingThread.start();
        
        try {
            Thread.sleep(100); // Give threads time to start
            System.out.println("Waiting thread state: " + waitingThread.getState());
            blockingThread.join();
            waitingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // WAITING state demonstration
        System.out.println("\n--- WAITING State ---");
        Object waitLock = new Object();
        
        Thread waitingThread2 = new Thread(() -> {
            synchronized (waitLock) {
                try {
                    waitLock.wait(); // WAITING state
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        waitingThread2.start();
        
        try {
            Thread.sleep(100);
            System.out.println("Waiting thread state: " + waitingThread2.getState());
            
            synchronized (waitLock) {
                waitLock.notify();
            }
            
            waitingThread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // TIMED_WAITING state demonstration
        System.out.println("\n--- TIMED_WAITING State ---");
        Thread timedWaitingThread = new Thread(() -> {
            try {
                Thread.sleep(1000); // TIMED_WAITING state
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        timedWaitingThread.start();
        
        try {
            Thread.sleep(100);
            System.out.println("Timed waiting thread state: " + timedWaitingThread.getState());
            timedWaitingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // TERMINATED state
        System.out.println("\n--- TERMINATED State ---");
        System.out.println("Terminated thread state: " + timedWaitingThread.getState());
    }
    
    static void demonstrateSynchronizationControl() {
        System.out.println("\n=== Synchronization Control ===");
        
        System.out.println("SYNCHRONIZATION CONTROL MECHANISMS:");
        System.out.println("1. synchronized methods and blocks");
        System.out.println("2. wait(), notify(), notifyAll()");
        System.out.println("3. ReentrantLock and other locks");
        System.out.println("4. Atomic variables");
        System.out.println("5. Volatile keyword");
        
        // Synchronized method demonstration
        System.out.println("\n--- Synchronized Method Demonstration ---");
        
        SynchronizedCounter counter = new SynchronizedCounter();
        
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    counter.increment();
                    System.out.println("Thread " + Thread.currentThread().getName() + 
                                     " - Count: " + counter.getCount());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "SyncThread-" + (i + 1));
            threads[i].start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final counter value: " + counter.getCount());
        
        // Wait/Notify demonstration
        System.out.println("\n--- Wait/Notify Demonstration ---");
        
        MessageQueue queue = new MessageQueue();
        
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 3; i++) {
                queue.put("Message " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }, "Producer");
        
        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 3; i++) {
                String message = queue.get();
                System.out.println("Consumed: " + message);
            }
        }, "Consumer");
        
        consumer.start();
        producer.start();
        
        try {
            producer.join();
            consumer.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateThreadCommunication() {
        System.out.println("\n=== Thread Communication ===");
        
        System.out.println("THREAD COMMUNICATION MECHANISMS:");
        System.out.println("1. Shared variables (with proper synchronization)");
        System.out.println("2. wait(), notify(), notifyAll()");
        System.out.println("3. BlockingQueue and other concurrent collections");
        System.out.println("4. CountDownLatch, CyclicBarrier, Semaphore");
        System.out.println("5. Exchanger for data exchange");
        
        // CountDownLatch demonstration
        System.out.println("\n--- CountDownLatch Demonstration ---");
        
        CountDownLatch latch = new CountDownLatch(3);
        
        Thread[] workers = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int workerId = i + 1;
            workers[i] = new Thread(() -> {
                System.out.println("Worker " + workerId + " started");
                try {
                    Thread.sleep(1000 + workerId * 500); // Different work times
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Worker " + workerId + " completed");
                latch.countDown(); // Signal completion
            }, "Worker-" + workerId);
            workers[i].start();
        }
        
        try {
            System.out.println("Main thread waiting for all workers...");
            latch.await(); // Wait for all workers to complete
            System.out.println("All workers completed, main thread continuing");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Semaphore demonstration
        System.out.println("\n--- Semaphore Demonstration ---");
        
        Semaphore semaphore = new Semaphore(2); // Allow 2 concurrent accesses
        
        Thread[] semaphoreThreads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            final int threadId = i + 1;
            semaphoreThreads[i] = new Thread(() -> {
                try {
                    System.out.println("Thread " + threadId + " requesting semaphore");
                    semaphore.acquire(); // Acquire permit
                    System.out.println("Thread " + threadId + " acquired semaphore");
                    
                    Thread.sleep(1000); // Simulate work
                    
                    System.out.println("Thread " + threadId + " releasing semaphore");
                    semaphore.release(); // Release permit
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "SemaphoreThread-" + threadId);
            semaphoreThreads[i].start();
        }
        
        // Wait for all semaphore threads to complete
        for (Thread thread : semaphoreThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    static void demonstrateBestPractices() {
        System.out.println("\n=== Best Practices ===");
        
        System.out.println("BEST PRACTICES FOR THREAD CONTROL:");
        System.out.println("1. Always call start() method, never run() directly");
        System.out.println("2. Handle InterruptedException properly");
        System.out.println("3. Use join() to wait for thread completion");
        System.out.println("4. Use interrupt() to stop threads gracefully");
        System.out.println("5. Avoid busy waiting - use sleep() or wait()");
        System.out.println("6. Use proper synchronization for shared data");
        System.out.println("7. Clean up resources in finally blocks");
        System.out.println("8. Use modern concurrency utilities when possible");
        
        // Demonstrate best practices
        System.out.println("\n--- Best Practices Example ---");
        
        BestPracticesThread bestThread = new BestPracticesThread("BestPractices");
        bestThread.start();
        
        try {
            Thread.sleep(2000); // Let thread run for a bit
            bestThread.interrupt(); // Demonstrate interruption
            bestThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Best practices demonstration completed");
    }
}

// ========== HELPER CLASSES ==========

/**
 * Synchronized counter class
 */
class SynchronizedCounter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}

/**
 * Message queue for wait/notify demonstration
 */
class MessageQueue {
    private String message;
    private boolean hasMessage = false;
    
    public synchronized void put(String message) {
        while (hasMessage) {
            try {
                wait(); // Wait for consumer to consume
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
        }
        
        this.message = message;
        hasMessage = true;
        notify(); // Notify consumer
        System.out.println("Produced: " + message);
    }
    
    public synchronized String get() {
        while (!hasMessage) {
            try {
                wait(); // Wait for producer to produce
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return null;
            }
        }
        
        String message = this.message;
        hasMessage = false;
        notify(); // Notify producer
        return message;
    }
}

/**
 * Thread demonstrating best practices
 */
class BestPracticesThread extends Thread {
    private volatile boolean shouldStop = false;
    
    public BestPracticesThread(String name) {
        super(name);
    }
    
    @Override
    public void run() {
        System.out.println("BestPracticesThread " + getName() + " started");
        
        try {
            // Best practice: Check interruption status
            while (!shouldStop && !Thread.currentThread().isInterrupted()) {
                System.out.println(getName() + " - Working...");
                
                // Best practice: Handle InterruptedException properly
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    System.out.println(getName() + " - Interrupted during sleep");
                    Thread.currentThread().interrupt(); // Restore interrupt status
                    break;
                }
                
                // Simulate some work
                doWork();
            }
        } finally {
            // Best practice: Clean up resources
            cleanup();
        }
        
        System.out.println("BestPracticesThread " + getName() + " completed");
    }
    
    private void doWork() {
        // Simulate work
        for (int i = 0; i < 100000; i++) {
            Math.random();
        }
    }
    
    private void cleanup() {
        System.out.println(getName() + " - Cleaning up resources");
    }
    
    public void requestStop() {
        shouldStop = true;
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Always call start() method, never run() directly for new thread execution
- Handle InterruptedException properly by restoring interrupt status
- Use join() to wait for thread completion
- Use interrupt() to stop threads gracefully
- Use proper synchronization for shared data

**Don'ts:**
- Don't call run() method directly when you want a new thread
- Don't ignore InterruptedException
- Don't start a thread multiple times
- Don't use busy waiting - use sleep() or wait()
- Don't rely on thread priorities for critical functionality

**Common Pitfalls:**
- Calling run() instead of start() method
- Starting a thread multiple times (IllegalThreadStateException)
- Not handling InterruptedException properly
- Race conditions when accessing shared data
- Deadlocks when using multiple locks

## 5. Summary

- **Thread Control** includes methods like start(), run(), join(), interrupt(), sleep(), yield()
- **start() vs run()**: start() creates new thread, run() executes in current thread
- **join()** method waits for thread completion and can have timeout
- **interrupt()** mechanism allows graceful thread termination
- **sleep()** pauses thread execution and can be interrupted
- **yield()** hints to scheduler to yield CPU (not guaranteed)
- **Thread States**: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
- **Synchronization** controls access to shared resources
- **Thread Communication** uses wait/notify, concurrent collections, and synchronization utilities

## 6. Tricky Interview Questions

1. **Thread Control**: What are the different ways to control thread execution in Java? Explain each method.

2. **start() vs run()**: What is the difference between start() and run() method of Thread class? What happens if you call run() directly?

3. **Thread States**: What are the different states of a thread? How does a thread transition between states?

4. **Interrupt Mechanism**: How does thread interruption work in Java? What is the difference between interrupt() and isInterrupted()?

5. **join() Method**: What is the purpose of join() method? How do you use join() with timeout?

6. **Thread Communication**: What are the different ways threads can communicate with each other? Give examples.

7. **Synchronization**: What are the different synchronization mechanisms in Java? When would you use each?

8. **Thread Lifecycle**: How do you manage thread lifecycle? What are the best practices?

9. **Exception Handling**: How do you handle InterruptedException? Why is it important?

10. **Thread Safety**: How do you ensure thread safety when multiple threads access shared data?

11. **Modern Concurrency**: How do modern Java concurrency utilities compare to traditional thread control methods?

12. **Performance**: What are the performance implications of different thread control mechanisms?
