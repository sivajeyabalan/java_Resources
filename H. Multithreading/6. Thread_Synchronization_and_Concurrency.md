## 1. Topic Overview

Thread synchronization in Java is the mechanism that ensures multiple threads can safely access shared resources without causing data corruption, race conditions, or inconsistent states. Synchronization is essential for thread safety and is achieved through various mechanisms including synchronized methods, synchronized blocks, locks, and atomic variables. Understanding synchronization is crucial for building robust multithreaded applications that can handle concurrent access to shared data safely and efficiently.

## 2. Topic Definition

- **What**: Mechanisms that coordinate access to shared resources among multiple threads to prevent race conditions and ensure data consistency
- **Why**: Prevent data corruption, avoid race conditions, ensure thread safety, maintain data integrity in concurrent environments
- **How**: Through synchronized methods/blocks, locks, atomic variables, volatile keyword, and concurrent collections
- **When/Where**: When multiple threads access shared data, concurrent programming, critical sections, shared resources
- **What If**:
  - Without synchronization: Race conditions, data corruption, inconsistent state, unpredictable behavior
  - With synchronization: Thread-safe access, data consistency, predictable behavior, coordinated execution
  - Improper synchronization: Deadlocks, performance issues, thread starvation
- **Examples**:
  - Synchronized method: `public synchronized void method() { ... }`
  - Synchronized block: `synchronized(object) { ... }`
  - Lock: `lock.lock(); try { ... } finally { lock.unlock(); }`

## 3. Deep Dive with Examples

```java
// File: ThreadSynchronizationDemo.java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Comprehensive demonstration of thread synchronization and concurrency
 */
public class ThreadSynchronizationDemo {
    
    public static void main(String[] args) {
        demonstrateRaceConditions();
        demonstrateSynchronizedMethods();
        demonstrateSynchronizedBlocks();
        demonstrateLocks();
        demonstrateAtomicVariables();
        demonstrateVolatileKeyword();
        demonstrateWaitNotify();
        demonstrateDeadlocks();
        demonstrateConcurrentCollections();
        demonstrateBestPractices();
    }
    
    static void demonstrateRaceConditions() {
        System.out.println("=== Race Conditions ===");
        
        System.out.println("RACE CONDITIONS:");
        System.out.println("1. Occur when multiple threads access shared data simultaneously");
        System.out.println("2. Can cause data corruption and inconsistent state");
        System.out.println("3. Result from lack of proper synchronization");
        System.out.println("4. Can lead to unpredictable program behavior");
        
        // Demonstrate race condition
        System.out.println("\n--- Race Condition Demonstration ---");
        
        UnsafeCounter unsafeCounter = new UnsafeCounter();
        
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    unsafeCounter.increment();
                }
            }, "UnsafeThread-" + (i + 1));
        }
        
        // Start all threads
        for (Thread thread : threads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Expected count: 5000");
        System.out.println("Actual count: " + unsafeCounter.getCount());
        System.out.println("Race condition occurred: " + (unsafeCounter.getCount() != 5000));
        
        // Demonstrate thread-safe counter
        System.out.println("\n--- Thread-Safe Counter Demonstration ---");
        
        SafeCounter safeCounter = new SafeCounter();
        
        Thread[] safeThreads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            safeThreads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    safeCounter.increment();
                }
            }, "SafeThread-" + (i + 1));
        }
        
        // Start all threads
        for (Thread thread : safeThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : safeThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Expected count: 5000");
        System.out.println("Actual count: " + safeCounter.getCount());
        System.out.println("Thread safety maintained: " + (safeCounter.getCount() == 5000));
    }
    
    static void demonstrateSynchronizedMethods() {
        System.out.println("\n=== Synchronized Methods ===");
        
        System.out.println("SYNCHRONIZED METHODS:");
        System.out.println("1. Synchronize entire method execution");
        System.out.println("2. Use object's intrinsic lock (monitor)");
        System.out.println("3. Only one thread can execute synchronized method at a time");
        System.out.println("4. Simple but can impact performance");
        
        // Demonstrate synchronized methods
        System.out.println("\n--- Synchronized Methods Demonstration ---");
        
        SynchronizedCounter syncCounter = new SynchronizedCounter();
        
        Thread[] threads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    syncCounter.increment();
                    System.out.println("Thread " + threadId + " - Count: " + syncCounter.getCount());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "SyncMethodThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : threads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final count: " + syncCounter.getCount());
        
        // Demonstrate static synchronized methods
        System.out.println("\n--- Static Synchronized Methods ---");
        
        Thread[] staticThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            staticThreads[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    SynchronizedCounter.incrementStatic();
                    System.out.println("Thread " + threadId + " - Static Count: " + 
                                     SynchronizedCounter.getStaticCount());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "StaticSyncThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : staticThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : staticThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final static count: " + SynchronizedCounter.getStaticCount());
    }
    
    static void demonstrateSynchronizedBlocks() {
        System.out.println("\n=== Synchronized Blocks ===");
        
        System.out.println("SYNCHRONIZED BLOCKS:");
        System.out.println("1. Synchronize specific code sections");
        System.out.println("2. More flexible than synchronized methods");
        System.out.println("3. Can use different objects as locks");
        System.out.println("4. Better performance than synchronized methods");
        
        // Demonstrate synchronized blocks
        System.out.println("\n--- Synchronized Blocks Demonstration ---");
        
        BlockSynchronizedCounter blockCounter = new BlockSynchronizedCounter();
        
        Thread[] threads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    blockCounter.increment();
                    System.out.println("Thread " + threadId + " - Count: " + blockCounter.getCount());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "BlockSyncThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : threads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final count: " + blockCounter.getCount());
        
        // Demonstrate different lock objects
        System.out.println("\n--- Different Lock Objects ---");
        
        Object lock1 = new Object();
        Object lock2 = new Object();
        
        Thread[] lockThreads = new Thread[4];
        for (int i = 0; i < 4; i++) {
            final int threadId = i + 1;
            final Object lock = (i % 2 == 0) ? lock1 : lock2;
            lockThreads[i] = new Thread(() -> {
                synchronized (lock) {
                    System.out.println("Thread " + threadId + " acquired lock: " + lock);
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    System.out.println("Thread " + threadId + " releasing lock: " + lock);
                }
            }, "LockThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : lockThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : lockThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    static void demonstrateLocks() {
        System.out.println("\n=== Locks ===");
        
        System.out.println("LOCKS:");
        System.out.println("1. ReentrantLock - Reentrant mutual exclusion lock");
        System.out.println("2. ReadWriteLock - Allows multiple readers or one writer");
        System.out.println("3. StampedLock - Optimistic locking with version stamps");
        System.out.println("4. More flexible than synchronized methods/blocks");
        
        // Demonstrate ReentrantLock
        System.out.println("\n--- ReentrantLock Demonstration ---");
        
        LockCounter lockCounter = new LockCounter();
        
        Thread[] lockThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            lockThreads[i] = new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    lockCounter.increment();
                    System.out.println("Thread " + threadId + " - Count: " + lockCounter.getCount());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "LockThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : lockThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : lockThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final count: " + lockCounter.getCount());
        
        // Demonstrate ReadWriteLock
        System.out.println("\n--- ReadWriteLock Demonstration ---");
        
        ReadWriteLockCounter rwCounter = new ReadWriteLockCounter();
        
        // Create reader threads
        Thread[] readerThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int readerId = i + 1;
            readerThreads[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    int value = rwCounter.getCount();
                    System.out.println("Reader " + readerId + " - Count: " + value);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "ReaderThread-" + readerId);
        }
        
        // Create writer threads
        Thread[] writerThreads = new Thread[2];
        for (int i = 0; i < 2; i++) {
            final int writerId = i + 1;
            writerThreads[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    rwCounter.increment();
                    System.out.println("Writer " + writerId + " - Count: " + rwCounter.getCount());
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "WriterThread-" + writerId);
        }
        
        // Start all threads
        for (Thread thread : readerThreads) {
            thread.start();
        }
        for (Thread thread : writerThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : readerThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        for (Thread thread : writerThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final count: " + rwCounter.getCount());
    }
    
    static void demonstrateAtomicVariables() {
        System.out.println("\n=== Atomic Variables ===");
        
        System.out.println("ATOMIC VARIABLES:");
        System.out.println("1. Thread-safe operations without explicit locking");
        System.out.println("2. Use compare-and-swap (CAS) operations");
        System.out.println("3. Better performance than synchronized methods");
        System.out.println("4. Available for primitive types and references");
        
        // Demonstrate AtomicInteger
        System.out.println("\n--- AtomicInteger Demonstration ---");
        
        AtomicCounter atomicCounter = new AtomicCounter();
        
        Thread[] atomicThreads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            atomicThreads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    atomicCounter.increment();
                }
            }, "AtomicThread-" + (i + 1));
        }
        
        // Start all threads
        for (Thread thread : atomicThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : atomicThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Expected count: 5000");
        System.out.println("Actual count: " + atomicCounter.getCount());
        System.out.println("Atomic operations successful: " + (atomicCounter.getCount() == 5000));
        
        // Demonstrate atomic operations
        System.out.println("\n--- Atomic Operations Demonstration ---");
        
        AtomicInteger atomicInt = new AtomicInteger(0);
        
        Thread[] operationThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            operationThreads[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    int oldValue = atomicInt.get();
                    int newValue = atomicInt.incrementAndGet();
                    System.out.println("Thread " + threadId + " - Old: " + oldValue + ", New: " + newValue);
                    
                    // Demonstrate compareAndSet
                    boolean success = atomicInt.compareAndSet(newValue, newValue + 10);
                    System.out.println("Thread " + threadId + " - CAS success: " + success + 
                                     ", Value: " + atomicInt.get());
                    
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "OperationThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : operationThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : operationThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final atomic value: " + atomicInt.get());
    }
    
    static void demonstrateVolatileKeyword() {
        System.out.println("\n=== Volatile Keyword ===");
        
        System.out.println("VOLATILE KEYWORD:");
        System.out.println("1. Ensures visibility of variable changes across threads");
        System.out.println("2. Prevents compiler optimizations that could cause issues");
        System.out.println("3. Not suitable for compound operations");
        System.out.println("4. Useful for simple flags and status variables");
        
        // Demonstrate volatile keyword
        System.out.println("\n--- Volatile Keyword Demonstration ---");
        
        VolatileCounter volatileCounter = new VolatileCounter();
        
        Thread[] volatileThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            volatileThreads[i] = new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    volatileCounter.increment();
                    System.out.println("Thread " + threadId + " - Count: " + volatileCounter.getCount());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "VolatileThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : volatileThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : volatileThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final count: " + volatileCounter.getCount());
        System.out.println("Note: Volatile alone is not sufficient for compound operations");
        
        // Demonstrate volatile flag
        System.out.println("\n--- Volatile Flag Demonstration ---");
        
        VolatileFlag flag = new VolatileFlag();
        
        Thread flagThread = new Thread(() -> {
            System.out.println("Flag thread started");
            while (!flag.isSet()) {
                // Do some work
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            System.out.println("Flag thread detected flag change");
        }, "FlagThread");
        
        flagThread.start();
        
        try {
            Thread.sleep(1000); // Let flag thread run
            System.out.println("Setting flag...");
            flag.set();
            flagThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateWaitNotify() {
        System.out.println("\n=== Wait/Notify ===");
        
        System.out.println("WAIT/NOTIFY MECHANISM:");
        System.out.println("1. wait() - Thread waits until notified");
        System.out.println("2. notify() - Wakes up one waiting thread");
        System.out.println("3. notifyAll() - Wakes up all waiting threads");
        System.out.println("4. Must be called within synchronized context");
        
        // Demonstrate wait/notify
        System.out.println("\n--- Wait/Notify Demonstration ---");
        
        MessageQueue queue = new MessageQueue();
        
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                queue.put("Message " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }, "Producer");
        
        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                String message = queue.get();
                System.out.println("Consumed: " + message);
            }
        }, "Consumer");
        
        consumer.start();
        producer.start();
        
        try {
            producer.join();
            consumer.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate notifyAll
        System.out.println("\n--- NotifyAll Demonstration ---");
        
        NotifyAllDemo notifyDemo = new NotifyAllDemo();
        
        Thread[] waitingThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            waitingThreads[i] = new Thread(() -> {
                notifyDemo.waitForSignal();
                System.out.println("Thread " + threadId + " received signal");
            }, "WaitingThread-" + threadId);
        }
        
        // Start waiting threads
        for (Thread thread : waitingThreads) {
            thread.start();
        }
        
        try {
            Thread.sleep(1000); // Let threads start and wait
            System.out.println("Notifying all waiting threads...");
            notifyDemo.notifyAllThreads();
            
            // Wait for all threads to complete
            for (Thread thread : waitingThreads) {
                thread.join();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateDeadlocks() {
        System.out.println("\n=== Deadlocks ===");
        
        System.out.println("DEADLOCKS:");
        System.out.println("1. Occur when threads wait for each other indefinitely");
        System.out.println("2. Usually caused by circular wait conditions");
        System.out.println("3. Can be prevented by proper lock ordering");
        System.out.println("4. Difficult to detect and debug");
        
        // Demonstrate deadlock
        System.out.println("\n--- Deadlock Demonstration ---");
        
        Object lock1 = new Object();
        Object lock2 = new Object();
        
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1 acquired lock1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                synchronized (lock2) {
                    System.out.println("Thread 1 acquired lock2");
                }
            }
        }, "DeadlockThread1");
        
        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread 2 acquired lock2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                synchronized (lock1) {
                    System.out.println("Thread 2 acquired lock1");
                }
            }
        }, "DeadlockThread2");
        
        thread1.start();
        thread2.start();
        
        try {
            Thread.sleep(2000); // Let threads run
            System.out.println("Checking for deadlock...");
            System.out.println("Thread 1 alive: " + thread1.isAlive());
            System.out.println("Thread 2 alive: " + thread2.isAlive());
            
            if (thread1.isAlive() || thread2.isAlive()) {
                System.out.println("Deadlock detected! Interrupting threads...");
                thread1.interrupt();
                thread2.interrupt();
            }
            
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate deadlock prevention
        System.out.println("\n--- Deadlock Prevention ---");
        
        System.out.println("Deadlock prevention strategies:");
        System.out.println("1. Lock ordering - always acquire locks in same order");
        System.out.println("2. Lock timeout - use tryLock with timeout");
        System.out.println("3. Avoid nested locks when possible");
        System.out.println("4. Use higher-level concurrency utilities");
        
        DeadlockPreventionDemo preventionDemo = new DeadlockPreventionDemo();
        
        Thread[] preventionThreads = new Thread[2];
        for (int i = 0; i < 2; i++) {
            final int threadId = i + 1;
            preventionThreads[i] = new Thread(() -> {
                preventionDemo.safeOperation(threadId);
            }, "PreventionThread-" + threadId);
        }
        
        // Start threads
        for (Thread thread : preventionThreads) {
            thread.start();
        }
        
        // Wait for completion
        for (Thread thread : preventionThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Deadlock prevention demonstration completed");
    }
    
    static void demonstrateConcurrentCollections() {
        System.out.println("\n=== Concurrent Collections ===");
        
        System.out.println("CONCURRENT COLLECTIONS:");
        System.out.println("1. Thread-safe collections without explicit synchronization");
        System.out.println("2. Better performance than synchronized collections");
        System.out.println("3. Designed for concurrent access");
        System.out.println("4. Examples: ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue");
        
        // Demonstrate ConcurrentHashMap
        System.out.println("\n--- ConcurrentHashMap Demonstration ---");
        
        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        
        Thread[] mapThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            mapThreads[i] = new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    String key = "key" + j;
                    concurrentMap.put(key, threadId * 100 + j);
                    System.out.println("Thread " + threadId + " - Put: " + key + " = " + 
                                     concurrentMap.get(key));
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "MapThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : mapThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : mapThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final map size: " + concurrentMap.size());
        System.out.println("Map contents: " + concurrentMap);
        
        // Demonstrate BlockingQueue
        System.out.println("\n--- BlockingQueue Demonstration ---");
        
        BlockingQueue<String> queue = new LinkedBlockingQueue<>();
        
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    queue.put("Item " + i);
                    System.out.println("Produced: Item " + i);
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }, "Producer");
        
        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    String item = queue.take();
                    System.out.println("Consumed: " + item);
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }, "Consumer");
        
        producer.start();
        consumer.start();
        
        try {
            producer.join();
            consumer.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateBestPractices() {
        System.out.println("\n=== Best Practices ===");
        
        System.out.println("BEST PRACTICES FOR THREAD SYNCHRONIZATION:");
        System.out.println("1. Use synchronized methods/blocks for simple cases");
        System.out.println("2. Use locks for more complex synchronization needs");
        System.out.println("3. Use atomic variables for simple operations");
        System.out.println("4. Use concurrent collections when possible");
        System.out.println("5. Avoid nested locks to prevent deadlocks");
        System.out.println("6. Use proper lock ordering");
        System.out.println("7. Keep synchronized blocks small");
        System.out.println("8. Use volatile for simple flags");
        
        // Demonstrate best practices
        System.out.println("\n--- Best Practices Example ---");
        
        BestPracticesDemo bestDemo = new BestPracticesDemo();
        
        Thread[] bestThreads = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            bestThreads[i] = new Thread(() -> {
                bestDemo.performOperation(threadId);
            }, "BestThread-" + threadId);
        }
        
        // Start all threads
        for (Thread thread : bestThreads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : bestThreads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Best practices demonstration completed");
    }
}

// ========== HELPER CLASSES ==========

/**
 * Unsafe counter demonstrating race conditions
 */
class UnsafeCounter {
    private int count = 0;
    
    public void increment() {
        count++; // Not thread-safe
    }
    
    public int getCount() {
        return count;
    }
}

/**
 * Safe counter using synchronized methods
 */
class SafeCounter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}

/**
 * Synchronized counter with static methods
 */
class SynchronizedCounter {
    private int count = 0;
    private static int staticCount = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
    
    public static synchronized void incrementStatic() {
        staticCount++;
    }
    
    public static synchronized int getStaticCount() {
        return staticCount;
    }
}

/**
 * Counter using synchronized blocks
 */
class BlockSynchronizedCounter {
    private int count = 0;
    private final Object lock = new Object();
    
    public void increment() {
        synchronized (lock) {
            count++;
        }
    }
    
    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }
}

/**
 * Counter using ReentrantLock
 */
class LockCounter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();
    
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
    
    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}

/**
 * Counter using ReadWriteLock
 */
class ReadWriteLockCounter {
    private int count = 0;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public void increment() {
        lock.writeLock().lock();
        try {
            count++;
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int getCount() {
        lock.readLock().lock();
        try {
            return count;
        } finally {
            lock.readLock().unlock();
        }
    }
}

/**
 * Counter using AtomicInteger
 */
class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();
    }
    
    public int getCount() {
        return count.get();
    }
}

/**
 * Counter using volatile keyword
 */
class VolatileCounter {
    private volatile int count = 0;
    
    public void increment() {
        count++; // Not thread-safe for compound operations
    }
    
    public int getCount() {
        return count;
    }
}

/**
 * Volatile flag demonstration
 */
class VolatileFlag {
    private volatile boolean flag = false;
    
    public void set() {
        flag = true;
    }
    
    public boolean isSet() {
        return flag;
    }
}

/**
 * Message queue for wait/notify demonstration
 */
class MessageQueue {
    private String message;
    private boolean hasMessage = false;
    
    public synchronized void put(String message) {
        while (hasMessage) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
        }
        
        this.message = message;
        hasMessage = true;
        notify();
        System.out.println("Produced: " + message);
    }
    
    public synchronized String get() {
        while (!hasMessage) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return null;
            }
        }
        
        String message = this.message;
        hasMessage = false;
        notify();
        return message;
    }
}

/**
 * NotifyAll demonstration
 */
class NotifyAllDemo {
    private boolean signal = false;
    
    public synchronized void waitForSignal() {
        while (!signal) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    public synchronized void notifyAllThreads() {
        signal = true;
        notifyAll();
    }
}

/**
 * Deadlock prevention demonstration
 */
class DeadlockPreventionDemo {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void safeOperation(int threadId) {
        // Always acquire locks in same order to prevent deadlock
        synchronized (lock1) {
            System.out.println("Thread " + threadId + " acquired lock1");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            synchronized (lock2) {
                System.out.println("Thread " + threadId + " acquired lock2");
                System.out.println("Thread " + threadId + " performing safe operation");
            }
        }
        System.out.println("Thread " + threadId + " completed safe operation");
    }
}

/**
 * Best practices demonstration
 */
class BestPracticesDemo {
    private final AtomicInteger counter = new AtomicInteger(0);
    private final ReentrantLock lock = new ReentrantLock();
    
    public void performOperation(int threadId) {
        // Use atomic operations for simple increments
        int count = counter.incrementAndGet();
        System.out.println("Thread " + threadId + " - Atomic count: " + count);
        
        // Use locks for complex operations
        lock.lock();
        try {
            System.out.println("Thread " + threadId + " performing complex operation");
            Thread.sleep(100); // Simulate work
            System.out.println("Thread " + threadId + " completed complex operation");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use synchronized methods/blocks for simple synchronization needs
- Use locks for more complex synchronization requirements
- Use atomic variables for simple operations
- Use concurrent collections when possible
- Keep synchronized blocks small and focused

**Don'ts:**
- Don't rely on volatile for compound operations
- Don't use nested locks without proper ordering
- Don't ignore InterruptedException
- Don't use synchronized collections when concurrent collections are available
- Don't create unnecessary synchronization

**Common Pitfalls:**
- Race conditions when accessing shared data without synchronization
- Deadlocks from improper lock ordering
- Performance issues from excessive synchronization
- Thread starvation from improper lock usage
- Data corruption from insufficient synchronization

## 5. Summary

- **Thread Synchronization** ensures safe access to shared resources among multiple threads
- **Synchronized Methods/Blocks** provide basic synchronization using object monitors
- **Locks** offer more flexible synchronization with ReentrantLock, ReadWriteLock
- **Atomic Variables** provide thread-safe operations without explicit locking
- **Volatile Keyword** ensures visibility of variable changes across threads
- **Wait/Notify** mechanism enables thread communication and coordination
- **Deadlocks** occur when threads wait for each other indefinitely
- **Concurrent Collections** provide thread-safe collections without explicit synchronization

## 6. Tricky Interview Questions

1. **Synchronization Basics**: What is thread synchronization? Why is it necessary in multithreaded applications?

2. **Synchronized Methods**: What are synchronized methods? How do they work? What are their limitations?

3. **Synchronized Blocks**: What are synchronized blocks? How do they differ from synchronized methods?

4. **Locks vs Synchronized**: What are the differences between locks and synchronized methods/blocks? When would you use each?

5. **Atomic Variables**: What are atomic variables? How do they provide thread safety? Give examples.

6. **Volatile Keyword**: What does the volatile keyword do? When should you use it? What are its limitations?

7. **Wait/Notify**: How do wait() and notify() methods work? What are the requirements for using them?

8. **Deadlocks**: What are deadlocks? How can they be prevented? Give examples of deadlock scenarios.

9. **Race Conditions**: What are race conditions? How do you prevent them? Give examples.

10. **Concurrent Collections**: What are concurrent collections? How do they differ from synchronized collections?

11. **Performance**: What are the performance implications of different synchronization mechanisms?

12. **Best Practices**: What are the best practices for thread synchronization? What should you avoid?
