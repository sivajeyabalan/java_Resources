## 1. Topic Overview

- Thread communication lets threads coordinate work without busy waiting. In Java, `wait()`, `notify()`, and `notifyAll()` enable threads to pause and resume based on shared state changes. They must be used with intrinsic locks (synchronized).

## 2 . Topic definition

- WHAT: `wait()` releases the monitor and suspends the current thread until `notify()`/`notifyAll()` or interrupt; `notify()` wakes one waiting thread; `notifyAll()` wakes all.
- WHY: Avoid CPU-wasting loops and ensure correct ordering (producer-consumer, hand-off).
- HOW: Call inside a synchronized block on the same monitor; always guard with a condition loop.
- WHEN/WHERE: Use for simple coordination on an intrinsic lock; prefer higher-level utilities (queues, latches) when possible.
- WHAT IF: Misusing (calling without monitor, using if instead of while) causes `IllegalMonitorStateException` or subtle bugs like lost notifications/spurious wakeups.
- EXAMPLES: Producer-consumer with a bounded buffer.

## 3. Deep Dive with Examples

```java
import java.util.LinkedList;
import java.util.Queue;

public class BoundedBuffer<T> {
    private final Queue<T> queue = new LinkedList<>();
    private final int capacity;

    public BoundedBuffer(int capacity) {
        this.capacity = capacity;
    }

    public void put(T item) throws InterruptedException {
        synchronized (this) {
            while (queue.size() == capacity) {
                wait(); // releases monitor and suspends
            }
            queue.add(item);
            notifyAll(); // signal consumers
        }
    }

    public T take() throws InterruptedException {
        synchronized (this) {
            while (queue.isEmpty()) {
                wait();
            }
            T item = queue.remove();
            notifyAll(); // signal producers
            return item;
        }
    }

    public static void main(String[] args) {
        BoundedBuffer<Integer> buffer = new BoundedBuffer<>(2);

        Runnable producer = () -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    buffer.put(i);
                    System.out.println("Produced " + i);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        };

        Runnable consumer = () -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    Integer v = buffer.take();
                    System.out.println("Consumed " + v);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        };

        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```

- Spurious wakeups: Always check conditions in a `while`, not `if`.

```java
// BAD: may proceed when condition no longer holds
synchronized (lock) {
    if (!condition) {
        lock.wait();
    }
    // ...
}

// GOOD: re-check on wakeup
synchronized (lock) {
    while (!condition) {
        lock.wait();
    }
    // ...
}
```

## 4. Best Practices & Pitfalls

- Do use `while` loops around `wait()` to handle spurious wakeups and recheck conditions.
- Do call `wait/notify` only while holding the same object's monitor.
- Prefer `notifyAll()` unless you can prove `notify()` is safe.
- Prefer higher-level concurrency utilities (`BlockingQueue`) for producer-consumer.
- Donâ€™t hold unrelated locks while waiting; avoid nested locks to reduce deadlock risk.

## 5. Summary

- `wait/notify` provide low-level coordination on intrinsic locks.
- Always synchronize on the same monitor and guard with `while`.
- Prefer `notifyAll()` and higher-level constructs when available.

## 6. Tricky Interview Questions

1. Why must `wait()`/`notify()` be called inside a synchronized block on the same monitor?
2. Explain spurious wakeups. How do you code defensively against them?
3. When is `notify()` insufficient and `notifyAll()` required? Give scenarios.
4. Can `wait()` cause deadlock? Under what conditions?
5. What happens if you call `wait()` without owning the monitor?
6. Show a bug from using `if` instead of `while` around `wait()`.
7. How would you convert a `wait/notify` solution to use `BlockingQueue`?

