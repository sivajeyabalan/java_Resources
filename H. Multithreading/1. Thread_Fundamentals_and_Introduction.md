## 1. Topic Overview

A thread in Java is the smallest unit of execution within a process. It represents a single path of execution that can run concurrently with other threads. Java's multithreading model allows multiple threads to execute simultaneously, enabling programs to perform multiple tasks concurrently, improve performance, and create responsive applications. Understanding threads is fundamental to Java programming as it enables developers to build efficient, scalable applications that can handle multiple operations simultaneously.

## 2. Topic Definition

- **What**: A thread is a lightweight subprocess that represents an independent path of execution within a Java program
- **Why**: Enables concurrent execution, improves application responsiveness, utilizes multiple CPU cores, handles multiple tasks simultaneously
- **How**: Through Thread class, Runnable interface, or modern concurrency utilities; managed by JVM thread scheduler
- **When/Where**: GUI applications, server applications, data processing, I/O operations, parallel computations, responsive user interfaces
- **What If**:
  - Without threads: Sequential execution, poor performance, unresponsive applications
  - Multiple threads: Concurrent execution, better resource utilization, improved user experience
  - Thread safety issues: Data corruption, race conditions, inconsistent state
- **Examples**:
  - GUI thread: `SwingUtilities.invokeLater(() -> updateUI())`
  - Background task: `new Thread(() -> processData()).start()`
  - Server handling: Multiple threads handling different client requests

## 3. Deep Dive with Examples

```java
// File: ThreadFundamentalsDemo.java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Comprehensive demonstration of Thread fundamentals and multithreading concepts
 */
public class ThreadFundamentalsDemo {
    
    // ========== BASIC THREAD CONCEPTS ==========
    
    public static void main(String[] args) {
        demonstrateThreadBasics();
        demonstrateThreadVsProcess();
        demonstrateMultithreadingModel();
        demonstrateThreadCreationMethods();
        demonstrateThreadLifecycle();
        demonstrateThreadStates();
        demonstrateThreadControl();
    }
    
    static void demonstrateThreadBasics() {
        System.out.println("=== Thread Fundamentals ===");
        
        System.out.println("THREAD CHARACTERISTICS:");
        System.out.println("1. Lightweight subprocess");
        System.out.println("2. Independent path of execution");
        System.out.println("3. Shares memory space with other threads in same process");
        System.out.println("4. Managed by JVM thread scheduler");
        System.out.println("5. Can run concurrently with other threads");
        
        // What is Thread in Java?
        System.out.println("\n--- What is Thread in Java? ---");
        System.out.println("A Thread in Java is:");
        System.out.println("- The smallest unit of execution");
        System.out.println("- A lightweight process that shares memory space");
        System.out.println("- Managed by the Java Virtual Machine");
        System.out.println("- Enables concurrent execution of multiple tasks");
        System.out.println("- Represented by java.lang.Thread class");
        
        // Demonstrate basic thread creation and execution
        System.out.println("\n--- Basic Thread Execution ---");
        
        // Get current thread information
        Thread currentThread = Thread.currentThread();
        System.out.println("Current thread: " + currentThread.getName());
        System.out.println("Thread ID: " + currentThread.getId());
        System.out.println("Thread priority: " + currentThread.getPriority());
        System.out.println("Thread state: " + currentThread.getState());
        System.out.println("Is daemon thread: " + currentThread.isDaemon());
        
        // Demonstrate thread creation
        Thread simpleThread = new Thread(() -> {
            System.out.println("Hello from thread: " + Thread.currentThread().getName());
        });
        
        System.out.println("Thread created: " + simpleThread.getName());
        System.out.println("Thread state before start: " + simpleThread.getState());
        
        simpleThread.start();
        
        try {
            simpleThread.join(); // Wait for thread to complete
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Thread state after completion: " + simpleThread.getState());
    }
    
    static void demonstrateThreadVsProcess() {
        System.out.println("\n=== Thread vs Process ===");
        
        System.out.println("THREAD vs PROCESS COMPARISON:");
        System.out.println();
        System.out.println("PROCESS:");
        System.out.println("- Independent program in execution");
        System.out.println("- Has its own memory space");
        System.out.println("- Heavyweight (more resource intensive)");
        System.out.println("- Inter-process communication is complex");
        System.out.println("- Process creation/destruction is expensive");
        System.out.println("- Each process has its own address space");
        
        System.out.println("\nTHREAD:");
        System.out.println("- Lightweight subprocess");
        System.out.println("- Shares memory space with other threads");
        System.out.println("- Lightweight (less resource intensive)");
        System.out.println("- Inter-thread communication is simple");
        System.out.println("- Thread creation/destruction is cheaper");
        System.out.println("- Threads share the same address space");
        
        // Demonstrate the difference
        System.out.println("\n--- Practical Demonstration ---");
        
        // Process information (JVM process)
        Runtime runtime = Runtime.getRuntime();
        System.out.println("JVM Process Information:");
        System.out.println("- Available processors: " + runtime.availableProcessors());
        System.out.println("- Total memory: " + runtime.totalMemory() / (1024 * 1024) + " MB");
        System.out.println("- Free memory: " + runtime.freeMemory() / (1024 * 1024) + " MB");
        
        // Thread information
        System.out.println("\nThread Information:");
        System.out.println("- Current thread: " + Thread.currentThread().getName());
        System.out.println("- Thread group: " + Thread.currentThread().getThreadGroup().getName());
        
        // Demonstrate multiple threads sharing memory
        System.out.println("\n--- Memory Sharing Demonstration ---");
        SharedCounter counter = new SharedCounter();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                counter.increment();
                System.out.println("Thread 1 - Counter: " + counter.getCount());
                try { Thread.sleep(100); } catch (InterruptedException e) { break; }
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                counter.increment();
                System.out.println("Thread 2 - Counter: " + counter.getCount());
                try { Thread.sleep(100); } catch (InterruptedException e) { break; }
            }
        });
        
        thread1.start();
        thread2.start();
        
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Final counter value: " + counter.getCount());
        System.out.println("Note: Both threads shared the same counter object (memory space)");
    }
    
    static void demonstrateMultithreadingModel() {
        System.out.println("\n=== Multithreading Model ===");
        
        System.out.println("MULTITHREADING MODEL CHARACTERISTICS:");
        System.out.println("1. Multiple threads execute concurrently");
        System.out.println("2. Threads share memory space");
        System.out.println("3. Thread scheduler manages execution");
        System.out.println("4. Preemptive or cooperative scheduling");
        System.out.println("5. Thread synchronization for shared resources");
        
        // Demonstrate concurrent execution
        System.out.println("\n--- Concurrent Execution Demonstration ---");
        
        System.out.println("Starting multiple threads to demonstrate concurrency:");
        
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            final int threadNumber = i + 1;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    System.out.println("Thread " + threadNumber + " - Iteration " + (j + 1));
                    try {
                        Thread.sleep(100); // Simulate work
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            });
            threads[i].start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("All threads completed - notice the interleaved output");
        
        // Demonstrate thread benefits
        System.out.println("\n--- Benefits of Multithreading ---");
        demonstrateThreadBenefits();
    }
    
    static void demonstrateThreadBenefits() {
        System.out.println("BENEFITS OF MULTITHREADING:");
        System.out.println("1. Improved Performance: Utilize multiple CPU cores");
        System.out.println("2. Better Responsiveness: UI remains responsive during background tasks");
        System.out.println("3. Resource Sharing: Efficient use of memory and other resources");
        System.out.println("4. Simplified Programming: Natural way to model concurrent activities");
        System.out.println("5. Scalability: Handle multiple clients/requests simultaneously");
        
        // Demonstrate performance benefit
        System.out.println("\n--- Performance Demonstration ---");
        
        int[] data = new int[1000000];
        for (int i = 0; i < data.length; i++) {
            data[i] = i;
        }
        
        // Sequential processing
        long startTime = System.nanoTime();
        long sequentialSum = calculateSumSequential(data);
        long sequentialTime = System.nanoTime() - startTime;
        
        // Parallel processing
        startTime = System.nanoTime();
        long parallelSum = calculateSumParallel(data);
        long parallelTime = System.nanoTime() - startTime;
        
        System.out.printf("Sequential sum: %d (%.2f ms)%n", 
                        sequentialSum, sequentialTime / 1_000_000.0);
        System.out.printf("Parallel sum: %d (%.2f ms)%n", 
                        parallelSum, parallelTime / 1_000_000.0);
        System.out.printf("Speedup: %.2fx%n", (double) sequentialTime / parallelTime);
    }
    
    static long calculateSumSequential(int[] data) {
        long sum = 0;
        for (int value : data) {
            sum += value;
        }
        return sum;
    }
    
    static long calculateSumParallel(int[] data) {
        int numThreads = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        
        try {
            int chunkSize = data.length / numThreads;
            Future<Long>[] futures = new Future[numThreads];
            
            for (int i = 0; i < numThreads; i++) {
                final int start = i * chunkSize;
                final int end = (i == numThreads - 1) ? data.length : (i + 1) * chunkSize;
                
                futures[i] = executor.submit(() -> {
                    long sum = 0;
                    for (int j = start; j < end; j++) {
                        sum += data[j];
                    }
                    return sum;
                });
            }
            
            long totalSum = 0;
            for (Future<Long> future : futures) {
                totalSum += future.get();
            }
            
            return totalSum;
        } catch (Exception e) {
            throw new RuntimeException("Parallel calculation failed", e);
        } finally {
            executor.shutdown();
        }
    }
    
    static void demonstrateThreadCreationMethods() {
        System.out.println("\n=== Thread Creation Methods ===");
        
        System.out.println("THREAD CREATION METHODS:");
        System.out.println("1. Extending Thread class");
        System.out.println("2. Implementing Runnable interface");
        System.out.println("3. Using lambda expressions");
        System.out.println("4. Using ExecutorService (modern approach)");
        
        // Method 1: Extending Thread class
        System.out.println("\n--- Method 1: Extending Thread Class ---");
        ThreadByExtension thread1 = new ThreadByExtension("ThreadByExtension");
        thread1.start();
        
        try {
            thread1.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Method 2: Implementing Runnable interface
        System.out.println("\n--- Method 2: Implementing Runnable Interface ---");
        Thread runnableThread = new Thread(new ThreadByRunnable(), "ThreadByRunnable");
        runnableThread.start();
        
        try {
            runnableThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Method 3: Lambda expression
        System.out.println("\n--- Method 3: Lambda Expression ---");
        Thread lambdaThread = new Thread(() -> {
            System.out.println("Hello from lambda thread: " + Thread.currentThread().getName());
            for (int i = 1; i <= 3; i++) {
                System.out.println("Lambda thread iteration: " + i);
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }, "LambdaThread");
        
        lambdaThread.start();
        
        try {
            lambdaThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Method 4: ExecutorService (modern approach)
        System.out.println("\n--- Method 4: ExecutorService (Modern Approach) ---");
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Future<?> future = executor.submit(() -> {
            System.out.println("Hello from ExecutorService thread: " + Thread.currentThread().getName());
            for (int i = 1; i <= 3; i++) {
                System.out.println("ExecutorService iteration: " + i);
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        
        try {
            future.get(); // Wait for completion
        } catch (Exception e) {
            System.err.println("ExecutorService task failed: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
    
    static void demonstrateThreadLifecycle() {
        System.out.println("\n=== Thread Lifecycle ===");
        
        System.out.println("THREAD LIFECYCLE STATES:");
        System.out.println("1. NEW - Thread created but not started");
        System.out.println("2. RUNNABLE - Thread is executing or ready to execute");
        System.out.println("3. BLOCKED - Thread waiting for monitor lock");
        System.out.println("4. WAITING - Thread waiting indefinitely for another thread");
        System.out.println("5. TIMED_WAITING - Thread waiting for specified time");
        System.out.println("6. TERMINATED - Thread has completed execution");
        
        // Demonstrate thread lifecycle
        System.out.println("\n--- Thread Lifecycle Demonstration ---");
        
        Thread lifecycleThread = new Thread(() -> {
            System.out.println("Thread started: " + Thread.currentThread().getState());
            
            try {
                Thread.sleep(1000); // TIMED_WAITING state
                System.out.println("Thread after sleep: " + Thread.currentThread().getState());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("Thread completing: " + Thread.currentThread().getState());
        }, "LifecycleThread");
        
        System.out.println("Thread state before start: " + lifecycleThread.getState());
        
        lifecycleThread.start();
        
        // Monitor state changes
        Thread.State previousState = lifecycleThread.getState();
        while (lifecycleThread.isAlive()) {
            Thread.State currentState = lifecycleThread.getState();
            if (currentState != previousState) {
                System.out.println("Thread state changed: " + previousState + " -> " + currentState);
                previousState = currentState;
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        System.out.println("Final thread state: " + lifecycleThread.getState());
        
        try {
            lifecycleThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    static void demonstrateThreadStates() {
        System.out.println("\n=== Thread States Detail ===");
        
        System.out.println("DETAILED THREAD STATES:");
        
        // NEW state
        System.out.println("\n--- NEW State ---");
        Thread newThread = new Thread(() -> System.out.println("Running"));
        System.out.println("NEW thread state: " + newThread.getState());
        
        // RUNNABLE state
        System.out.println("\n--- RUNNABLE State ---");
        Thread runnableThread = new Thread(() -> {
            System.out.println("Thread is RUNNABLE: " + Thread.currentThread().getState());
            // Simulate some work
            for (int i = 0; i < 1000000; i++) {
                Math.random();
            }
        });
        runnableThread.start();
        
        try {
            Thread.sleep(50); // Give thread time to run
            System.out.println("Thread state while running: " + runnableThread.getState());
            runnableThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // BLOCKED state demonstration
        System.out.println("\n--- BLOCKED State ---");
        Object lock = new Object();
        
        Thread blockingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(2000); // Hold lock for 2 seconds
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Got the lock!");
            }
        });
        
        blockingThread.start();
        waitingThread.start();
        
        try {
            Thread.sleep(100); // Give threads time to start
            System.out.println("Waiting thread state: " + waitingThread.getState());
            blockingThread.join();
            waitingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // WAITING state demonstration
        System.out.println("\n--- WAITING State ---");
        Object waitLock = new Object();
        
        Thread waitingThread2 = new Thread(() -> {
            synchronized (waitLock) {
                try {
                    waitLock.wait(); // WAITING state
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        waitingThread2.start();
        
        try {
            Thread.sleep(100);
            System.out.println("Waiting thread state: " + waitingThread2.getState());
            
            synchronized (waitLock) {
                waitLock.notify();
            }
            
            waitingThread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // TIMED_WAITING state demonstration
        System.out.println("\n--- TIMED_WAITING State ---");
        Thread timedWaitingThread = new Thread(() -> {
            try {
                Thread.sleep(1000); // TIMED_WAITING state
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        timedWaitingThread.start();
        
        try {
            Thread.sleep(100);
            System.out.println("Timed waiting thread state: " + timedWaitingThread.getState());
            timedWaitingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // TERMINATED state
        System.out.println("\n--- TERMINATED State ---");
        System.out.println("Terminated thread state: " + timedWaitingThread.getState());
    }
    
    static void demonstrateThreadControl() {
        System.out.println("\n=== Thread Control Mechanisms ===");
        
        System.out.println("THREAD CONTROL METHODS:");
        System.out.println("1. start() - Start thread execution");
        System.out.println("2. run() - Execute thread code (don't call directly)");
        System.out.println("3. join() - Wait for thread to complete");
        System.out.println("4. interrupt() - Interrupt thread execution");
        System.out.println("5. sleep() - Pause thread execution");
        System.out.println("6. yield() - Hint to scheduler to yield CPU");
        
        // Demonstrate start() vs run()
        System.out.println("\n--- start() vs run() Method ---");
        
        System.out.println("Difference between start() and run():");
        System.out.println("- start(): Creates new thread and calls run() in that thread");
        System.out.println("- run(): Executes code in current thread (no new thread)");
        
        Thread startThread = new Thread(() -> {
            System.out.println("Thread using start(): " + Thread.currentThread().getName());
        });
        
        System.out.println("Calling start() method:");
        startThread.start();
        
        try {
            startThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Calling run() method directly:");
        startThread.run(); // This runs in main thread, not new thread
        
        // Demonstrate thread interruption
        System.out.println("\n--- Thread Interruption ---");
        
        Thread interruptibleThread = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    if (Thread.currentThread().isInterrupted()) {
                        System.out.println("Thread was interrupted, stopping...");
                        break;
                    }
                    System.out.println("Working... " + i);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted via InterruptedException");
                Thread.currentThread().interrupt(); // Restore interrupt status
            }
        });
        
        interruptibleThread.start();
        
        try {
            Thread.sleep(1500); // Let thread run for a bit
            interruptibleThread.interrupt(); // Interrupt the thread
            interruptibleThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate thread joining
        System.out.println("\n--- Thread Joining ---");
        
        Thread[] workers = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int workerId = i + 1;
            workers[i] = new Thread(() -> {
                System.out.println("Worker " + workerId + " starting");
                try {
                    Thread.sleep(1000 + workerId * 500); // Different work times
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Worker " + workerId + " completed");
            });
            workers[i].start();
        }
        
        System.out.println("Waiting for all workers to complete...");
        for (Thread worker : workers) {
            try {
                worker.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        System.out.println("All workers completed!");
    }
}

// ========== HELPER CLASSES ==========

/**
 * Thread created by extending Thread class
 */
class ThreadByExtension extends Thread {
    public ThreadByExtension(String name) {
        super(name);
    }
    
    @Override
    public void run() {
        System.out.println("Hello from " + getName() + " (extends Thread)");
        for (int i = 1; i <= 3; i++) {
            System.out.println(getName() + " - Iteration: " + i);
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
}

/**
 * Thread created by implementing Runnable interface
 */
class ThreadByRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Hello from " + Thread.currentThread().getName() + " (implements Runnable)");
        for (int i = 1; i <= 3; i++) {
            System.out.println(Thread.currentThread().getName() + " - Iteration: " + i);
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
}

/**
 * Shared counter class to demonstrate memory sharing
 */
class SharedCounter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use Runnable interface over extending Thread class for better design
- Always call start() method, never call run() directly for new thread execution
- Use ExecutorService for modern thread management
- Implement proper thread interruption handling
- Use synchronized methods or blocks for thread safety

**Don'ts:**
- Don't call run() method directly when you want a new thread
- Don't start a thread twice (it will throw IllegalThreadStateException)
- Don't ignore InterruptedException - handle it properly
- Don't rely on thread priorities for critical functionality
- Don't use stop() method (deprecated and unsafe)

**Common Pitfalls:**
- Calling run() instead of start() method
- Starting a thread multiple times
- Not handling InterruptedException properly
- Race conditions when accessing shared data
- Deadlocks when using multiple locks

## 5. Summary

- **Thread** is the smallest unit of execution in Java, representing an independent path of execution
- **Thread vs Process**: Threads are lightweight, share memory space, while processes are heavyweight and independent
- **Multithreading model** enables concurrent execution of multiple threads within a single process
- **Thread creation** can be done by extending Thread class or implementing Runnable interface
- **Thread lifecycle** includes states: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
- **Thread control** methods include start(), run(), join(), interrupt(), sleep(), yield()
- **start() vs run()**: start() creates new thread, run() executes in current thread
- **Thread benefits** include improved performance, responsiveness, and resource utilization

## 6. Tricky Interview Questions

1. **Thread Definition**: What is Thread in Java? How does it differ from a process?

2. **Thread vs Process**: What is the difference between Thread and Process in Java? Give examples of each.

3. **Thread Implementation**: How do you implement Thread in Java? What are the different approaches?

4. **Runnable vs Thread**: When to use Runnable vs Thread in Java? What are the advantages of each approach?

5. **start() vs run()**: What is the difference between start() and run() method of Thread class? What happens if you call run() directly?

6. **Thread States**: What are the different states of a thread? Explain each state with examples.

7. **Thread Control**: How do you stop a thread in Java? What are the different ways to control thread execution?

8. **Thread Priorities**: Explain the different priorities of Threads. How does thread scheduling work?

9. **Thread Lifecycle**: What happens when a thread enters the waiting stage? What are the different ways a thread can enter waiting?

10. **Thread Safety**: What are the primary drawbacks of using synchronized methods? How do you ensure thread safety?

11. **Thread Reusability**: Is it possible to start a thread twice? What happens if you try to do so?

12. **Concurrency Benefits**: What are the benefits of multithreading? How does it improve application performance?
