## 1. Topic Overview

- `ThreadLocal` stores per-thread data, useful for context like request IDs; misuse can cause leaks in thread pools.

## 2 . Topic definition

- WHAT: Per-thread variable storage; each thread has its own copy.
- WHY: Avoid passing context everywhere; keep state isolated per thread.
- HOW: Define `ThreadLocal.withInitial(...)`; set/get within thread; clear after use.
- WHEN/WHERE: Request-scoped data, formatters, correlation IDs.
- WHAT IF: Not clearing in pools leaks memory/data across requests.

## 3. Deep Dive with Examples

```java
class RequestContext {
    static final ThreadLocal<String> correlationId = ThreadLocal.withInitial(() -> null);
}

// usage in filter/interceptor
RequestContext.correlationId.set("req-123");
try { /* process */ }
finally { RequestContext.correlationId.remove(); }
```

## 4. Best Practices & Pitfalls

- Always `remove()` in `finally` when using pools.
- Prefer explicit context passing when feasible; avoid hidden coupling.
- Use `InheritableThreadLocal` carefully; may leak into thread pools.

## 5. Summary

- Powerful for per-thread context with strict lifecycle management.

## 6. Tricky Interview Questions

1. Why does `ThreadLocal` leak in application servers? How to prevent it?
2. Difference between `ThreadLocal` and `InheritableThreadLocal`.

