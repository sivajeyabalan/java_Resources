## 1. Topic Overview

- Executors abstract thread management. Thread pools reuse a fixed number of threads to execute many tasks efficiently, reducing creation overhead and providing back-pressure and lifecycle management.

## 2 . Topic definition

- WHAT: `Executor` runs submitted tasks; `ExecutorService` adds lifecycle (`shutdown`), futures, and pooling; `Executors` provides factories; `ThreadPoolExecutor` is the configurable engine.
- WHY: Creating a thread per task is costly and unsafe under load. Pools control concurrency, queueing, and resource use.
- HOW: Choose pool type (fixed, cached, scheduled, work-stealing), submit `Runnable`/`Callable`, manage shutdown, handle rejections.
- WHEN/WHERE: Use pools for server-side request handling, background processing, periodic tasks.
- WHAT IF: Wrong pool sizing leads to saturation or context switching; unbounded queues cause latency spikes; forgetting shutdown leaks threads.
- EXAMPLES: CPU vs IO pool sizing, custom `ThreadPoolExecutor`.

## 3. Deep Dive with Examples

```java
import java.util.List;
import java.util.concurrent.*;

public class ExecutorsBasics {
    public static void main(String[] args) throws Exception {
        ExecutorService fixed = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        Future<Integer> future = fixed.submit(() -> expensiveComputation(42));
        System.out.println("Result: " + future.get());
        fixed.shutdown();
    }

    static int expensiveComputation(int x) {
        return x * x;
    }
}
```

```java
// Custom ThreadPoolExecutor with bounded queue and rejection policy
import java.util.concurrent.*;

public class CustomPool {
    public static ExecutorService createCpuBoundPool(int parallelism) {
        int core = parallelism;
        int max = parallelism; // for CPU-bound, keep core == max
        long keepAlive = 0L;
        BlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(1000);
        ThreadFactory factory = r -> {
            Thread t = new Thread(r);
            t.setName("cpu-pool-" + t.getId());
            t.setDaemon(false);
            return t;
        };
        RejectedExecutionHandler reject = new ThreadPoolExecutor.CallerRunsPolicy();
        return new ThreadPoolExecutor(core, max, keepAlive, TimeUnit.SECONDS, queue, factory, reject);
    }
}
```

```java
// Scheduled tasks
import java.util.concurrent.*;

public class SchedulingExample {
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
        scheduler.scheduleAtFixedRate(() -> System.out.println("Tick"), 1, 5, TimeUnit.SECONDS);
        scheduler.schedule(() -> System.out.println("One-off"), 2, TimeUnit.SECONDS);
        // add shutdown hook in real apps
    }
}
```

Pool sizing guidelines:
- CPU-bound: size ≈ number of cores (use `availableProcessors()`).
- IO-bound: size > cores (cores × (1 + wait/compute)). Measure and adjust.

## 4. Best Practices & Pitfalls

- Always call `shutdown()` or `shutdownNow()` (with await termination) to release threads.
- Use bounded queues and appropriate rejection policies to avoid overload.
- Name threads via `ThreadFactory` for observability; set uncaught exception handlers.
- Avoid blocking inside common fork-join pool tasks; use dedicated pools for blocking IO.
- Prefer `newWorkStealingPool` for many small, fork-join style tasks.

## 5. Summary

- Executors decouple task submission from execution. Properly sized, bounded pools improve performance and stability.

## 6. Tricky Interview Questions

1. Compare fixed vs cached vs scheduled vs work-stealing pools and use cases.
2. Explain how `ThreadPoolExecutor` chooses to create threads vs queue tasks.
3. What happens on `shutdown()` vs `shutdownNow()`? How to await termination safely?
4. Why is an unbounded queue dangerous with a fixed pool? What are mitigations?
5. How to size pools for CPU vs IO workloads? Give a formula and caveats.

