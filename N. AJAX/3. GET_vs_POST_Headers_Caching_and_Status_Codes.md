## 1. Topic Overview

Understanding HTTP semantics is crucial for robust AJAX: choose the right method, set headers, leverage caching, and handle status codes.

## 2 . Topic definition

- **GET**: Safe, idempotent; parameters in URL; cacheable.
- **POST**: For creating/processing; body carries data; usually not cacheable.
- **Headers**: `Content-Type`, `Accept`, `Cache-Control`, custom headers.
- **Status codes**: 2xx success, 3xx redirection, 4xx client error, 5xx server error.

## 3. Deep Dive with Examples

```js
// GET with cache-busting
fetch('/api/users?ts=' + Date.now(), { headers: { 'Accept': 'application/json' } })
  .then(r => r.json()).then(data => console.log(data));

// POST JSON
fetch('/api/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'Alice' })
});
```

Caching headers:
```http
Cache-Control: no-store
ETag: "abc123"
If-None-Match: "abc123"
```

Client handling:
```js
const res = await fetch('/api/data');
if (res.status === 304) { /* use cached */ }
if (!res.ok) { /* show error */ }
```

## 4. Best Practices & Pitfalls

- Use idempotent methods for retries; avoid side effects on GET.
- Implement ETag/Last-Modified to reduce bandwidth.
- Pitfall: Sending sensitive data in query strings; prefer POST body and HTTPS.

## 5. Summary

- Method choice, headers, and caching policies directly affect reliability and performance.

## 6. Tricky Interview Questions

1) When is 201 vs 200 appropriate for POST? What headers accompany 201?
2) How to safely implement retries without duplicating server-side effects?
