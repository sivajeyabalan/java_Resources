## 1. Topic Overview

Security constraints affect AJAX heavily: same-origin policy, CORS for cross-origin calls, cookie `SameSite` behavior, and XSS/CSRF protections.

## 2 . Topic definition

- **Same-Origin Policy**: Browser restricts cross-origin reads for security.
- **CORS**: Server-set headers (`Access-Control-Allow-Origin`, etc.) to allow cross-origin requests.
- **SameSite**: Cookie attribute controlling cross-site sending (Lax/Strict/None).

## 3. Deep Dive with Examples

Server CORS (Servlet):
```java
resp.setHeader("Access-Control-Allow-Origin", "https://app.example.com");
resp.setHeader("Access-Control-Allow-Methods", "GET,POST");
resp.setHeader("Access-Control-Allow-Headers", "Content-Type,Authorization");
```

Preflight handling:
```http
OPTIONS /api/data HTTP/1.1
Origin: https://app.example.com
Access-Control-Request-Method: POST
```

CSRF note (cookies): Use SameSite=Lax by default; for cross-site POSTs, add CSRF tokens.

## 4. Best Practices & Pitfalls

- Narrow CORS origins; avoid `*` with credentials.
- Set `SameSite=Lax` or `Strict` for session cookies; use `Secure` and `HttpOnly`.
- Sanitize outputs to avoid XSS; never blindly inject server data into DOM.

## 5. Summary

- Understand SOP/CORS and cookie attributes to safely enable cross-origin AJAX.

## 6. Tricky Interview Questions

1) Why canâ€™t `Access-Control-Allow-Origin: *` be used with credentials?
2) How do you safely support a public API consumed by browsers across origins?
