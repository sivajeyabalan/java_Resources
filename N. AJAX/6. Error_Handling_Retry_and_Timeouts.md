## 1. Topic Overview

AJAX must handle transient failures gracefully using timeouts, retries with backoff, and user-visible error messages.

## 2 . Topic definition

- **Timeout**: Upper bound for waiting on a response.
- **Retry with backoff**: Retry failed requests with delays increasing each attempt.
- **Circuit breaker**: Stop calling a failing endpoint temporarily.

## 3. Deep Dive with Examples

```js
async function fetchWithTimeout(resource, options = {}) {
  const { timeout = 5000 } = options;
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const res = await fetch(resource, { ...options, signal: controller.signal });
    return res;
  } finally { clearTimeout(id); }
}

async function retry(fn, attempts = 3) {
  let delay = 300;
  for (let i = 0; i < attempts; i++) {
    try { return await fn(); } catch (e) { if (i === attempts - 1) throw e; }
    await new Promise(r => setTimeout(r, delay));
    delay *= 2;
  }
}
```

## 4. Best Practices & Pitfalls

- Retry only idempotent operations; show clear errors when retries exhaust.
- Log errors with correlation IDs; collect metrics for alerting.
- Pitfall: Infinite retries or retry storms during outages.

## 5. Summary

- Combine timeouts, bounded retries with backoff, and user feedback for resilience.

## 6. Tricky Interview Questions

1) How do you detect and treat client aborts on the server side?
2) Which status codes should not be retried and why?
