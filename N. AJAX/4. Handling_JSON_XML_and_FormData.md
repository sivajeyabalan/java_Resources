## 1. Topic Overview

AJAX payloads commonly use JSON, but XML and `FormData` are also used. Know how to serialize/deserialize each and set proper headers.

## 2 . Topic definition

- **JSON**: Lightweight, native to JS; `application/json`.
- **XML**: Structured; `application/xml` or `text/xml`.
- **FormData**: Multipart form uploads; files + fields.

## 3. Deep Dive with Examples

JSON:
```js
await fetch('/api/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ a: 1 }) });
```

XML:
```js
const xml = `<msg><text>Hello</text></msg>`;
await fetch('/api/xml', { method: 'POST', headers: { 'Content-Type': 'application/xml' }, body: xml });
```

FormData:
```js
const fd = new FormData();
fd.append('name', 'doc');
fd.append('file', fileInput.files[0]);
await fetch('/api/upload', { method: 'POST', body: fd }); // Browser sets boundary
```

Servlet handlers:
```java
// JSON
String json = new String(req.getInputStream().readAllBytes(), java.nio.charset.StandardCharsets.UTF_8);

// XML
org.w3c.dom.Document doc = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(req.getInputStream());

// Multipart
@MultipartConfig
@WebServlet("/api/upload")
public class UploadApi extends HttpServlet { /* getPart("file") */ }
```

## 4. Best Practices & Pitfalls

- Always set `Content-Type` and check `Accept`.
- Validate and sanitize inputs; limit file sizes/types for uploads.
- Pitfall: Manually setting multipart boundariesâ€”let the browser handle it.

## 5. Summary

- Use JSON by default; support XML/Multipart when needed; set headers correctly.

## 6. Tricky Interview Questions

1) How do you detect and handle a malformed JSON body gracefully?
2) How to stream large file uploads while showing progress to the user?
