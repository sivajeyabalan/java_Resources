## 1. Topic Overview

- In Java, a class is a blueprint that defines state (fields) and behavior (methods). An object is a runtime instance of a class with its own copy of instance fields.
- Classes encapsulate data and operations, enabling modularity, reusability, and maintainability.
- Real-world mapping: a `Car` class defines features; a specific car you own is an object.

## 2. Deep Dive with Examples

### Beginner: Define a simple class and create objects

```java
class Point {
    // State (instance fields)
    int x;
    int y;

    // Behavior (instance method)
    int manhattanDistance() {
        return Math.abs(x) + Math.abs(y);
    }
}

public class Main {
    public static void main(String[] args) {
        Point p1 = new Point(); // object 1
        p1.x = 3; p1.y = -2;

        Point p2 = new Point(); // object 2
        p2.x = 10; p2.y = 4;

        System.out.println(p1.manhattanDistance()); // 5
        System.out.println(p2.manhattanDistance()); // 14
    }
}
```

### Intermediate: Encapsulation with getters/setters

```java
class BankAccount {
    private String owner;      // hidden state
    private double balance;    // invariant: balance >= 0

    public BankAccount(String owner, double openingBalance) {
        if (openingBalance < 0) throw new IllegalArgumentException("Negative opening balance");
        this.owner = owner;
        this.balance = openingBalance;
    }

    public String getOwner() { return owner; }
    public double getBalance() { return balance; }

    public void deposit(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Amount must be positive");
        balance += amount;
    }

    public void withdraw(double amount) {
        if (amount <= 0 || amount > balance) throw new IllegalArgumentException("Invalid amount");
        balance -= amount;
    }
}
```

### Advanced: Class vs object identity and equality

```java
class User {
    private final String id; // unique identifier
    private final String name;

    public User(String id, String name) {
        this.id = id; this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;              // same object
        if (!(obj instanceof User)) return false;  // type check
        User other = (User) obj;
        return id.equals(other.id);                // logical equality by id
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}
```

## 3. Best Practices & Pitfalls

- Prefer `private` fields; expose minimal public API to preserve invariants.
- Implement `equals` and `hashCode` together for classes used in collections (e.g., `HashSet`).
- Avoid exposing mutable internal state directly; return copies or unmodifiable views.
- Initialize objects to a valid state using constructors; validate inputs.
- Pitfall: Using `==` for string/content comparison. Use `.equals`.

## 4. Summary

- A class is a blueprint; an object is its runtime instance.
- Encapsulation protects invariants and simplifies maintenance.
- Equality should be logical (`equals`/`hashCode`) when used in collections.

## 5. Tricky Interview Questions

1. If `a.equals(b)` is true, must `a == b` be true? Why or why not?
2. What invariants can be broken if you expose internal mutable arrays via a getter?
3. How does `hashCode` relate to `equals`? What happens if only one is overridden?
4. When might you avoid setters entirely? Give a scenario.
5. Show a bug from comparing two `Integer` objects with `==` and explain.
6. How would you design an immutable class? Which fields, constructors, and methods?
7. What is object identity vs logical equality? How does it affect caching?
8. Can constructors call instance methods safely? What are the risks?
