## 1. Topic Overview

- Encapsulation hides internal representation and exposes a controlled API. Abstraction focuses on essential features while hiding details.
- Together they reduce coupling and enable maintainable, evolvable code.

## 2. Deep Dive with Examples

### Beginner: Encapsulation via access modifiers

```java
class Thermostat {
    private double temperature; // Celsius

    public double getTemperature() { return temperature; }
    public void setTemperature(double temperature) {
        if (temperature < -50 || temperature > 60) throw new IllegalArgumentException("Range");
        this.temperature = temperature;
    }
}
```

### Intermediate: Abstraction with interfaces

```java
interface PaymentGateway {
    boolean charge(String accountId, int cents);
}

class StripeGateway implements PaymentGateway {
    public boolean charge(String accountId, int cents) { return true; }
}

class CheckoutService {
    private final PaymentGateway gateway; // abstract dependency
    CheckoutService(PaymentGateway gateway) { this.gateway = gateway; }
    public boolean checkout(String userId, int amount) { return gateway.charge(userId, amount); }
}
```

### Advanced: Encapsulation with invariants and immutability

```java
import java.util.Collections;
import java.util.List;

final class ShoppingCart {
    private final List<String> items;

    public ShoppingCart(List<String> items) {
        this.items = List.copyOf(items); // defensive copy and unmodifiable
    }

    public List<String> getItems() {
        return Collections.unmodifiableList(items);
    }
}
```

## 3. Best Practices & Pitfalls

- Keep fields `private`; expose minimal, intention-revealing methods.
- Depend on abstractions (interfaces), not concretions; inject implementations.
- Preserve invariants through constructors and setters.
- Pitfall: Leaking internal collections or arrays allows external mutation.

## 4. Summary

- Encapsulation hides data; abstraction hides details behind contracts.
- Interfaces decouple clients from implementations.

## 5. Tricky Interview Questions

1. Show how exposing a mutable `Date` via a getter breaks encapsulation.
2. Why is depending on interfaces better than concrete classes?
3. How do access modifiers support encapsulation hierarchy-wide?
4. Contrast encapsulation and abstraction with concrete design examples.
5. Demonstrate how immutability enforces strong encapsulation.
