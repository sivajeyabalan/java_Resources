## 1. Topic Overview

- Constructors initialize new objects, setting required fields and invariants.
- `this` refers to the current object; it disambiguates fields from parameters and can call another constructor via `this(...)`.

## 2. Deep Dive with Examples

### Beginner: Basic constructor and `this`

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name; // disambiguate field vs parameter
        this.age = age;
    }
}
```

### Intermediate: Constructor chaining with `this(...)`

```java
class Rectangle {
    private final int width;
    private final int height;

    public Rectangle(int side) {
        this(side, side); // delegate to two-arg constructor
    }

    public Rectangle(int width, int height) {
        if (width <= 0 || height <= 0) throw new IllegalArgumentException("Invalid size");
        this.width = width;
        this.height = height;
    }
}
```

### Advanced: Defensive copying and validation

```java
import java.util.Date;

class Event {
    private final String title;
    private final Date startsAt; // mutable type

    public Event(String title, Date startsAt) {
        if (title == null || title.isBlank()) throw new IllegalArgumentException("title");
        if (startsAt == null) throw new IllegalArgumentException("startsAt");
        this.title = title;
        this.startsAt = new Date(startsAt.getTime()); // defensive copy
    }

    public Date getStartsAt() {
        return new Date(startsAt.getTime()); // avoid exposing internal mutable state
    }
}
```

## 3. Best Practices & Pitfalls

- Validate constructor arguments; fail fast with meaningful messages.
- Prefer immutable objects: initialize all required fields and avoid setters.
- Avoid heavy work or calling overridable methods in constructors (risk: subclass sees partially constructed state).
- Use constructor chaining to centralize validation logic.
- Pitfall: Using `this()` and `super()` together in the same constructor line is illegal; only one can appear and must be first.

## 4. Summary

- Constructors create valid objects; `this` clarifies context and supports chaining.
- Defensive copies prevent external mutation of internal state.
- Avoid invoking overridable methods during construction.

## 5. Tricky Interview Questions

1. Why must `this()` or `super()` be the first statement in a constructor?
2. What happens if a constructor throws? Is the object usable? Explain.
3. Can you call an instance method from a constructor safely? When does it fail?
4. How do you design constructors for immutable vs mutable classes?
5. Why is defensive copying needed for arrays or `Date`, and what if you forget?
6. How does constructor overloading differ from method overloading rules?
