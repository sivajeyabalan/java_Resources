## 1. Topic Overview

- Inner classes are classes declared inside another class: member, static nested, local, and anonymous.
- `final` keyword: variables become constant references; methods non-overridable; classes non-inheritable.

## 2. Deep Dive with Examples

### Beginner: Member and static nested classes

```java
class Outer {
    private int x = 10;

    class MemberInner { // has reference to Outer
        int getOuterX() { return x; }
    }

    static class StaticNested { // no implicit Outer reference
        int twice(int n) { return 2 * n; }
    }
}
```

### Intermediate: Local and anonymous classes

```java
interface Greeter { String greet(); }

class Demo {
    Greeter makeGreeter(String name) {
        final String suffix = "!"; // effectively final
        class LocalGreeter implements Greeter {
            public String greet() { return "Hello, " + name + suffix; }
        }
        return new LocalGreeter();
    }

    Greeter anon() {
        return new Greeter() { public String greet() { return "Hi"; } };
    }
}
```

### Advanced: `final` semantics

```java
final class Constants {
    public static final int MAX = 100;
}

class Base { public final void cannotOverride() {} }
class Sub extends Base { /* cannot override cannotOverride */ }
```

## 3. Best Practices & Pitfalls

- Use static nested classes when the inner does not need an outer instance.
- Anonymous classes are concise for one-off implementations; prefer lambdas for single-method interfaces.
- `final` fields should be initialized once, typically in constructors.
- Pitfall: Local/anonymous classes can only capture effectively final variables.

## 4. Summary

- Choose the right inner class type based on coupling to the outer instance.
- `final` controls mutability and inheritance behavior.

## 5. Tricky Interview Questions

1. Difference between member inner and static nested classes in memory and access.
2. Why must captured variables be effectively final in inner classes?
3. When would you prefer an inner class over a separate top-level class?
4. How does `final` affect thread-safety and safe publication of objects?
5. Can a `final` reference point to a mutable object? Consequences?
