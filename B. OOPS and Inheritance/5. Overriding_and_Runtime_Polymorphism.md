## 1. Topic Overview

- Method overriding lets a subclass provide a specific implementation of a method defined in a superclass.
- Runtime polymorphism (dynamic method dispatch) chooses the method implementation based on the actual object type at runtime, not the reference type.

## 2. Deep Dive with Examples

### Beginner: Overriding basics

```java
class Shape {
    double area() { return 0.0; }
}
class Circle extends Shape {
    private final double r;
    Circle(double r) { this.r = r; }
    @Override double area() { return Math.PI * r * r; }
}
class Rectangle extends Shape {
    private final double w, h;
    Rectangle(double w, double h) { this.w = w; this.h = h; }
    @Override double area() { return w * h; }
}

public class Main {
    public static void main(String[] args) {
        Shape s = new Circle(2);
        System.out.println(s.area()); // dispatches to Circle.area
    }
}
```

### Intermediate: Upcasting, overriding, and the `instanceof` operator

```java
class Printer {
    void print(Shape s) {
        System.out.println("Area: " + s.area()); // dynamic dispatch
        if (s instanceof Circle) {
            System.out.println("It is a circle");
        }
    }
}
```

### Advanced: Covariant return types and `final` methods

```java
class Animal { Animal reproduce() { return new Animal(); } }
class Cat extends Animal {
    @Override Cat reproduce() { // covariant return type
        return new Cat();
    }
}

class Base {
    public final void stable() { } // cannot be overridden
}
```

## 3. Best Practices & Pitfalls

- Use `@Override` to catch mistakes early (mismatched signature, wrong access).
- Match or widen access level when overriding; do not reduce it.
- Do not throw broader checked exceptions than the overridden method.
- Avoid calling overridable methods from constructors.
- Pitfall: Overload vs override confusionâ€”overloading is compile-time selection by parameter types, not polymorphism.

## 4. Summary

- Overriding enables specialized behavior; runtime type decides the method invoked.
- Use `@Override` and follow signature/access/exception rules for safe overriding.

## 5. Tricky Interview Questions

1. Differentiate overriding from overloading with code that compiles but surprises.
2. Can overridden methods throw new checked exceptions? Under what constraints?
3. How does access level change in overriding? Provide examples.
4. Show how polymorphism can remove `if-else` chains and improve extensibility.
5. Demonstrate a bug caused by calling an overridable method in a constructor.
