## 1. Topic Overview

- Inheritance allows a class (subclass) to acquire state and behavior from another (superclass) using `extends`.
- `super` keyword refers to the immediate superclass: access hidden fields/methods and invoke superclass constructors.
- Java supports single inheritance for classes; multiple inheritance via interfaces.

## 2. Deep Dive with Examples

### Beginner: Basic inheritance and `super()`

```java
class Animal {
    protected final String name;
    public Animal(String name) { this.name = name; }
    public void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name); // must be first statement
    }
}
```

### Intermediate: Field hiding and method access via `super`

```java
class Parent {
    int value = 42;
    void show() { System.out.println("Parent.show: " + value); }
}

class Child extends Parent {
    int value = 7; // hides parent field
    @Override void show() {
        System.out.println("Child.show: " + value);
        System.out.println("Parent value via super: " + super.value);
        super.show();
    }
}
```

### Advanced: Multilevel hierarchy and constructor order

```java
class A { A() { System.out.println("A"); } }
class B extends A { B() { System.out.println("B"); } }
class C extends B { C() { System.out.println("C"); } }

// new C() prints: A, then B, then C
```

## 3. Best Practices & Pitfalls

- Favor composition over inheritance when "is-a" does not strictly hold.
- Keep superclasses stable and focused; changes ripple to subclasses.
- Always call the proper `super(...)` constructor to initialize inherited state.
- Avoid field hiding; prefer different names to reduce confusion.
- Pitfall: Constructors do not inherit; remember to expose necessary ones in subclasses.

## 4. Summary

- `extends` builds hierarchies; `super` accesses superclass state/behavior and constructors.
- Constructor chaining goes from superclass to subclass.

## 5. Tricky Interview Questions

1. Why canâ€™t constructors be inherited or overridden? What is the design rationale?
2. Demonstrate field hiding vs method overriding with output and explain resolution rules.
3. When would you prefer composition over inheritance for code reuse?
4. What happens if `super(...)` is omitted in a subclass constructor?
5. Can you access a hidden superclass variable? Show how and discuss trade-offs.
