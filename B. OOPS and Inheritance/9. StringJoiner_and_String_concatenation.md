## 1. Topic Overview

- `StringJoiner` and `String.join` help efficiently build delimited strings.
- Prefer `StringBuilder` or joining utilities over repeated `+` concatenation in loops.

## 2. Deep Dive with Examples

### Beginner: Concatenation pitfalls

```java
String result = "";
for (int i = 0; i < 3; i++) {
    result += i; // creates many intermediate strings
}
```

### Intermediate: Using `StringBuilder`

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 3; i++) {
    sb.append(i);
}
String result = sb.toString();
```

### Advanced: `StringJoiner` and `String.join`

```java
import java.util.StringJoiner;
import java.util.List;

StringJoiner sj = new StringJoiner(", ", "[", "]");
sj.add("A").add("B").add("C");
String joined = sj.toString(); // "[A, B, C]"

List<String> names = List.of("Alice", "Bob", "Cara");
String csv = String.join(",", names); // "Alice,Bob,Cara"
```

## 3. Best Practices & Pitfalls

- Use `StringBuilder` for loops and heavy concatenations.
- Use `String.join`/`StringJoiner` for readability with delimiters, prefix, suffix.
- Beware of `null` elements in `String.join`; it throws `NullPointerException`.

## 4. Summary

- Avoid `+` in loops; prefer `StringBuilder` or joiners.
- `StringJoiner` provides delimiter, prefix, and suffix control.

## 5. Tricky Interview Questions

1. Why is `String` immutable and how does it affect concatenation performance?
2. What does the compiler do for `"a" + x + y`? When is it optimized?
3. How does `StringBuilder` differ from `StringBuffer`?
4. What happens if `String.join` receives a list with `null`?
5. How do you join with a delimiter while skipping empty values safely?
