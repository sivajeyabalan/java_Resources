## 1. Topic Overview

- `static` members belong to the class, shared by all instances; instance members belong to each object.
- `final` makes variables unassignable after initialization, methods non-overridable, and classes non-inheritable.

## 2. Deep Dive with Examples

### Beginner: Static vs instance state

```java
class Counter {
    private static int globalCount = 0; // shared
    private int id;                     // per-object

    public Counter() {
        id = ++globalCount;
    }

    public int getId() { return id; }
    public static int getGlobalCount() { return globalCount; }
}
```

### Intermediate: Static block and utility methods

```java
class MathUtil {
    public static final double PI;

    static { // static initialization block
        PI = Math.PI; // complex init logic allowed here
    }

    private MathUtil() { } // prevent instantiation

    public static int clamp(int value, int min, int max) {
        return Math.max(min, Math.min(max, value));
    }
}
```

### Advanced: `final` fields and thread-safety guarantees

```java
final class ApiClient { // cannot be subclassed
    private final String baseUrl; // safe publication if set in constructor

    public ApiClient(String baseUrl) {
        if (baseUrl == null || baseUrl.isBlank()) throw new IllegalArgumentException("baseUrl");
        this.baseUrl = baseUrl;
    }

    public final String getBaseUrl() { // cannot be overridden
        return baseUrl;
    }
}
```

## 3. Best Practices & Pitfalls

- Use `static` for stateless utilities and shared constants, not for global mutable state.
- Prefer `public static final` constants in a constants class or interface (discouraged) but keep them cohesive.
- Avoid accessing instance members from static context; pass instances explicitly.
- `final` fields improve thread-safety by guaranteeing visibility after construction.
- Pitfall: `static` mutable fields can cause hidden coupling and test flakiness.

## 4. Summary

- `static` → class-level, shared; `final` → immutability/non-overridable.
- Use static for utilities and constants; keep mutable state instance-scoped.

## 5. Tricky Interview Questions

1. Can a `static` method be overridden? What actually happens with same signature?
2. Why is `public static void main(String[] args)` required to be static?
3. Explain when to use a static initialization block vs inline field init.
4. What are the JVM guarantees for `final` fields with respect to visibility?
5. How do you test code that relies on `static` global state reliably?
