## 1. Topic Overview

- `instanceof` checks if an object is an instance of a given type at runtime.
- With Java 16+, pattern matching for `instanceof` simplifies casting.
- Prefer polymorphism over explicit type checks where possible.

## 2. Deep Dive with Examples

### Beginner: Basic `instanceof`

```java
Object o = "hello";
if (o instanceof String) {
    String s = (String) o; // safe cast
    System.out.println(s.length());
}
```

### Intermediate: Pattern matching for `instanceof`

```java
Object shape = new java.awt.Point(1, 2);
if (shape instanceof java.awt.Point p) {
    System.out.println(p.x + "," + p.y);
}
```

### Advanced: Replace type checks with polymorphism

```java
abstract class Notification { abstract void send(); }
class Email extends Notification { void send() { /* ... */ } }
class SMS extends Notification { void send() { /* ... */ } }

// Bad: explicit type checks
void sendNotification(Notification n) {
    if (n instanceof Email) ((Email) n).send();
    else if (n instanceof SMS) ((SMS) n).send();
}

// Better: rely on polymorphism
void sendNotificationBetter(Notification n) { n.send(); }
```

## 3. Best Practices & Pitfalls

- Prefer virtual dispatch over chains of `instanceof`.
- Use pattern matching to reduce verbosity and casting errors.
- Avoid `instanceof` with unrelated types; it will always be false.
- Pitfall: `null instanceof Type` is always false.

## 4. Summary

- `instanceof` is useful but often replaceable with polymorphism.
- Pattern matching reduces boilerplate and improves readability.

## 5. Tricky Interview Questions

1. What does `null instanceof Object` evaluate to and why?
2. Show how pattern matching for `instanceof` prevents `ClassCastException`.
3. When is `instanceof` unavoidable? Give realistic examples.
4. How would you refactor multiple `instanceof` checks into polymorphism?
5. Explain how generics interact with `instanceof` and type erasure.
