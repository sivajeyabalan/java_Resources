## 1. Topic Overview

- Quick tour of patterns commonly discussed in Java interviews: Singleton, Factory, Strategy, Builder, Observer, Template Method, and Adapter.

## 2 . Topic definition

- WHAT: Reusable design solutions; each addresses a specific coupling/variation problem.
- WHY: Improve flexibility, testability, and clarity.
- HOW: Recognize variation points and encapsulate them behind interfaces/constructors.

## 3. Deep Dive with Examples

```java
// Singleton (enum is safest)
public enum AppConfig { INSTANCE; public String baseUrl(){ return "https://"; } }
```

```java
// Factory
interface Shape { void draw(); }
class Circle implements Shape { public void draw(){} }
class ShapeFactory { static Shape of(String t){ return switch(t){ case "circle" -> new Circle(); default -> throw new IllegalArgumentException(); }; } }
```

```java
// Strategy
interface Sorter { void sort(int[] a); }
class QuickSort implements Sorter { public void sort(int[] a){} }
class Context { private final Sorter s; Context(Sorter s){this.s=s;} void run(int[] a){ s.sort(a);} }
```

```java
// Builder
class User { private final String name; private final int age; private User(Builder b){ this.name=b.name; this.age=b.age; }
  static class Builder { String name; int age; Builder name(String n){this.name=n; return this;} Builder age(int a){this.age=a; return this;} User build(){ return new User(this);} } }
```

```java
// Observer (using listeners)
interface Listener { void onEvent(String e); }
class Publisher { java.util.List<Listener> ls = new java.util.ArrayList<>(); void add(Listener l){ls.add(l);} void publish(String e){ ls.forEach(l -> l.onEvent(e)); } }
```

```java
// Template Method
abstract class Task { final void run(){ setup(); execute(); teardown(); } abstract void execute(); void setup(){} void teardown(){} }
```

```java
// Adapter
class LegacyPayment { void pay(int cents){} }
interface Payment { void payDollars(int dollars); }
class LegacyPaymentAdapter implements Payment { private final LegacyPayment lp = new LegacyPayment(); public void payDollars(int dollars){ lp.pay(dollars*100); } }
```

## 4. Best Practices & Pitfalls

- Prefer composition over inheritance; avoid over-patterning.
- Use enum for Singleton; make dependencies explicit for testability.
- Document participants and responsibilities; keep examples small and focused.

## 5. Summary

- Know the intent and trade-offs; implement with clear interfaces and composition.

## 6. Tricky Interview Questions

1. When to pick Strategy over Template Method?
2. Pros/cons of enum Singleton vs double-checked locking.

