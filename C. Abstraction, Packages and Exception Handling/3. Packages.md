# Packages in Java

## 1. Topic Overview

Packages in Java are a mechanism for organizing related classes, interfaces, and sub-packages into a single namespace. They provide a way to group related functionality, avoid naming conflicts, and control access to classes and members. Packages are essential for building large-scale applications and are fundamental to Java's modular architecture.

Think of packages as folders in a file system that organize your code logically. Just like you organize files in folders on your computer, packages help organize Java classes into logical groups. They also provide access control and help avoid naming conflicts when multiple developers work on the same project.

## 2. Topic Definition

### Key Terms and Concepts

**Package**: A namespace that organizes a set of related classes and interfaces.

**Package Declaration**: The `package` statement at the beginning of a Java file.

**Import Statement**: Used to bring classes from other packages into the current namespace.

**Static Import**: A special type of import that allows importing static members.

**WHAT**: Packages are containers that organize Java classes and interfaces.

**WHY**: They provide namespace management, access control, and code organization.

**HOW**: Use `package` keyword to declare packages and `import` to use classes from other packages.

**WHEN/WHERE**: Use when building applications with multiple classes or when using third-party libraries.

**WHAT IF**: Without packages, you'd have naming conflicts and poor code organization.

**EXAMPLES**: `java.util`, `java.io`, `com.company.project` packages.

## 3. Deep Dive with Examples

### Basic Package Structure

```java
// File: com/company/employee/Employee.java
package com.company.employee;

public class Employee {
    private String name;
    private int id;
    private double salary;

    public Employee(String name, int id, double salary) {
        this.name = name;
        this.id = id;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    public double getSalary() {
        return salary;
    }

    public void displayInfo() {
        System.out.println("Employee: " + name + ", ID: " + id + ", Salary: " + salary);
    }
}
```

### Package with Multiple Classes

```java
// File: com/company/employee/Manager.java
package com.company.employee;

public class Manager extends Employee {
    private String department;
    private int teamSize;

    public Manager(String name, int id, double salary, String department, int teamSize) {
        super(name, id, salary);
        this.department = department;
        this.teamSize = teamSize;
    }

    public String getDepartment() {
        return department;
    }

    public int getTeamSize() {
        return teamSize;
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Department: " + department + ", Team Size: " + teamSize);
    }

    public void conductMeeting() {
        System.out.println("Manager " + getName() + " is conducting a team meeting");
    }
}

// File: com/company/employee/Developer.java
package com.company.employee;

public class Developer extends Employee {
    private String programmingLanguage;
    private int yearsOfExperience;

    public Developer(String name, int id, double salary, String programmingLanguage, int yearsOfExperience) {
        super(name, id, salary);
        this.programmingLanguage = programmingLanguage;
        this.yearsOfExperience = yearsOfExperience;
    }

    public String getProgrammingLanguage() {
        return programmingLanguage;
    }

    public int getYearsOfExperience() {
        return yearsOfExperience;
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Language: " + programmingLanguage + ", Experience: " + yearsOfExperience + " years");
    }

    public void writeCode() {
        System.out.println("Developer " + getName() + " is writing " + programmingLanguage + " code");
    }
}
```

### Using Import Statements

```java
// File: com/company/hr/HRSystem.java
package com.company.hr;

// Import specific classes
import com.company.employee.Employee;
import com.company.employee.Manager;
import com.company.employee.Developer;

// Import all classes from a package
import java.util.*;

public class HRSystem {
    private List<Employee> employees;

    public HRSystem() {
        this.employees = new ArrayList<>();
    }

    public void addEmployee(Employee employee) {
        employees.add(employee);
        System.out.println("Added employee: " + employee.getName());
    }

    public void displayAllEmployees() {
        System.out.println("=== All Employees ===");
        for (Employee emp : employees) {
            emp.displayInfo();
            System.out.println("---");
        }
    }

    public void calculateTotalSalary() {
        double total = 0;
        for (Employee emp : employees) {
            total += emp.getSalary();
        }
        System.out.println("Total salary expense: $" + total);
    }

    public void conductPerformanceReview() {
        System.out.println("=== Performance Review ===");
        for (Employee emp : employees) {
            if (emp instanceof Manager) {
                ((Manager) emp).conductMeeting();
            } else if (emp instanceof Developer) {
                ((Developer) emp).writeCode();
            }
        }
    }
}
```

### Static Import Examples

```java
// File: com/company/utils/MathUtils.java
package com.company.utils;

public class MathUtils {
    public static final double PI = 3.14159;
    public static final double E = 2.71828;

    public static double calculateCircleArea(double radius) {
        return PI * radius * radius;
    }

    public static double calculateRectangleArea(double length, double width) {
        return length * width;
    }

    public static int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
}

// File: com/company/calculator/Calculator.java
package com.company.calculator;

// Static import for constants and methods
import static com.company.utils.MathUtils.*;
import static java.lang.Math.*;

public class Calculator {

    public double calculateCircleArea(double radius) {
        // Using static import - no need for MathUtils.PI
        return PI * radius * radius;
    }

    public double calculateSphereVolume(double radius) {
        // Using static import from java.lang.Math
        return (4.0 / 3.0) * PI * pow(radius, 3);
    }

    public int calculateFactorial(int n) {
        // Using static import for custom method
        return factorial(n);
    }

    public double calculateCompoundInterest(double principal, double rate, int time) {
        // Using static import for Math methods
        return principal * pow(1 + rate, time);
    }
}
```

### Package Access Control

```java
// File: com/company/internal/InternalProcessor.java
package com.company.internal;

// Package-private class (no access modifier)
class InternalProcessor {
    private String processorName;

    InternalProcessor(String name) {
        this.processorName = name;
    }

    // Package-private method
    void processData(String data) {
        System.out.println("Processing " + data + " with " + processorName);
    }

    // Public method for external access
    public String getProcessorName() {
        return processorName;
    }
}

// File: com/company/internal/DataProcessor.java
package com.company.internal;

public class DataProcessor {
    private InternalProcessor processor;

    public DataProcessor(String processorName) {
        // Can access package-private class
        this.processor = new InternalProcessor(processorName);
    }

    public void process(String data) {
        // Can access package-private method
        processor.processData(data);
    }

    public String getProcessorInfo() {
        return "Processor: " + processor.getProcessorName();
    }
}

// File: com/company/public/PublicAPI.java
package com.company.public;

import com.company.internal.DataProcessor;

public class PublicAPI {
    private DataProcessor processor;

    public PublicAPI() {
        // Can access public class from different package
        this.processor = new DataProcessor("Main Processor");
    }

    public void handleRequest(String data) {
        System.out.println("Public API handling request...");
        processor.process(data);
        System.out.println("Request processed successfully");
    }
}
```

### Package with Interfaces

```java
// File: com/company/contracts/Displayable.java
package com.company.contracts;

public interface Displayable {
    void display();
    String getDisplayName();
}

// File: com/company/contracts/Comparable.java
package com.company.contracts;

public interface Comparable<T> {
    int compareTo(T other);
    boolean equals(T other);
}

// File: com/company/models/Product.java
package com.company.models;

import com.company.contracts.Displayable;
import com.company.contracts.Comparable;

public class Product implements Displayable, Comparable<Product> {
    private String name;
    private double price;
    private int id;

    public Product(String name, double price, int id) {
        this.name = name;
        this.price = price;
        this.id = id;
    }

    @Override
    public void display() {
        System.out.println("Product: " + name + ", Price: $" + price + ", ID: " + id);
    }

    @Override
    public String getDisplayName() {
        return name;
    }

    @Override
    public int compareTo(Product other) {
        return Double.compare(this.price, other.price);
    }

    @Override
    public boolean equals(Product other) {
        return this.id == other.id;
    }

    // Getters
    public String getName() { return name; }
    public double getPrice() { return price; }
    public int getId() { return id; }
}
```

## 4. Best Practices & Pitfalls

### Best Practices

1. **Use meaningful package names**: Follow reverse domain naming convention (com.company.project).

2. **Organize by functionality**: Group related classes together in the same package.

3. **Use appropriate access modifiers**: Make classes package-private when they're only used within the package.

4. **Avoid wildcard imports**: Import specific classes instead of using `import package.*` to avoid conflicts.

5. **Create package-info.java**: Document your packages with package-level documentation.

### Common Pitfalls

1. **Missing package declaration**:

   ```java
   // WRONG - Class without package declaration
   public class MyClass {
       // This goes to default package
   }

   // CORRECT - Always declare package
   package com.company.project;
   public class MyClass {
       // Properly organized
   }
   ```

2. **Import conflicts**:

   ```java
   // WRONG - Ambiguous import
   import java.util.*;
   import java.sql.*;
   // Both have Date class - causes conflict

   // CORRECT - Use fully qualified names or specific imports
   import java.util.Date;
   import java.sql.Timestamp;
   ```

3. **Circular dependencies**: Avoid packages that depend on each other.

4. **Not following naming conventions**: Use lowercase package names with dots as separators.

## 5. Summary

- Packages organize related classes and interfaces
- Use `package` keyword to declare package membership
- Use `import` to access classes from other packages
- Static imports allow importing static members
- Package-private access is the default access level
- Follow reverse domain naming convention
- Organize packages by functionality, not by technical layers
- Use package-info.java for documentation

## 6. Tricky Interview Questions

1. **What is the default package in Java?**

   - Classes without a package declaration belong to the default package, which has no name and should be avoided in production code.

2. **Can you have a class without a package declaration?**

   - Yes, but it goes to the default package, which is not recommended for production applications.

3. **What's the difference between `import java.util.*` and `import java.util.ArrayList`?**

   - The first imports all public classes from java.util, while the second imports only ArrayList. The first can cause naming conflicts.

4. **Can you import a class from the same package?**

   - No, classes in the same package are automatically available without import statements.

5. **What happens if you have two classes with the same name in different packages?**

   - You need to use fully qualified names or import one and use fully qualified name for the other.

6. **Can a package-private class be accessed from a subclass in a different package?**

   - No, package-private access is limited to the same package only.

7. **What is the purpose of the `import static` statement?**

   - It allows importing static members (methods and variables) from a class, so you can use them without the class name prefix.

8. **Can you have a package declaration after other statements in a Java file?**

   - No, the package declaration must be the first statement (after comments) in a Java file.

9. **What's the difference between `java.lang` package and other packages?**

   - Classes from `java.lang` package are automatically imported, so you don't need explicit import statements for them.

10. **Can you create a package with a name that starts with a number?**
    - No, package names must follow Java identifier rules and cannot start with a number.
