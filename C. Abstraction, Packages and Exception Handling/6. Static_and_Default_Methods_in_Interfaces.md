# Static and Default Methods in Interfaces

## 1. Topic Overview

Static and default methods in interfaces were introduced in Java 8 to enhance the functionality of interfaces while maintaining backward compatibility. These features allow interfaces to provide concrete implementations of methods, making them more powerful and flexible. Static methods provide utility functions related to the interface, while default methods provide default implementations that implementing classes can use or override.

Think of static and default methods as giving interfaces the ability to provide both utility functions and default behaviors. This is like having a toolbox (static methods) and a set of default instructions (default methods) that classes can use or customize as needed.

## 2. Topic Definition

### Key Terms and Concepts

**Static Methods in Interfaces**: Methods that belong to the interface itself and can be called without creating an instance.

**Default Methods**: Methods in interfaces that provide default implementations and can be overridden by implementing classes.

**Backward Compatibility**: The ability to add new methods to existing interfaces without breaking existing implementations.

**Diamond Problem**: A conflict that occurs when a class implements multiple interfaces with the same default method signature.

**WHAT**: Static and default methods allow interfaces to provide concrete implementations.

**WHY**: They enhance interface functionality while maintaining backward compatibility.

**HOW**: Use `static` keyword for static methods and `default` keyword for default methods.

**WHEN/WHERE**: Use static methods for utility functions and default methods for common implementations.

**WHAT IF**: Without these features, adding methods to interfaces would break existing code.

**EXAMPLES**: Comparator.comparing(), Collection.stream(), List.sort().

## 3. Deep Dive with Examples

### Static Methods in Interfaces

```java
// Interface with static methods
interface MathOperations {
    // Abstract method
    double calculate(double a, double b);

    // Static method - belongs to the interface
    static double add(double a, double b) {
        return a + b;
    }

    static double subtract(double a, double b) {
        return a - b;
    }

    static double multiply(double a, double b) {
        return a * b;
    }

    static double divide(double a, double b) {
        if (b == 0) {
            throw new IllegalArgumentException("Division by zero is not allowed");
        }
        return a / b;
    }

    // Static method that returns a comparator
    static java.util.Comparator<MathOperations> getComparator() {
        return (op1, op2) -> Double.compare(op1.calculate(10, 5), op2.calculate(10, 5));
    }
}

// Using static methods
class Calculator implements MathOperations {
    @Override
    public double calculate(double a, double b) {
        return MathOperations.add(a, b); // Using static method
    }

    public void demonstrateStaticMethods() {
        // Call static methods directly on interface
        System.out.println("Addition: " + MathOperations.add(10, 5));
        System.out.println("Subtraction: " + MathOperations.subtract(10, 5));
        System.out.println("Multiplication: " + MathOperations.multiply(10, 5));
        System.out.println("Division: " + MathOperations.divide(10, 5));
    }
}
```

### Default Methods in Interfaces

```java
// Interface with default methods
interface Vehicle {
    // Abstract methods
    void start();
    void stop();

    // Default method - provides default implementation
    default void honk() {
        System.out.println("Vehicle is honking!");
    }

    default void turnOnLights() {
        System.out.println("Vehicle lights are turned on");
    }

    default void turnOffLights() {
        System.out.println("Vehicle lights are turned off");
    }

    // Default method with parameters
    default void accelerate(int speed) {
        System.out.println("Vehicle is accelerating to " + speed + " km/h");
    }

    // Default method that calls other methods
    default void emergencyStop() {
        System.out.println("Emergency stop initiated!");
        stop();
        turnOnLights();
    }
}

// Implementing class that uses default methods
class Car implements Vehicle {
    private String brand;

    public Car(String brand) {
        this.brand = brand;
    }

    @Override
    public void start() {
        System.out.println(brand + " car is starting...");
    }

    @Override
    public void stop() {
        System.out.println(brand + " car is stopping...");
    }

    // Override default method
    @Override
    public void honk() {
        System.out.println(brand + " car is honking loudly!");
    }

    public void demonstrateDefaultMethods() {
        start();
        honk(); // Uses overridden version
        accelerate(60);
        turnOnLights();
        emergencyStop(); // Uses default implementation
    }
}

// Another implementing class
class Motorcycle implements Vehicle {
    private String model;

    public Motorcycle(String model) {
        this.model = model;
    }

    @Override
    public void start() {
        System.out.println(model + " motorcycle is starting...");
    }

    @Override
    public void stop() {
        System.out.println(model + " motorcycle is stopping...");
    }

    // Uses default implementation of honk()
    public void demonstrateDefaultMethods() {
        start();
        honk(); // Uses default implementation
        accelerate(80);
        turnOnLights();
    }
}
```

### Advanced Default Methods

```java
// Interface with complex default methods
interface DatabaseConnection {
    // Abstract methods
    void connect();
    void disconnect();
    void executeQuery(String query);

    // Default method with common functionality
    default void connectWithRetry(int maxRetries) {
        int attempts = 0;
        while (attempts < maxRetries) {
            try {
                connect();
                System.out.println("Connected successfully on attempt " + (attempts + 1));
                return;
            } catch (Exception e) {
                attempts++;
                if (attempts >= maxRetries) {
                    System.out.println("Failed to connect after " + maxRetries + " attempts");
                    throw new RuntimeException("Connection failed", e);
                }
                System.out.println("Connection attempt " + attempts + " failed, retrying...");
            }
        }
    }

    // Default method that provides logging
    default void executeQueryWithLogging(String query) {
        System.out.println("Executing query: " + query);
        long startTime = System.currentTimeMillis();

        try {
            executeQuery(query);
            long duration = System.currentTimeMillis() - startTime;
            System.out.println("Query executed successfully in " + duration + "ms");
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            System.out.println("Query failed after " + duration + "ms: " + e.getMessage());
            throw e;
        }
    }

    // Default method that provides transaction support
    default void executeInTransaction(java.util.List<String> queries) {
        System.out.println("Starting transaction with " + queries.size() + " queries");
        try {
            for (String query : queries) {
                executeQuery(query);
            }
            System.out.println("Transaction completed successfully");
        } catch (Exception e) {
            System.out.println("Transaction failed, rolling back: " + e.getMessage());
            throw new RuntimeException("Transaction failed", e);
        }
    }
}

// Implementation
class MySQLConnection implements DatabaseConnection {
    private String host;
    private boolean connected = false;

    public MySQLConnection(String host) {
        this.host = host;
    }

    @Override
    public void connect() {
        if (host.equals("error")) {
            throw new RuntimeException("Connection failed");
        }
        connected = true;
        System.out.println("Connected to MySQL at " + host);
    }

    @Override
    public void disconnect() {
        connected = false;
        System.out.println("Disconnected from MySQL");
    }

    @Override
    public void executeQuery(String query) {
        if (!connected) {
            throw new RuntimeException("Not connected to database");
        }
        System.out.println("Executing MySQL query: " + query);
    }
}
```

### Multiple Interface Inheritance with Default Methods

```java
// First interface
interface Flyable {
    void fly();

    default void takeOff() {
        System.out.println("Taking off...");
    }

    default void land() {
        System.out.println("Landing...");
    }

    default void emergencyLanding() {
        System.out.println("Emergency landing procedure initiated");
        land();
    }
}

// Second interface
interface Swimmable {
    void swim();

    default void dive() {
        System.out.println("Diving into water...");
    }

    default void surface() {
        System.out.println("Surfacing from water...");
    }

    default void emergencySurface() {
        System.out.println("Emergency surfacing procedure initiated");
        surface();
    }
}

// Third interface with conflicting default method
interface EmergencyProtocol {
    default void emergencyLanding() {
        System.out.println("Emergency protocol: Landing immediately");
    }

    default void emergencySurface() {
        System.out.println("Emergency protocol: Surfacing immediately");
    }
}

// Class implementing multiple interfaces
class Duck implements Flyable, Swimmable {
    private String name;

    public Duck(String name) {
        this.name = name;
    }

    @Override
    public void fly() {
        System.out.println(name + " is flying");
    }

    @Override
    public void swim() {
        System.out.println(name + " is swimming");
    }

    // No conflicts - both interfaces have different method names
    public void demonstrateAbilities() {
        takeOff();
        fly();
        land();
        dive();
        swim();
        surface();
    }
}

// Class with diamond problem
class AmphibiousVehicle implements Flyable, Swimmable, EmergencyProtocol {
    private String model;

    public AmphibiousVehicle(String model) {
        this.model = model;
    }

    @Override
    public void fly() {
        System.out.println(model + " is flying");
    }

    @Override
    public void swim() {
        System.out.println(model + " is swimming");
    }

    // Must resolve diamond problem by overriding conflicting methods
    @Override
    public void emergencyLanding() {
        System.out.println(model + " emergency landing - choosing air protocol");
        Flyable.super.emergencyLanding();
    }

    @Override
    public void emergencySurface() {
        System.out.println(model + " emergency surfacing - choosing water protocol");
        Swimmable.super.emergencySurface();
    }
}
```

### Static Methods with Generics

```java
// Generic interface with static methods
interface Comparator<T> {
    int compare(T o1, T o2);

    // Static method that creates a comparator
    static <T> Comparator<T> comparing(java.util.function.Function<T, Comparable> keyExtractor) {
        return (o1, o2) -> keyExtractor.apply(o1).compareTo(keyExtractor.apply(o2));
    }

    // Static method for reverse order
    static <T> Comparator<T> reverseOrder() {
        return (o1, o2) -> o2.compareTo(o1);
    }

    // Static method for null handling
    static <T> Comparator<T> nullsFirst(Comparator<T> comparator) {
        return (o1, o2) -> {
            if (o1 == null && o2 == null) return 0;
            if (o1 == null) return -1;
            if (o2 == null) return 1;
            return comparator.compare(o1, o2);
        };
    }
}

// Using static methods
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

// Usage example
class ComparatorExample {
    public static void main(String[] args) {
        java.util.List<Person> people = java.util.Arrays.asList(
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 20)
        );

        // Using static method to create comparator
        java.util.Comparator<Person> byName = Comparator.comparing(Person::getName);
        java.util.Comparator<Person> byAge = Comparator.comparing(Person::getAge);

        System.out.println("Sorted by name:");
        people.sort(byName);
        people.forEach(System.out::println);

        System.out.println("\nSorted by age:");
        people.sort(byAge);
        people.forEach(System.out::println);
    }
}
```

## 4. Best Practices & Pitfalls

### Best Practices

1. **Use static methods for utility functions**: Static methods should be related to the interface's purpose.

2. **Provide meaningful default implementations**: Default methods should provide sensible defaults that most implementations can use.

3. **Document default behavior**: Clearly document what default methods do and when to override them.

4. **Resolve diamond problems explicitly**: When multiple interfaces have the same default method, override it explicitly.

5. **Keep interfaces focused**: Don't add too many default methods that aren't related to the interface's core purpose.

### Common Pitfalls

1. **Diamond problem without resolution**:

   ```java
   // WRONG - This will cause compilation error
   class MyClass implements InterfaceA, InterfaceB {
       // Both interfaces have default method with same signature
       // Must override the method
   }

   // CORRECT - Resolve the conflict
   class MyClass implements InterfaceA, InterfaceB {
       @Override
       public void conflictingMethod() {
           InterfaceA.super.conflictingMethod(); // Choose one
       }
   }
   ```

2. **Overusing default methods**: Don't add default methods for every possible functionality.

3. **Not considering backward compatibility**: When adding default methods, ensure they don't break existing implementations.

## 5. Summary

- Static methods in interfaces provide utility functions related to the interface
- Default methods provide default implementations that can be overridden
- Static methods are called on the interface itself, not on instances
- Default methods help maintain backward compatibility when adding new methods
- Diamond problem occurs when multiple interfaces have the same default method
- Use `InterfaceName.super.methodName()` to call specific interface's default method
- Static and default methods make interfaces more powerful and flexible

## 6. Tricky Interview Questions

1. **Can you override a static method in an interface?**

   - No, static methods in interfaces cannot be overridden. They belong to the interface itself.

2. **What happens if two interfaces have the same default method signature?**

   - The implementing class must override the method to resolve the conflict, or you'll get a compilation error.

3. **Can you call a static method on an interface from an implementing class?**

   - Yes, but you need to use the interface name: `InterfaceName.staticMethod()`.

4. **What's the difference between static and default methods in interfaces?**

   - Static methods belong to the interface and cannot be overridden. Default methods provide default implementations that can be overridden.

5. **Can you have a static method and a default method with the same signature?**

   - No, you cannot have methods with the same signature but different modifiers in the same interface.

6. **What happens if you don't resolve a diamond problem?**

   - You'll get a compilation error saying the class must override the conflicting method.

7. **Can you call a default method from a static method in the same interface?**

   - No, static methods cannot call instance methods (including default methods) because they don't have access to `this`.

8. **What's the purpose of the `super` keyword with default methods?**

   - It allows you to call a specific interface's default method when there are multiple interfaces with the same method.

9. **Can you make a default method private?**

   - No, default methods must be public (or package-private in the same package).

10. **What happens if you override a default method but don't call the original?**
    - The original default method implementation is completely replaced by your override.
