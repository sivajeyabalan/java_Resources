# Abstract Classes in Java

## 1. Topic Overview

Abstract classes in Java are classes that cannot be instantiated directly and are designed to be extended by other classes. They serve as a blueprint for subclasses and can contain both abstract methods (methods without implementation) and concrete methods (methods with implementation). Abstract classes are a fundamental concept in object-oriented programming that enables code reusability and enforces a contract for subclasses.

Think of abstract classes as incomplete templates - they define the structure and some behavior, but leave certain methods to be implemented by their subclasses. This is particularly useful when you have a group of related classes that share common functionality but differ in specific behaviors.

## 2. Topic Definition

### Key Terms and Concepts

**Abstract Class**: A class declared with the `abstract` keyword that cannot be instantiated directly.

**Abstract Method**: A method declared without implementation (no method body) in an abstract class.

**Concrete Method**: A method with complete implementation in an abstract class.

**WHAT**: Abstract classes are incomplete classes that serve as templates for other classes.

**WHY**: They provide a way to define common functionality while forcing subclasses to implement specific behaviors.

**HOW**: Use the `abstract` keyword in class declaration and method signatures.

**WHEN/WHERE**: Use when you have related classes that share common behavior but differ in specific implementations.

**WHAT IF**: If you try to instantiate an abstract class directly, you'll get a compile-time error.

**EXAMPLES**: Shape class with abstract `calculateArea()` method, Animal class with abstract `makeSound()` method.

## 3. Deep Dive with Examples

### Basic Abstract Class Structure

```java
// Abstract class example
abstract class Vehicle {
    // Concrete instance variables
    protected String brand;
    protected int year;

    // Constructor (abstract classes can have constructors)
    public Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
    }

    // Concrete method - shared by all subclasses
    public void start() {
        System.out.println("Starting the " + brand + " vehicle...");
    }

    // Abstract method - must be implemented by subclasses
    abstract public void accelerate();
    abstract public void brake();

    // Concrete method
    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Year: " + year);
    }
}
```

### Implementing Abstract Classes

```java
// Concrete implementation of abstract class
class Car extends Vehicle {
    private int numberOfDoors;

    public Car(String brand, int year, int numberOfDoors) {
        super(brand, year); // Call parent constructor
        this.numberOfDoors = numberOfDoors;
    }

    // Must implement abstract methods
    @Override
    public void accelerate() {
        System.out.println("Car is accelerating by pressing gas pedal");
    }

    @Override
    public void brake() {
        System.out.println("Car is braking by pressing brake pedal");
    }

    // Additional methods specific to Car
    public void openTrunk() {
        System.out.println("Car trunk is opened");
    }
}

class Motorcycle extends Vehicle {
    private boolean hasWindshield;

    public Motorcycle(String brand, int year, boolean hasWindshield) {
        super(brand, year);
        this.hasWindshield = hasWindshield;
    }

    @Override
    public void accelerate() {
        System.out.println("Motorcycle is accelerating by twisting throttle");
    }

    @Override
    public void brake() {
        System.out.println("Motorcycle is braking by squeezing brake lever");
    }

    public void wheelie() {
        System.out.println("Motorcycle is doing a wheelie!");
    }
}
```

### Advanced Abstract Class Features

```java
abstract class Shape {
    protected String color;
    protected boolean filled;

    // Static variables in abstract class
    public static int shapeCount = 0;

    public Shape(String color, boolean filled) {
        this.color = color;
        this.filled = filled;
        shapeCount++;
    }

    // Abstract methods
    abstract double getArea();
    abstract double getPerimeter();

    // Concrete methods
    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public boolean isFilled() {
        return filled;
    }

    // Static method in abstract class
    public static int getShapeCount() {
        return shapeCount;
    }

    // Final method - cannot be overridden
    public final void displayShapeInfo() {
        System.out.println("Color: " + color + ", Filled: " + filled);
    }
}

class Circle extends Shape {
    private double radius;

    public Circle(String color, boolean filled, double radius) {
        super(color, filled);
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }

    public double getRadius() {
        return radius;
    }
}
```

### Abstract Class with Static and Final Members

```java
abstract class DatabaseConnection {
    // Static final variables (constants)
    public static final String DEFAULT_HOST = "localhost";
    public static final int DEFAULT_PORT = 3306;

    // Static variables
    private static int connectionCount = 0;

    // Instance variables
    protected String host;
    protected int port;
    protected boolean connected;

    public DatabaseConnection(String host, int port) {
        this.host = host;
        this.port = port;
        this.connected = false;
        connectionCount++;
    }

    // Abstract methods
    abstract boolean connect();
    abstract void disconnect();
    abstract void executeQuery(String query);

    // Static methods
    public static int getConnectionCount() {
        return connectionCount;
    }

    public static void resetConnectionCount() {
        connectionCount = 0;
    }

    // Final method
    public final boolean isConnected() {
        return connected;
    }

    // Concrete method
    public void displayConnectionInfo() {
        System.out.println("Host: " + host + ", Port: " + port + ", Connected: " + connected);
    }
}
```

## 4. Best Practices & Pitfalls

### Best Practices

1. **Use abstract classes when you have common functionality**: If multiple classes share common behavior, use abstract classes.

2. **Keep abstract methods minimal**: Don't over-abstract. Only make methods abstract if they truly need different implementations.

3. **Use meaningful names**: Abstract class and method names should clearly indicate their purpose.

4. **Provide default implementations**: Use concrete methods in abstract classes to provide common functionality.

5. **Use constructors wisely**: Abstract classes can have constructors, but they're called through subclass constructors.

### Common Pitfalls

1. **Trying to instantiate abstract classes**:

   ```java
   // WRONG - This will cause compilation error
   Vehicle vehicle = new Vehicle("Toyota", 2023);

   // CORRECT - Use concrete subclass
   Vehicle vehicle = new Car("Toyota", 2023, 4);
   ```

2. **Forgetting to implement abstract methods**:

   ```java
   // WRONG - This will cause compilation error
   class IncompleteCar extends Vehicle {
       // Missing implementation of abstract methods
   }
   ```

3. **Using abstract classes when interfaces would be better**: If you only need to define contracts without shared implementation, consider interfaces.

4. **Over-abstracting**: Don't make every method abstract. Provide concrete implementations where appropriate.

## 5. Summary

- Abstract classes cannot be instantiated directly
- They can contain both abstract and concrete methods
- Subclasses must implement all abstract methods
- Abstract classes can have constructors, static methods, and final methods
- They support instance variables and can have access modifiers
- Use abstract classes when you need to share common functionality among related classes
- Abstract classes provide a middle ground between concrete classes and interfaces

## 6. Tricky Interview Questions

1. **Can an abstract class have a constructor? If yes, why would you need one?**

   - Yes, abstract classes can have constructors. They're used to initialize instance variables and are called through subclass constructors using `super()`.

2. **What happens if a subclass doesn't implement all abstract methods?**

   - The subclass must also be declared as abstract, or you'll get a compilation error.

3. **Can an abstract class have static methods? Can they be abstract?**

   - Yes, abstract classes can have static methods, but static methods cannot be abstract because they belong to the class, not instances.

4. **Can you have a final abstract method?**

   - No, you cannot have a final abstract method because final methods cannot be overridden, but abstract methods must be overridden.

5. **What's the difference between an abstract class and a regular class with all methods having empty implementations?**

   - Abstract classes enforce implementation through compilation errors, while regular classes with empty methods don't provide this enforcement.

6. **Can an abstract class implement an interface?**

   - Yes, abstract classes can implement interfaces. They can provide implementations for some or all interface methods.

7. **What happens if you try to call an abstract method from within the abstract class itself?**

   - You'll get a compilation error because abstract methods have no implementation to call.

8. **Can an abstract class extend another abstract class?**

   - Yes, abstract classes can extend other abstract classes. The subclass can choose to implement some, all, or none of the abstract methods.

9. **Is it possible to have an abstract class with no abstract methods?**

   - Yes, but it's generally not recommended as it defeats the purpose of using abstract classes.

10. **Can you declare an abstract class as final?**
    - No, you cannot declare an abstract class as final because final classes cannot be extended, but abstract classes are meant to be extended.
