# Interfaces in Java

## 1. Topic Overview

Interfaces in Java are reference types that define a contract for classes to implement. They specify what methods a class must implement without providing the implementation details. Interfaces are a powerful mechanism for achieving abstraction and multiple inheritance in Java, allowing classes to define their behavior through contracts rather than inheritance.

Think of interfaces as blueprints or contracts that specify what a class can do, but not how it does it. They enable loose coupling between components and make code more flexible and maintainable. Interfaces are essential for building modular, testable, and extensible applications.

## 2. Topic Definition

### Key Terms and Concepts

**Interface**: A reference type that contains only constants, method signatures, default methods, static methods, and nested types.

**Contract**: A specification that defines what methods a class must implement.

**Multiple Inheritance**: The ability of a class to implement multiple interfaces.

**Marker Interface**: An interface with no methods, used to mark classes with special properties.

**WHAT**: Interfaces define contracts that classes must follow.

**WHY**: They enable abstraction, multiple inheritance, and loose coupling.

**HOW**: Use the `interface` keyword and implement interfaces using `implements` keyword.

**WHEN/WHERE**: Use when you need to define contracts, achieve multiple inheritance, or create loosely coupled systems.

**WHAT IF**: If a class doesn't implement all interface methods, it must be declared abstract.

**EXAMPLES**: Comparable, Serializable, Runnable interfaces in Java API.

## 3. Deep Dive with Examples

### Basic Interface Structure

```java
// Basic interface definition
interface Drawable {
    // Constants (implicitly public, static, final)
    String DEFAULT_COLOR = "black";
    int DEFAULT_THICKNESS = 1;

    // Abstract methods (implicitly public and abstract)
    void draw();
    void setColor(String color);
    String getColor();
}

// Interface implementation
class Circle implements Drawable {
    private String color;
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
        this.color = DEFAULT_COLOR;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " circle with radius " + radius);
    }

    @Override
    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String getColor() {
        return color;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle implements Drawable {
    private String color;
    private double width, height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
        this.color = DEFAULT_COLOR;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " rectangle " + width + "x" + height);
    }

    @Override
    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String getColor() {
        return color;
    }

    public double getArea() {
        return width * height;
    }
}
```

### Multiple Interface Implementation

```java
// Multiple interfaces
interface Flyable {
    void fly();
    int getMaxAltitude();
}

interface Swimmable {
    void swim();
    int getMaxDepth();
}

interface Runnable {
    void run();
    int getMaxSpeed();
}

// Class implementing multiple interfaces
class Duck implements Flyable, Swimmable, Runnable {
    private String name;
    private int currentAltitude;
    private int currentDepth;
    private int currentSpeed;

    public Duck(String name) {
        this.name = name;
    }

    // Flyable interface implementation
    @Override
    public void fly() {
        currentAltitude = 100;
        System.out.println(name + " is flying at altitude " + currentAltitude);
    }

    @Override
    public int getMaxAltitude() {
        return 1000;
    }

    // Swimmable interface implementation
    @Override
    public void swim() {
        currentDepth = 5;
        System.out.println(name + " is swimming at depth " + currentDepth);
    }

    @Override
    public int getMaxDepth() {
        return 50;
    }

    // Runnable interface implementation
    @Override
    public void run() {
        currentSpeed = 10;
        System.out.println(name + " is running at speed " + currentSpeed);
    }

    @Override
    public int getMaxSpeed() {
        return 20;
    }

    public void quack() {
        System.out.println(name + " says quack!");
    }
}
```

### Interface Inheritance and Extension

```java
// Base interface
interface Animal {
    void eat();
    void sleep();
    String getName();
}

// Extended interface
interface Pet extends Animal {
    void play();
    void beFriendly();
}

// Another interface
interface Guard {
    void protect();
    void bark();
}

// Class implementing extended interface and another interface
class Dog implements Pet, Guard {
    private String name;
    private String breed;

    public Dog(String name, String breed) {
        this.name = name;
        this.breed = breed;
    }

    // Animal interface methods
    @Override
    public void eat() {
        System.out.println(name + " is eating dog food");
    }

    @Override
    public void sleep() {
        System.out.println(name + " is sleeping on the couch");
    }

    @Override
    public String getName() {
        return name;
    }

    // Pet interface methods
    @Override
    public void play() {
        System.out.println(name + " is playing fetch");
    }

    @Override
    public void beFriendly() {
        System.out.println(name + " is wagging tail and being friendly");
    }

    // Guard interface methods
    @Override
    public void protect() {
        System.out.println(name + " is protecting the house");
    }

    @Override
    public void bark() {
        System.out.println(name + " says Woof! Woof!");
    }

    public String getBreed() {
        return breed;
    }
}
```

### Marker Interfaces

```java
// Marker interface - no methods defined
interface Serializable {
    // Empty interface - used as a marker
}

// Another marker interface
interface Cloneable {
    // Empty interface - indicates the object can be cloned
}

// Class using marker interfaces
class Document implements Serializable, Cloneable {
    private String content;
    private String title;

    public Document(String title, String content) {
        this.title = title;
        this.content = content;
    }

    public String getContent() {
        return content;
    }

    public String getTitle() {
        return title;
    }

    // Cloneable marker interface allows this method
    @Override
    public Object clone() throws CloneNotSupportedException {
        return new Document(this.title, this.content);
    }
}
```

### Interface with Constants and Nested Types

```java
interface DatabaseConfig {
    // Constants
    String DEFAULT_HOST = "localhost";
    int DEFAULT_PORT = 3306;
    String DEFAULT_USERNAME = "root";
    String DEFAULT_PASSWORD = "";

    // Nested interface
    interface ConnectionPool {
        int getMaxConnections();
        void setMaxConnections(int max);
    }

    // Nested enum
    enum DatabaseType {
        MYSQL, POSTGRESQL, ORACLE, SQLSERVER
    }

    // Methods
    void connect();
    void disconnect();
    DatabaseType getDatabaseType();
}

// Implementation
class MySQLDatabase implements DatabaseConfig {
    private String host;
    private int port;
    private DatabaseType type;

    public MySQLDatabase(String host, int port) {
        this.host = host;
        this.port = port;
        this.type = DatabaseType.MYSQL;
    }

    @Override
    public void connect() {
        System.out.println("Connecting to MySQL at " + host + ":" + port);
    }

    @Override
    public void disconnect() {
        System.out.println("Disconnecting from MySQL");
    }

    @Override
    public DatabaseType getDatabaseType() {
        return type;
    }
}
```

## 4. Best Practices & Pitfalls

### Best Practices

1. **Use interfaces for contracts**: Define what a class should do, not how it should do it.

2. **Keep interfaces focused**: Each interface should have a single responsibility.

3. **Use meaningful names**: Interface names should clearly indicate their purpose (often ending with -able or -er).

4. **Prefer composition over inheritance**: Use interfaces to achieve flexibility.

5. **Document interface contracts**: Clearly document what implementing classes should do.

### Common Pitfalls

1. **Trying to instantiate interfaces directly**:

   ```java
   // WRONG - Interfaces cannot be instantiated
   Drawable drawable = new Drawable();

   // CORRECT - Use implementing class
   Drawable drawable = new Circle(5.0);
   ```

2. **Not implementing all interface methods**:

   ```java
   // WRONG - This will cause compilation error
   class IncompleteShape implements Drawable {
       // Missing implementation of interface methods
   }
   ```

3. **Using interfaces when abstract classes would be better**: If you need to share common implementation, consider abstract classes.

4. **Over-engineering with too many interfaces**: Don't create interfaces for everything; use them when you need contracts.

## 5. Summary

- Interfaces define contracts that classes must implement
- Classes can implement multiple interfaces
- Interfaces can extend other interfaces
- All interface methods are implicitly public and abstract
- All interface variables are implicitly public, static, and final
- Marker interfaces have no methods and are used for marking
- Interfaces enable multiple inheritance and loose coupling
- Use interfaces to define what a class should do, not how

## 6. Tricky Interview Questions

1. **Can an interface have instance variables?**

   - No, interfaces can only have constants (public, static, final variables).

2. **Can an interface extend a class?**

   - No, interfaces can only extend other interfaces.

3. **What happens if a class implements an interface but doesn't implement all methods?**

   - The class must be declared as abstract, or you'll get a compilation error.

4. **Can an interface have constructors?**

   - No, interfaces cannot have constructors because they cannot be instantiated.

5. **What's the difference between an interface and an abstract class?**

   - Interfaces can only have abstract methods (before Java 8), while abstract classes can have both abstract and concrete methods. A class can implement multiple interfaces but extend only one class.

6. **Can an interface be declared as final?**

   - No, interfaces cannot be final because they are meant to be implemented by classes.

7. **What is a marker interface? Give examples.**

   - A marker interface is an interface with no methods, used to mark classes with special properties. Examples: Serializable, Cloneable.

8. **Can an interface have private methods?**

   - Yes, starting from Java 9, interfaces can have private methods.

9. **What happens if two interfaces have methods with the same signature?**

   - If a class implements both interfaces, it only needs to implement the method once since they have the same signature.

10. **Can an interface have static methods?**
    - Yes, starting from Java 8, interfaces can have static methods with implementation.
