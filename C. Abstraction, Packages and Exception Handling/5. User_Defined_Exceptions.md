# User-Defined Exceptions in Java

## 1. Topic Overview

User-defined exceptions in Java are custom exception classes that you create to handle specific error conditions in your application. While Java provides many built-in exceptions, sometimes you need to create your own exceptions to represent business logic errors or application-specific problems that aren't covered by standard exceptions.

Think of user-defined exceptions as your own error codes or error messages. Just like how different companies have their own error codes for different problems, you can create custom exceptions to represent specific errors that are unique to your application's domain.

## 2. Topic Definition

### Key Terms and Concepts

**User-Defined Exception**: A custom exception class created by the developer to handle specific application errors.

**Business Logic Exception**: An exception that represents a violation of business rules.

**Application-Specific Exception**: An exception that represents errors unique to your application domain.

**Exception Chaining**: The practice of wrapping one exception inside another to preserve the original error information.

**WHAT**: Custom exception classes that extend Java's exception hierarchy.

**WHY**: To handle application-specific errors that aren't covered by built-in exceptions.

**HOW**: Create classes that extend Exception or RuntimeException and use throw keyword.

**WHEN/WHERE**: Use when you need to represent specific business logic errors or application-specific problems.

**WHAT IF**: Without custom exceptions, you'd have to use generic exceptions with unclear error messages.

**EXAMPLES**: InsufficientFundsException, InvalidAgeException, DuplicateUserException.

## 3. Deep Dive with Examples

### Basic User-Defined Exception

```java
// Custom checked exception
class InsufficientFundsException extends Exception {
    private double amount;
    private double balance;

    public InsufficientFundsException(double amount, double balance) {
        super("Insufficient funds. Required: $" + amount + ", Available: $" + balance);
        this.amount = amount;
        this.balance = balance;
    }

    public double getAmount() {
        return amount;
    }

    public double getBalance() {
        return balance;
    }

    public double getShortfall() {
        return amount - balance;
    }
}

// Custom unchecked exception
class InvalidAgeException extends RuntimeException {
    private int age;

    public InvalidAgeException(int age) {
        super("Invalid age: " + age + ". Age must be between 0 and 150.");
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}

// Using custom exceptions
class BankAccount {
    private String accountNumber;
    private double balance;

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        }

        if (amount > balance) {
            throw new InsufficientFundsException(amount, balance);
        }

        balance -= amount;
        System.out.println("Withdrawn $" + amount + ". New balance: $" + balance);
    }

    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }

        balance += amount;
        System.out.println("Deposited $" + amount + ". New balance: $" + balance);
    }

    public double getBalance() {
        return balance;
    }
}
```

### Advanced User-Defined Exceptions

```java
// Exception with additional context
class DuplicateUserException extends Exception {
    private String username;
    private String email;
    private String existingUserId;

    public DuplicateUserException(String username, String email, String existingUserId) {
        super("User already exists with username: " + username + " or email: " + email);
        this.username = username;
        this.email = email;
        this.existingUserId = existingUserId;
    }

    public String getUsername() {
        return username;
    }

    public String getEmail() {
        return email;
    }

    public String getExistingUserId() {
        return existingUserId;
    }

    public String getSuggestion() {
        return "Try using username: " + username + "_" + System.currentTimeMillis();
    }
}

// Exception with error codes
class ValidationException extends Exception {
    private String fieldName;
    private String errorCode;
    private Object invalidValue;

    public ValidationException(String fieldName, String errorCode, Object invalidValue, String message) {
        super(message);
        this.fieldName = fieldName;
        this.errorCode = errorCode;
        this.invalidValue = invalidValue;
    }

    public String getFieldName() {
        return fieldName;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public Object getInvalidValue() {
        return invalidValue;
    }

    public String getFormattedMessage() {
        return String.format("Validation failed for field '%s': %s (Code: %s, Value: %s)",
                           fieldName, getMessage(), errorCode, invalidValue);
    }
}

// Using advanced exceptions
class UserRegistration {
    private java.util.Set<String> existingUsernames = new java.util.HashSet<>();
    private java.util.Set<String> existingEmails = new java.util.HashSet<>();

    public void registerUser(String username, String email, int age)
            throws DuplicateUserException, ValidationException {

        // Validate username
        if (username == null || username.trim().isEmpty()) {
            throw new ValidationException("username", "EMPTY_USERNAME", username,
                                       "Username cannot be empty");
        }

        if (username.length() < 3) {
            throw new ValidationException("username", "SHORT_USERNAME", username,
                                       "Username must be at least 3 characters");
        }

        // Validate email
        if (email == null || !email.contains("@")) {
            throw new ValidationException("email", "INVALID_EMAIL", email,
                                       "Email must contain @ symbol");
        }

        // Validate age
        if (age < 0 || age > 150) {
            throw new ValidationException("age", "INVALID_AGE", age,
                                       "Age must be between 0 and 150");
        }

        // Check for duplicates
        if (existingUsernames.contains(username)) {
            throw new DuplicateUserException(username, email, "USER_" + username.hashCode());
        }

        if (existingEmails.contains(email)) {
            throw new DuplicateUserException(username, email, "USER_" + email.hashCode());
        }

        // Register user
        existingUsernames.add(username);
        existingEmails.add(email);
        System.out.println("User registered successfully: " + username);
    }
}
```

### Exception Chaining and Wrapping

```java
// Custom exception that wraps other exceptions
class DatabaseOperationException extends Exception {
    private String operation;
    private String tableName;

    public DatabaseOperationException(String operation, String tableName, Throwable cause) {
        super("Database operation failed: " + operation + " on table " + tableName, cause);
        this.operation = operation;
        this.tableName = tableName;
    }

    public String getOperation() {
        return operation;
    }

    public String getTableName() {
        return tableName;
    }
}

// Exception with multiple causes
class CompositeException extends Exception {
    private java.util.List<Exception> causes = new java.util.ArrayList<>();

    public CompositeException(String message) {
        super(message);
    }

    public void addCause(Exception cause) {
        causes.add(cause);
    }

    public java.util.List<Exception> getCauses() {
        return new java.util.ArrayList<>(causes);
    }

    @Override
    public String getMessage() {
        StringBuilder sb = new StringBuilder(super.getMessage());
        if (!causes.isEmpty()) {
            sb.append("\nCauses:");
            for (int i = 0; i < causes.size(); i++) {
                sb.append("\n  ").append(i + 1).append(". ").append(causes.get(i).getMessage());
            }
        }
        return sb.toString();
    }
}

// Using exception chaining
class DatabaseService {
    public void saveUser(String username, String email) throws DatabaseOperationException {
        try {
            // Simulate database operation that might fail
            if (username == null) {
                throw new IllegalArgumentException("Username cannot be null");
            }

            // Simulate connection error
            if (username.equals("error")) {
                throw new java.sql.SQLException("Connection lost");
            }

            System.out.println("User saved: " + username);

        } catch (IllegalArgumentException e) {
            // Wrap in custom exception
            throw new DatabaseOperationException("INSERT", "users", e);
        } catch (java.sql.SQLException e) {
            // Wrap in custom exception
            throw new DatabaseOperationException("INSERT", "users", e);
        }
    }
}
```

### Business Logic Exceptions

```java
// Inventory management exceptions
class OutOfStockException extends Exception {
    private String productId;
    private int requestedQuantity;
    private int availableQuantity;

    public OutOfStockException(String productId, int requestedQuantity, int availableQuantity) {
        super("Product " + productId + " is out of stock. Requested: " + requestedQuantity +
              ", Available: " + availableQuantity);
        this.productId = productId;
        this.requestedQuantity = requestedQuantity;
        this.availableQuantity = availableQuantity;
    }

    public String getProductId() {
        return productId;
    }

    public int getRequestedQuantity() {
        return requestedQuantity;
    }

    public int getAvailableQuantity() {
        return availableQuantity;
    }
}

class InvalidDiscountException extends Exception {
    private double discountPercentage;
    private double maxAllowedDiscount;

    public InvalidDiscountException(double discountPercentage, double maxAllowedDiscount) {
        super("Invalid discount: " + discountPercentage + "%. Maximum allowed: " + maxAllowedDiscount + "%");
        this.discountPercentage = discountPercentage;
        this.maxAllowedDiscount = maxAllowedDiscount;
    }

    public double getDiscountPercentage() {
        return discountPercentage;
    }

    public double getMaxAllowedDiscount() {
        return maxAllowedDiscount;
    }
}

// Using business logic exceptions
class InventoryManager {
    private java.util.Map<String, Integer> inventory = new java.util.HashMap<>();
    private double maxDiscountPercentage = 50.0;

    public InventoryManager() {
        inventory.put("LAPTOP001", 10);
        inventory.put("MOUSE001", 50);
        inventory.put("KEYBOARD001", 25);
    }

    public void processOrder(String productId, int quantity, double discountPercentage)
            throws OutOfStockException, InvalidDiscountException {

        // Check inventory
        Integer available = inventory.get(productId);
        if (available == null) {
            throw new OutOfStockException(productId, quantity, 0);
        }

        if (quantity > available) {
            throw new OutOfStockException(productId, quantity, available);
        }

        // Check discount
        if (discountPercentage > maxDiscountPercentage) {
            throw new InvalidDiscountException(discountPercentage, maxDiscountPercentage);
        }

        // Process order
        inventory.put(productId, available - quantity);
        System.out.println("Order processed: " + quantity + " units of " + productId +
                          " with " + discountPercentage + "% discount");
    }
}
```

### Exception with Custom Messages and Localization

```java
// Exception with localized messages
class LocalizedException extends Exception {
    private String errorCode;
    private Object[] parameters;

    public LocalizedException(String errorCode, Object... parameters) {
        super(getLocalizedMessage(errorCode, parameters));
        this.errorCode = errorCode;
        this.parameters = parameters;
    }

    private static String getLocalizedMessage(String errorCode, Object... parameters) {
        // In a real application, this would use ResourceBundle
        switch (errorCode) {
            case "USER_NOT_FOUND":
                return String.format("User not found: %s", parameters);
            case "INVALID_CREDENTIALS":
                return "Invalid username or password";
            case "ACCOUNT_LOCKED":
                return String.format("Account locked for %s minutes", parameters);
            default:
                return "Unknown error: " + errorCode;
        }
    }

    public String getErrorCode() {
        return errorCode;
    }

    public Object[] getParameters() {
        return parameters.clone();
    }
}

// Using localized exceptions
class AuthenticationService {
    public void authenticate(String username, String password) throws LocalizedException {
        if (username == null || username.trim().isEmpty()) {
            throw new LocalizedException("USER_NOT_FOUND", username);
        }

        if (!isValidCredentials(username, password)) {
            throw new LocalizedException("INVALID_CREDENTIALS");
        }

        if (isAccountLocked(username)) {
            throw new LocalizedException("ACCOUNT_LOCKED", 30);
        }

        System.out.println("Authentication successful for: " + username);
    }

    private boolean isValidCredentials(String username, String password) {
        // Simulate credential validation
        return "admin".equals(username) && "password".equals(password);
    }

    private boolean isAccountLocked(String username) {
        // Simulate account lock check
        return false;
    }
}
```

## 4. Best Practices & Pitfalls

### Best Practices

1. **Extend appropriate base class**: Extend Exception for checked exceptions, RuntimeException for unchecked.

2. **Provide meaningful constructors**: Include relevant context in exception constructors.

3. **Add useful methods**: Include getter methods for exception-specific data.

4. **Use descriptive names**: Exception class names should clearly indicate the problem.

5. **Include context information**: Store relevant data that helps with debugging.

### Common Pitfalls

1. **Creating exceptions for every small error**:

   ```java
   // WRONG - Over-engineering
   class EmptyStringException extends Exception { }
   class NullStringException extends Exception { }

   // CORRECT - Use standard exceptions when appropriate
   if (str == null) {
       throw new IllegalArgumentException("String cannot be null");
   }
   ```

2. **Not providing useful information**:

   ```java
   // WRONG - Not helpful
   class MyException extends Exception {
       public MyException() {
           super("Error occurred");
       }
   }

   // CORRECT - Include context
   class MyException extends Exception {
       public MyException(String operation, String reason) {
           super("Operation '" + operation + "' failed: " + reason);
       }
   }
   ```

3. **Forgetting to handle checked exceptions**: Always handle or declare checked exceptions.

## 5. Summary

- User-defined exceptions extend Exception or RuntimeException
- Provide meaningful constructors and useful methods
- Include context information for better debugging
- Use exception chaining to preserve original error information
- Create exceptions for business logic errors and application-specific problems
- Use descriptive names and meaningful error messages
- Don't over-engineer - use standard exceptions when appropriate

## 6. Tricky Interview Questions

1. **When should you create a checked exception vs unchecked exception?**

   - Use checked exceptions for recoverable errors that callers should handle (IOException). Use unchecked exceptions for programming errors (NullPointerException).

2. **Can you throw an exception from a constructor?**

   - Yes, but if the constructor throws a checked exception, all constructors in the class must declare it.

3. **What happens if you don't handle a checked exception?**

   - You'll get a compilation error. You must either handle it with try-catch or declare it with throws.

4. **Can you have a custom exception without any fields or methods?**

   - Yes, but it's not very useful. Include relevant information to help with debugging.

5. **What's the difference between creating a new exception and reusing an existing one?**

   - Custom exceptions provide specific context and can include domain-specific information, while reusing existing exceptions is simpler but less informative.

6. **Can you catch a user-defined exception with a generic Exception catch block?**

   - Yes, but you'll lose the specific exception information. Catch specific exceptions first.

7. **What happens if you throw an exception from a finally block?**

   - The exception from the finally block will mask any exception from the try or catch blocks.

8. **Can you create an exception that extends Error instead of Exception?**

   - Yes, but it's not recommended as Errors indicate serious problems that usually cannot be recovered from.

9. **What's the purpose of exception chaining?**

   - Exception chaining preserves the original error information while adding context about where the error occurred.

10. **Can you have multiple catch blocks for the same exception type?**
    - No, you cannot have multiple catch blocks for the same exception type in the same try block.
