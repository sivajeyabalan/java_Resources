## 1. Topic Overview

Boot makes building web apps easy: define controllers, map routes with `@GetMapping`/`@PostMapping`, and return views or `ResponseEntity` for REST responses.

## 2 . Topic definition

- **@Controller / @RestController**: MVC vs REST endpoints.
- **@RequestMapping** family: Map paths, HTTP methods, consumes/produces.
- **ResponseEntity**: Full control over status, headers, and body.

## 3. Deep Dive with Examples

REST controller:
```java
@RestController
@RequestMapping("/api")
class ApiController {
  @GetMapping(value="/hello", produces = MediaType.TEXT_PLAIN_VALUE)
  ResponseEntity<String> hello(){
    return ResponseEntity.ok().header("X-App","boot").body("Hello");
  }

  @PostMapping(value="/echo", consumes = MediaType.APPLICATION_JSON_VALUE)
  ResponseEntity<Map<String,Object>> echo(@RequestBody Map<String,Object> in){
    return ResponseEntity.status(HttpStatus.CREATED).body(in);
  }
}
```

MVC controller with view:
```java
@Controller
class PageController {
  @GetMapping("/home")
  String home(Model m){ m.addAttribute("title","Home"); return "home"; }
}
```

## 4. Best Practices & Pitfalls

- Return proper status codes; use `ResponseEntity` for REST.
- Validate request bodies with `@Valid` and handle errors centrally.
- Pitfall: Missing `produces/consumes` causing 415/406 errors.

## 5. Summary

- Use annotations to map routes; `ResponseEntity` controls REST responses.

## 6. Tricky Interview Questions

1) How does content negotiation determine response format?
2) How to create a global header applied to all responses?
