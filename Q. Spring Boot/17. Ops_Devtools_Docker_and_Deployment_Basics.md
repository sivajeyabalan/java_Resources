## 1. Topic Overview

- Developer productivity and deployment: Devtools for live reload, containerizing with Docker, and deployment basics.

## 2 . Topic definition

- WHAT: Spring Boot Devtools, layered jars, Dockerfiles, container memory/CPU tuning.
- WHY: Faster feedback locally, reproducible deployments.
- HOW: Add devtools dependency, create Dockerfile with layered jars, configure JVM flags.
- WHEN/WHERE: Local development and production deployments.
- WHAT IF: Exposing devtools in prod is risky; oversized images slow deployments.

## 3. Deep Dive with Examples

```xml
<!-- pom.xml -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-devtools</artifactId>
  <optional>true</optional>
  </dependency>
```

```dockerfile
# Dockerfile
FROM eclipse-temurin:21-jre
ARG JAR=app.jar
COPY target/*.jar /app.jar
ENTRYPOINT ["java","-XX:+UseZGC","-Xms256m","-Xmx512m","-jar","/app.jar"]
```

```properties
# application.properties (prod hints)
server.shutdown=graceful
management.endpoints.web.exposure.include=health,metrics
```

## 4. Best Practices & Pitfalls

- Use layered jars or buildpacks to leverage Docker layer caching.
- Configure graceful shutdown and readiness/liveness probes.
- Externalize config with profiles and environment variables.

## 5. Summary

- Devtools accelerates dev; Docker ensures consistent deployments; tune JVM and app settings for prod.

## 6. Tricky Interview Questions

1. How do buildpacks differ from Dockerfiles for Spring Boot?
2. What JVM/container settings matter most for memory-constrained environments?

