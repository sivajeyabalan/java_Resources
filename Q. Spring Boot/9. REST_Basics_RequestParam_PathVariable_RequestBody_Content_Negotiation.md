## 1. Topic Overview

Spring Boot simplifies building REST APIs using `@RestController`, request mapping annotations, and automatic JSON/XML serialization with content negotiation.

## 2 . Topic definition

- **@RequestParam**: Bind query params/form fields.
- **@PathVariable**: Bind URI template variables.
- **@RequestBody**: Bind request body (JSON/XML) to an object.
- **Content negotiation**: Chooses response media type based on `Accept` header and configuration.

## 3. Deep Dive with Examples

```java
@RestController
@RequestMapping("/api/users")
class UserApi {
  @GetMapping
  List<User> find(@RequestParam(defaultValue = "0") int page) { return svc.find(page); }

  @GetMapping("/{id}")
  User one(@PathVariable long id) { return svc.get(id); }

  @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE)
  ResponseEntity<User> create(@RequestBody @Valid UserCreate req) {
    User saved = svc.create(req);
    return ResponseEntity.status(HttpStatus.CREATED).body(saved);
  }
}
```

Content negotiation examples:
- Client sets `Accept: application/json` → JSON
- Or `Accept: application/xml` with Jackson XML/ JAXB on classpath → XML

Force produces:
```java
@GetMapping(value="/status", produces = MediaType.TEXT_PLAIN_VALUE)
String status(){ return "OK"; }
```

## 4. Best Practices & Pitfalls

- Validate inputs with Bean Validation; return proper status codes (201 for create, 204 for delete).
- Version APIs; keep DTOs distinct from entities.
- Pitfall: Relying on default message converters without required dependencies (e.g., XML).

## 5. Summary

- Bind params, path vars, and bodies with annotations; use content negotiation to serve proper media types.

## 6. Tricky Interview Questions

1) How does Spring choose an `HttpMessageConverter` for a request/response?
2) Difference between `@RequestParam` and `@PathVariable` in REST design?
