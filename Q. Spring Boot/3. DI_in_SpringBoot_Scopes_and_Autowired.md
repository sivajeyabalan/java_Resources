## 1. Topic Overview

Spring Boot uses the same IoC/DI container as Spring. Beans are discovered via component scanning and wired via constructor injection and `@Autowired`.

## 2 . Topic definition

- **Component scan**: Auto-detect `@Component` stereotypes in base package.
- **Autowired**: Resolve and inject dependencies; works with constructors/setters/parameters.
- **Scopes**: `singleton` (default), `prototype`, and web scopes in MVC apps.

## 3. Deep Dive with Examples

```java
@SpringBootApplication
public class App {}

@Service class GreetingService { String greet(String n){ return "Hello " + n; } }
@RestController
class GreetingController {
  private final GreetingService svc;
  GreetingController(GreetingService svc){ this.svc = svc; }
  @GetMapping("/greet") String greet(@RequestParam String name){ return svc.greet(name); }
}
```

Qualifier:
```java
interface Msg {}
@Component("a") class A implements Msg {}
@Component("b") class B implements Msg {}
@RestController class Ctl { Ctl(@Qualifier("b") Msg m){} }
```

## 4. Best Practices & Pitfalls

- Prefer constructor injection; it works well with Boot’s auto-configured beans.
- Keep controller constructors small; push logic to services.
- Pitfall: Component scanning base package misconfigured—beans not found.

## 5. Summary

- Boot leverages Spring DI: component scan + constructor injection + qualifiers/profiles.

## 6. Tricky Interview Questions

1) How does Boot determine component scan base packages by default?
2) How do you override or extend auto-configured beans cleanly?
