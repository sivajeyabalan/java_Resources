## 1. Topic Overview

Spring Boot is an opinionated layer on top of Spring that eliminates boilerplate by providing auto-configuration, embedded servers, and convention-over-configuration. It accelerates building production-ready applications with minimal setup.

## 2 . Topic definition

- **WHAT**: Spring + auto-configuration + starters + embedded server + Actuator.
- **WHY**: Reduce configuration, start quickly, consistent defaults, production features.
- **HOW**: Add starter dependencies; `@SpringBootApplication` bootstraps auto-config; run with an embedded server.
- **WHEN/WHERE**: Microservices, APIs, web apps, CLIs—where quick setup and self-contained apps help.
- **WHAT IF**: You can override auto-config via properties/beans; falls back to manual Spring if needed.
- **EXAMPLES**: `spring-boot-starter-web` auto-configures MVC + Tomcat.

## 3. Deep Dive with Examples

Typical layers in a Boot MVC app:
- Controller (web layer)
- Service (business logic)
- Repository (data access)

Request flow: Client → Embedded server (Tomcat/Jetty/Undertow) → DispatcherServlet → Controller → Service/Repository → DB → Response.

Minimal app:
```java
@SpringBootApplication
public class App { public static void main(String[] args){ SpringApplication.run(App.class, args); } }

@RestController
class HelloController {
  @GetMapping("/hello") String hello() { return "Hello Boot"; }
}
```

## 4. Best Practices & Pitfalls

- Start with starters; add dependencies sparingly; prefer properties over code when possible.
- Keep layers thin and testable; avoid business logic in controllers.
- Pitfall: Fighting auto-config—learn conditions and customize properly.

## 5. Summary

- Boot streamlines Spring with auto-config, starters, and embedded servers, following layered MVC flow.

## 6. Tricky Interview Questions

1) How does Spring Boot auto-configuration decide what to configure?
2) How to exclude an auto-configuration and supply custom beans?
