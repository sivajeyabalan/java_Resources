## 1. Topic Overview

- End-to-end observability: instrument with Micrometer, scrape with Prometheus, visualize with Grafana.

## 2 . Topic definition

- WHAT: Metrics registry abstraction (Micrometer) + Prometheus exporter via Actuator + Grafana dashboards.
- WHY: Monitor latency, errors, throughput, and resource usage.
- HOW: Add Actuator + Micrometer Prometheus registry, configure `/actuator/prometheus`, set Prometheus job, import Grafana dashboards.

## 3. Deep Dive with Examples

```xml
<!-- pom.xml -->
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-registry-prometheus</artifactId>
  </dependency>
```

```properties
management.endpoints.web.exposure.include=health,metrics,prometheus
```

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'spring'
    static_configs:
      - targets: ['host.docker.internal:8080']
    metrics_path: /actuator/prometheus
```

## 4. Best Practices & Pitfalls

- Control metric cardinality; avoid unbounded label values.
- Add timing to critical operations with `@Timed` or manual timers.
- Secure metrics endpoint as needed.

## 5. Summary

- Micrometer + Prometheus + Grafana provides portable, production-grade observability for Spring Boot apps.

## 6. Tricky Interview Questions

1. What causes high-cardinality metrics and how to avoid them?
2. How do you correlate traces/logs with metrics for incident debugging?

