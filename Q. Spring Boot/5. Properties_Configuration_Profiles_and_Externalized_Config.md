## 1. Topic Overview

Spring Boot centralizes configuration in `application.properties` or `application.yml`, supports profiles for environment-specific overrides, and binds properties into strongly-typed beans.

## 2 . Topic definition

- **application.properties/yml**: Default config loaded from classpath and external locations.
- **Profiles**: `spring.profiles.active` selects `application-{profile}.yml`.
- **@ConfigurationProperties**: Type-safe binding into POJOs.
- **Externalized config**: Env vars, system props, command-line args, config files.

## 3. Deep Dive with Examples

application.yml:
```yaml
server:
  port: 8081
spring:
  profiles:
    active: dev
app:
  title: Demo
  cache:
    enabled: true
```

Profile-specific:
```yaml
# application-dev.yml
logging:
  level:
    root: DEBUG

# application-prod.yml
server:
  port: 8080
```

Type-safe binding:
```java
@ConfigurationProperties(prefix = "app")
public record AppProps(String title, Cache cache) { public record Cache(boolean enabled) {} }

@Configuration
@EnableConfigurationProperties(AppProps.class)
class Cfg {}

@RestController class Ctl { Ctl(AppProps p){} }
```

External overrides:
- CLI: `--server.port=9000`
- Env var: `SPRING_APPLICATION_NAME=myapp`

## 4. Best Practices & Pitfalls

- Keep secrets out of repos; use env vars or vaults.
- Validate config with `@Validated` on `@ConfigurationProperties` classes.
- Pitfall: Mixing `.properties` and `.yml` with conflicting keys.

## 5. Summary

- Use YAML/properties, profiles, and `@ConfigurationProperties` for clean, portable config.

## 6. Tricky Interview Questions

1) How does property binding precedence work across sources?
2) When to choose profiles vs dedicated `PropertySource`s?
