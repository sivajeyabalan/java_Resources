## 1. Topic Overview

Spring Data JPA reduces boilerplate via repository interfaces. Derived query methods generate JPQL from method names; custom queries are supported.

## 2 . Topic definition

- **CrudRepository/JpaRepository**: Generic CRUD/repository operations.
- **Derived queries**: Method names like `findByNameStartingWith` → JPQL.
- **@Query**: Custom queries (JPQL or native SQL).

## 3. Deep Dive with Examples

Entity & repository:
```java
@Entity class Customer { @Id @GeneratedValue Long id; String name; String city; }
public interface CustomerRepo extends JpaRepository<Customer, Long> {
  List<Customer> findByCity(String city);
  List<Customer> findByNameStartingWithOrderByNameAsc(String prefix);
  @Query("select c from Customer c where lower(c.name) like lower(concat(:p,'%'))")
  List<Customer> search(@Param("p") String p);
}
```

Usage:
```java
@Service class CustomerService { private final CustomerRepo repo; CustomerService(CustomerRepo r){this.repo=r;}
  public List<Customer> inCity(String c){ return repo.findByCity(c); }
}
```

## 4. Best Practices & Pitfalls

- Keep method names readable; switch to `@Query` when names get unwieldy.
- Use DTO projections for performance when not returning entities.
- Pitfall: N+1 on relationships—use `@EntityGraph` or fetch joins.

## 5. Summary

- Repositories provide rapid data access; derived and custom queries cover most needs.

## 6. Tricky Interview Questions

1) How are derived queries parsed and translated to JPQL?
2) When to choose projections vs returning entities?
