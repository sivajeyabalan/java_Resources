## 1. Topic Overview

- Document REST APIs with OpenAPI/Swagger and auto-generate clients for consistency and speed.

## 2 . Topic definition

- WHAT: springdoc-openapi integration exposes `/v3/api-docs` and Swagger UI.
- WHY: Clear contracts, discoverability, and tooling for testing and client generation.
- HOW: Add springdoc dependency, annotate controllers, expose Swagger UI, generate clients via OpenAPI Generator.
- WHEN/WHERE: All public/internal APIs.
- WHAT IF: Stale docs cause confusionâ€”use runtime generation tied to code.

## 3. Deep Dive with Examples

```xml
<!-- pom.xml -->
<dependency>
  <groupId>org.springdoc</groupId>
  <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
  <version>2.5.0</version>
  </dependency>
```

```java
import io.swagger.v3.oas.annotations.Operation;
import org.springframework.web.bind.annotation.*;

@RestController
class BookController {
    @Operation(summary = "Get book by id")
    @GetMapping("/books/{id}")
    public String get(@PathVariable long id) { return "ok"; }
}
```

```bash
# Client generation example (CLI)
openapi-generator generate -i http://localhost:8080/v3/api-docs -g java -o client
```

## 4. Best Practices & Pitfalls

- Keep annotations minimal; rely on auto-scanning; use `@Schema` for complex models.
- Version APIs and docs; secure Swagger UI in production.

## 5. Summary

- OpenAPI + springdoc provides live documentation and client generation paths.

## 6. Tricky Interview Questions

1. Differences between code-first and spec-first approaches.
2. How to secure and version OpenAPI docs in production?

