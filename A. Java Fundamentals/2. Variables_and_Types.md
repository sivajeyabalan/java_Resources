## 1. Topic Overview

- Java has two broad categories: **primitive types** and **reference types**.
- Primitives store values directly; references point to objects on the heap.
- Correct typing improves safety and performance.

## 2. Deep Dive with Examples

### Primitive Types

- Integral: `byte` (8), `short` (16), `int` (32), `long` (64)
- Floating: `float` (32), `double` (64)
- Others: `char` (16, Unicode), `boolean` (true/false)

```java
public class PrimitivesDemo {
    public static void main(String[] args) {
        int age = 28;
        long big = 10_000_000_000L; // suffix L for long
        float ratio = 3.14f;        // suffix f for float
        double price = 19.99;
        char grade = 'A';
        boolean active = true;

        System.out.println(age + ", " + big + ", " + ratio + ", " + price + ", " + grade + ", " + active);
    }
}
```

### Reference Types

- Classes, arrays, interfaces, enums; default value is `null`.

```java
public class ReferenceDemo {
    static class User { String name; }

    public static void main(String[] args) {
        User u = new User();
        u.name = "Ada";
        User v = u; // both references point to the same object
        v.name = "Grace";
        System.out.println(u.name); // Grace
    }
}
```

### Type Casting and Literals

```java
public class CastingDemo {
    public static void main(String[] args) {
        double d = 9.7;
        int n = (int) d; // narrowing cast, n = 9
        long t = 100;    // widening cast (implicit)

        System.out.println(n + ", " + t);
    }
}
```

## 3. Best Practices & Pitfalls

- Use the smallest type that fits but prefer `int` for arithmetic unless you need `long`.
- Beware of overflow on `int` when summing large counts; consider `long`.
- Avoid `==` for strings; use `.equals` to compare content.
- Initialize variables close to their use; avoid unnecessary `null`s.

## 4. Mini Exercises

- Declare variables for a product: id (`long`), name (`String`), price (`double`), inStock (`boolean`).
- Demonstrate string content comparison using `equals` and `equalsIgnoreCase`.
- Cast a `double` to `int` and observe truncation.

## 5. Summary

- Primitives hold values; references hold addresses to objects.
- Widening conversions are safe; narrowing requires explicit casts.
- Prefer `equals` for object content comparison, not `==`.

## 6. Tricky Interview Questions


## 1. Why is 0.1 + 0.2 != 0.3 in binary floating point?
<details>
<summary>Answer</summary>

- **Reason:** `0.1` and `0.2` cannot be represented exactly in binary floating point (IEEE 754 double). Tiny rounding errors occur.
- **Example:**
```java
System.out.println(0.1 + 0.2 == 0.3); // false
````

* **Safe comparison:** Use a tolerance (epsilon):

```java
final double EPS = 1e-9;
double sum = 0.1 + 0.2;
System.out.println(Math.abs(sum - 0.3) < EPS); // true
```

</details>

## 2. What happens when `byte b = 130;` compiles?

<details>
<summary>Answer</summary>

* `byte` range: -128 to 127. 130 exceeds this → **compilation error** unless explicitly cast.
* Narrowing example with overflow:

```java
byte b = (byte)130;
System.out.println(b); // -126 (overflow)
```

* Explanation: 130 - 256 = -126 (wrap-around due to 8-bit byte)

</details>

## 3. Autoboxing pitfalls

<details>
<summary>Answer</summary>

* Integers between -128 and 127 are **cached** by JVM.

```java
Integer a = 128, b = 128;
System.out.println(a == b); // false (different objects)

Integer c = 127, d = 127;
System.out.println(c == d); // true (cached)
```

* Use `.equals()` for value comparison.

</details>

## 4. `String s = null; s instanceof String` result?

<details>
<summary>Answer</summary>

```java
String s = null;
System.out.println(s instanceof String); // false
```

* **Reason:** `instanceof` returns `false` if the reference is null. Safe way to check type.

</details>

## 5. final reference vs object immutability

<details>
<summary>Answer</summary>

* **final reference:** Cannot point to another object, but object can be mutable.

```java
final List<Integer> list = new ArrayList<>();
list.add(1); // allowed
// list = new ArrayList<>(); // not allowed
```

* **Immutable object:** Object’s state cannot change, even if reference is non-final.

```java
String s = "Hello";
s = s.concat(" World"); // creates new object, original immutable
```

* **Summary:** `final` protects the reference; immutability protects the object’s internal state.

</details>
```
