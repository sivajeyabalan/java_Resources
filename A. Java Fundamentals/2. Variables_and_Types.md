## 1. Topic Overview

- Java has two broad categories: **primitive types** and **reference types**.
- Primitives store values directly; references point to objects on the heap.
- Correct typing improves safety and performance.

## 2. Deep Dive with Examples

### Primitive Types

- Integral: `byte` (8), `short` (16), `int` (32), `long` (64)
- Floating: `float` (32), `double` (64)
- Others: `char` (16, Unicode), `boolean` (true/false)

```java
public class PrimitivesDemo {
    public static void main(String[] args) {
        int age = 28;
        long big = 10_000_000_000L; // suffix L for long
        float ratio = 3.14f;        // suffix f for float
        double price = 19.99;
        char grade = 'A';
        boolean active = true;

        System.out.println(age + ", " + big + ", " + ratio + ", " + price + ", " + grade + ", " + active);
    }
}
```

### Reference Types

- Classes, arrays, interfaces, enums; default value is `null`.

```java
public class ReferenceDemo {
    static class User { String name; }

    public static void main(String[] args) {
        User u = new User();
        u.name = "Ada";
        User v = u; // both references point to the same object
        v.name = "Grace";
        System.out.println(u.name); // Grace
    }
}
```

### Type Casting and Literals

```java
public class CastingDemo {
    public static void main(String[] args) {
        double d = 9.7;
        int n = (int) d; // narrowing cast, n = 9
        long t = 100;    // widening cast (implicit)

        System.out.println(n + ", " + t);
    }
}
```

## 3. Best Practices & Pitfalls

- Use the smallest type that fits but prefer `int` for arithmetic unless you need `long`.
- Beware of overflow on `int` when summing large counts; consider `long`.
- Avoid `==` for strings; use `.equals` to compare content.
- Initialize variables close to their use; avoid unnecessary `null`s.

## 4. Mini Exercises

- Declare variables for a product: id (`long`), name (`String`), price (`double`), inStock (`boolean`).
- Demonstrate string content comparison using `equals` and `equalsIgnoreCase`.
- Cast a `double` to `int` and observe truncation.

## 5. Summary

- Primitives hold values; references hold addresses to objects.
- Widening conversions are safe; narrowing requires explicit casts.
- Prefer `equals` for object content comparison, not `==`.

## 6. Tricky Interview Questions

- Why is `0.1 + 0.2 != 0.3` in binary floating point? How to compare safely?
- What happens when `byte b = 130;` compiles? Explain narrowing and overflow.
- Autoboxing pitfalls: `Integer a = 128, b = 128; a==b?` vs `Integer c = 127, d = 127; a==b?`
- `String s = null; s instanceof String` result? Why?
- Explain `final` reference vs object immutability with examples.
