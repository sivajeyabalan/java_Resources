## 1. Topic Overview

- Arrays store fixed-size sequences; Collections provide dynamic data structures (`List`, `Set`, `Map`).
- Start with arrays, then prefer collections for flexibility and utilities.

## 2. Deep Dive with Examples

```java
import java.util.*;

public class ArraysCollectionsIntro {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        System.out.println(nums[1]); // 2

        List<String> names = new ArrayList<>();
        names.add("A"); names.add("B");
        // forEach using method reference
        names.forEach(System.out::println);

        Set<String> unique = new HashSet<>(names);
        unique.add("A"); // no effect, set keeps unique elements
        System.out.println(unique.size());

        Map<String, Integer> counts = new HashMap<>();
        counts.put("apples", 3);
        counts.put("oranges", 2);
        System.out.println(counts.getOrDefault("bananas", 0)); // 0
    }
}
```

### Sorting: Serial vs Parallel

```java
import java.util.*;

public class SortingDemo {
    public static void main(String[] args) {
        int[] a = new Random().ints(100_000).toArray();
        int[] b = Arrays.copyOf(a, a.length);

        long t1 = System.nanoTime();
        Arrays.sort(a); // serial sort
        long t2 = System.nanoTime();

        Arrays.parallelSort(b); // parallel sort using ForkJoinPool.commonPool()
        long t3 = System.nanoTime();

        System.out.printf("serial=%.2fms, parallel=%.2fms%n", (t2-t1)/1e6, (t3-t2)/1e6);
    }
}
```

|Feature|Serial Sort (`Arrays.sort`)|Parallel Sort (`Arrays.parallelSort`)|
|---|---|---|
|Threads used|Single thread|Multiple threads (ForkJoinPool)|
|Algorithm|Dual-Pivot Quicksort (primitives), TimSort (objects)|Parallel Merge Sort|
|Best for|Small/medium arrays|Large arrays, multi-core systems|
|Time complexity|O(n log n)|O(n log n) (parallelized)|
|Memory usage|Low (in-place)|Higher (needs buffers for merging)|
|Java version|Since Java 1.2|Since Java 8|

Guidance:

- Prefer `parallelSort` for large arrays on multi-core machines when CPU-bound and data is in memory.
- For small arrays or when threads are constrained, `Arrays.sort` can be faster and more predictable.

## 3. Best Practices & Pitfalls

- Prefer `List` over arrays for most app code; arrays shine in fixed-size, performance-critical paths.
- Use interfaces (`List`, `Set`, `Map`) on variables/parameters, concrete classes on instantiation.
- Be careful with `Arrays.asList` (fixed-size list view over array).
  - To get a mutable list: `new ArrayList<>(Arrays.asList(arr))`.

## 4. Mini Exercises

- Convert an array of integers to a `List<Integer>` and back.
- Count word frequencies from an array using a `Map<String,Integer>`.
- Remove duplicates from a list using a `Set`.

## 5. Summary

- Arrays are fixed-size; collections are flexible and feature-rich.
- Favor collection interfaces and utility methods for productivity.

## 6. Tricky Interview Questions

- Why does `Arrays.asList` not support `add/remove`? How to get a mutable list?
- Hash-based collections: why must `equals` and `hashCode` be consistent? Show a bug.
- Iteration removal: why does removing during for-each throw `ConcurrentModificationException`?
- `parallelSort` pitfalls when common pool is saturated; how to control parallelism?
- Ordering guarantees: `HashSet` vs `LinkedHashSet` vs `TreeSet` differences.
