## 1. Topic Overview

- JPMS (modules) provides strong encapsulation and reliable configuration for large Java applications.

## 2 . Topic definition

- WHAT: Modules with `module-info.java` declaring requires/exports/opens.
- WHY: Control visibility across modules, reduce classpath hell, enable jlink images.
- HOW: Create `module-info.java`, declare dependencies/exports; use `opens` for reflection (e.g., frameworks).
- WHEN/WHERE: Large apps, libraries, or when building custom runtimes.
- WHAT IF: Missing `opens` breaks reflection; split packages not allowed.

## 3. Deep Dive with Examples

```java
// module-info.java
module com.example.app {
  requires java.sql;
  exports com.example.api;
  opens com.example.entity to jakarta.persistence; // for reflection
}
```

## 4. Best Practices & Pitfalls

- Avoid split packages; keep clear boundaries.
- Use `opens` narrowly; prefer compile-time exports.
- Consider multi-release jars and automatic modules for migration.

## 5. Summary

- JPMS strengthens encapsulation and deployment; essential for large-scale modularity.

## 6. Tricky Interview Questions

1. Difference between `exports` and `opens` and when to use each?
2. How do automatic/modules on the classpath help migration?

