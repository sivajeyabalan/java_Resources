## 1. Topic Overview

- Object-Oriented Programming organizes software around objects: state (fields) and behavior (methods).
- Core pillars: Encapsulation, Inheritance, Polymorphism, Abstraction.

## 2. Deep Dive with Examples

### Encapsulation with Getters/Setters

```java
public class BankAccount {
    private final String accountNumber;
    private double balance;

    public BankAccount(String accountNumber, double openingBalance) {
        this.accountNumber = accountNumber;
        this.balance = openingBalance;
    }

    public String getAccountNumber() { return accountNumber; }
    public double getBalance() { return balance; }
    public void deposit(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Amount must be > 0");
        balance += amount;
    }
    public boolean withdraw(double amount) {
        if (amount <= 0 || amount > balance) return false;
        balance -= amount; return true;
    }
}
```

### Inheritance and Polymorphism

```java
abstract class Shape { abstract double area(); }
class Circle extends Shape { private final double r; Circle(double r){this.r=r;} double area(){return Math.PI*r*r;} }
class Rect extends Shape { private final double w,h; Rect(double w,double h){this.w=w;this.h=h;} double area(){return w*h;} }

public class PolyDemo {
    public static void main(String[] args) {
        Shape s1 = new Circle(2.0);
        Shape s2 = new Rect(3.0, 4.0);
        System.out.println(s1.area());
        System.out.println(s2.area());
    }
}
```

## 3. Best Practices & Pitfalls

- Favor composition over inheritance unless an "is-a" relationship is clear.
- Keep fields private; expose minimal, meaningful methods.
- Use `final` for immutable fields and prefer immutable objects where possible.

## 4. Mini Exercises

- Create a `Vehicle` superclass and `Car`/`Bike` subclasses with a `speed()` method.
- Implement an `Employee` class with validation in setters.
- Write a small hierarchy `Animal` â†’ `Dog`, `Cat` and demonstrate polymorphism.

## 5. Summary

- OOP models real-world entities with state and behavior.
- Encapsulation protects invariants; inheritance and polymorphism enable reuse and flexibility.

## 6. Tricky Interview Questions

- Composition over inheritance: refactor a brittle inheritance hierarchy.
- Covariant return types: when is overriding with a narrowed return allowed?
- Accessor exposure: how can getters leak mutability? Show safe patterns.
- Why prefer `equals`/`hashCode` consistency in entities? Consequences if broken.
- Final classes vs open hierarchies: trade-offs for libraries and APIs.
