## 1. Topic Overview

- **JDK**: Developer toolkit that includes the compiler (`javac`), tools, and the JRE.
- **JRE**: Runtime environment containing the **JVM** plus core libraries to run Java apps.
- **JVM**: Executes Java bytecode, manages memory (heap/stack), and performs garbage collection.
- Flow: `.java` (source) → `javac` → `.class` (bytecode) → `java` (JVM executes).

## 2. Deep Dive with Examples

### Compile and Run

```bash
javac Main.java
java Main
```

```java
// File: Main.java
public class Main {
    public static void main(String[] args) {
        System.out.println("Java is platform independent via JVM!");
    }
}
```

### JIT Compiler and Execution

- The Just-In-Time (JIT) compiler compiles hot bytecode paths into native machine code at runtime for speed.
- Modern JVMs also use profiling and optimizations (inlining, escape analysis) to accelerate execution.

### Class Loader and Bytecode Verifier

- Class Loaders (bootstrap, platform, application) load classes on demand from classpath/modulepath.
- The Bytecode Verifier checks code safety (stack discipline, type safety) before execution.

### JVM Memory Model (High Level)

- Method Area: class metadata, static variables, constants.
- Heap: objects live here; garbage collected.
- Stack: frames for method calls, local variables, references.

### PATH vs CLASSPATH (Quick Guide)

- PATH: lets your OS find executables like `java` and `javac`.
- CLASSPATH: tells the JVM where to find classes/jars at runtime/compile-time.
  - Example (Windows PowerShell): `setx CLASSPATH ".;C:\\libs\\my.jar"`
  - Prefer command-line flags: `javac -cp libs/* MyApp.java` and `java -cp .;libs/* MyApp`.

## 3. Best Practices & Pitfalls

- **Use an LTS JDK** (e.g., 17/21) for production stability.
- **Match tools**: Use the same `javac` and `java` from one JDK version.
- **Set JAVA_HOME** and update PATH to avoid version confusion.
- Avoid mixing vendor distributions without understanding differences (e.g., Oracle vs. OpenJDK).

## 4. Mini Exercises

- Compile and run a simple program printing the Java version using `System.getProperty("java.version")`.
- Describe the roles of JDK, JRE, and JVM in 2–3 lines each.
- Draw a simple diagram of the JVM memory areas.
- Print the class loader of a known class (e.g., `String.class.getClassLoader()`) and explain the output.
- Demonstrate PATH vs CLASSPATH by running with/without `-cp`.

## 5. Summary

- **JDK** = tools + compiler + JRE; **JRE** = JVM + libraries; **JVM** runs bytecode.
- Compilation produces `.class` files which the JVM executes on any supported platform.
- Understanding the memory areas helps reason about performance and errors.

## 6. Tricky Interview Questions

- Why can two different class loaders load the “same” class name and still be considered different types?
- Difference between `ClassNotFoundException` and `NoClassDefFoundError` with scenarios.
- How does the bytecode verifier ensure type safety? What would it reject?
- What is the impact of escape analysis on object allocation and synchronization?
- When does JIT compile a method, and what optimizations can deopt trigger?
- PATH vs CLASSPATH: show a subtle failure caused by wrong classpath ordering.
