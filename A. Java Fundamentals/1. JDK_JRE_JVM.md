## 1. Topic Overview

- **JDK**: Developer toolkit that includes the compiler (`javac`), tools, and the JRE.
- **JRE**: Runtime environment containing the **JVM** plus core libraries to run Java apps.
- **JVM**: Executes Java bytecode, manages memory (heap/stack), and performs garbage collection.
- Flow: `.java` (source) → `javac` → `.class` (bytecode) → `java` (JVM executes).

## 2. Deep Dive with Examples

### Compile and Run

```bash
javac Main.java
java Main
```

```java
// File: Main.java
public class Main {
    public static void main(String[] args) {
        System.out.println("Java is platform independent via JVM!");
    }
}
```

### JIT Compiler and Execution

- The Just-In-Time (JIT) compiler compiles hot bytecode paths into native machine code at runtime for speed.
- Modern JVMs also use profiling and optimizations (inlining, escape analysis) to accelerate execution.

### Class Loader and Bytecode Verifier

- Class Loaders (bootstrap, platform, application) load classes on demand from classpath/modulepath.
- The Bytecode Verifier checks code safety (stack discipline, type safety) before execution.

              [Bootstrap ClassLoader]
                        ↑
                        │
              [Platform/Extension ClassLoader]
                        ↑
                        │
              [Application (System) ClassLoader]
                        ↑
                        │
                 Your Program Classes

### JVM Memory Model (High Level)

- Method Area: class metadata, static variables, constants.
- Heap: objects live here; garbage collected.
- Stack: frames for method calls, local variables, references.

```
┌───────────────────────────────┐
│         Method Area           │  ← class metadata, static vars, constant pool
└───────────────────────────────┘
┌───────────────────────────────┐
│             Heap              │  ← objects
│   ┌──────────────┐            │
│   │ Young Gen    │            │
│   │  (Eden+S0+S1)│            │
│   └──────────────┘            │
│   ┌──────────────┐            │
│   │ Old Gen      │            │
│   └──────────────┘            │
└───────────────────────────────┘
┌───────────────────────────────┐
│   Per-thread Areas            │
│   ┌──────────────┐            │
│   │ Java Stack   │ ← local vars│
│   ├──────────────┤            │
│   │ PC Register  │            │
│   ├──────────────┤            │
│   │ Native Stack │            │
│   └──────────────┘            │
└───────────────────────────────┘
```

## java memory model 

```
                ┌─────────────────────────┐
                │       Main Memory       │
                │ (shared across threads) │
                └───────────┬─────────────┘
                            │
      ┌─────────────────────┼─────────────────────┐
      │                     │                     │
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│ Thread 1       │     │ Thread 2       │     │ Thread 3       │
│ Working Memory │     │ Working Memory │     │ Working Memory │
│  (local copy)  │     │  (local copy)  │     │  (local copy)  │
└───────────────┘     └───────────────┘     └───────────────┘

   ↕ sync/volatile needed for visibility + ordering

```

### PATH vs CLASSPATH (Quick Guide)

- PATH: lets your OS find executables like `java` and `javac`.
- CLASSPATH: tells the JVM where to find classes/jars at runtime/compile-time.
  - Example (Windows PowerShell): `setx CLASSPATH ".;C:\\libs\\my.jar"`
  - Prefer command-line flags: `javac -cp libs/* MyApp.java` and `java -cp .;libs/* MyApp`.

## 3. Best Practices & Pitfalls

- **Use an LTS JDK** (e.g., 17/21) for production stability.
- **Match tools**: Use the same `javac` and `java` from one JDK version.
- **Set JAVA_HOME** and update PATH to avoid version confusion.
- Avoid mixing vendor distributions without understanding differences (e.g., Oracle vs. OpenJDK).

## 4. Mini Exercises

- Compile and run a simple program printing the Java version using `System.getProperty("java.version")`.
- Describe the roles of JDK, JRE, and JVM in 2–3 lines each.
- Draw a simple diagram of the JVM memory areas.
- Print the class loader of a known class (e.g., `String.class.getClassLoader()`) and explain the output.
- Demonstrate PATH vs CLASSPATH by running with/without `-cp`.

## 5. Summary

- **JDK** = tools + compiler + JRE; **JRE** = JVM + libraries; **JVM** runs bytecode.
- Compilation produces `.class` files which the JVM executes on any supported platform.
- Understanding the memory areas helps reason about performance and errors.

## 6. Tricky Interview Questions

- Why can two different class loaders load the “same” class name and still be considered different types?
<details> <summary>Ans</summary>Two classes with the same name are considered different if loaded by different class loaders because JVM defines a class uniquely by (ClassName + ClassLoader).</details>
<br>

- Difference between `ClassNotFoundException` and `NoClassDefFoundError` with scenarios.
Got it! Here’s a **short and crisp version**:

---

<details>
  <summary>ClassNotFoundException vs NoClassDefFoundError</summary>

* **ClassNotFoundException**

  * Checked exception.
  * Occurs **when dynamically loading** a class (`Class.forName`) that’s missing.
  * Example:

  ```java
  Class.forName("com.example.MissingClass"); // throws exception
  ```

* **NoClassDefFoundError**

  * Unchecked error.
  * Occurs **when JVM cannot find a class that existed at compile-time**.
  * Example:

  ```java
  MyClass obj = new MyClass(); // throws error if MyClass.class missing at runtime
  ```

✅ **Key:** JVM identifies a class by **name + loader**; dynamic vs compile-time difference distinguishes them.

</details>
<br>
- How does the bytecode verifier ensure type safety? What would it reject?
<details>Bytecode verifier is a JVM security & type safety mechanism.

Ensures stack and variable types are correct, control flow is valid, and objects are initialized.

Rejects illegal casts, invalid instructions, stack misuse, uninitialized objects.</details><br>
- What is the impact of escape analysis on object allocation and synchronization?
<details>
Escape Analysis lets JVM allocate objects on stack instead of heap and remove unnecessary locks for objects that do not escape their method or thread, improving performance.
</details><br>
- When does JIT compile a method, and what optimizations can deopt trigger?
<details>JIT compiles: methods/loops that are “hot” based on execution frequency and profiling.

Optimizations: inlining, dead code elimination, lock removal, escape analysis, etc.

Deopt triggers: type profile change, new classes loaded, violated assumptions → JVM reverts to interpreter.</details><br>
- PATH vs CLASSPATH: show a subtle failure caused by wrong classpath ordering.
<details>PATH → affects which java or javac is invoked.

CLASSPATH → affects which classes get loaded.

Wrong ordering in CLASSPATH → JVM may load wrong version of class → subtle runtime bugs.</details><br>