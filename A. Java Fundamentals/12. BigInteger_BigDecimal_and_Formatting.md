## 1. Topic Overview

- Precise arithmetic with `BigInteger`/`BigDecimal` and number/date formatting for locale-safe I/O.

## 2 . Topic definition

- WHAT: Arbitrary-precision integers/decimals, immutable; `NumberFormat`, `DecimalFormat`, `DateTimeFormatter`.
- WHY: Avoid floating-point errors in money and identifiers; present data per locale.
- HOW: Use factory methods/constructors from `String`; use `MathContext`/`RoundingMode`; format/parse with locale-aware formatters.
- WHEN/WHERE: Financial apps, IDs beyond `long`, user-facing formatting.
- WHAT IF: Using double constructor causes precision loss; wrong rounding breaks totals.

## 3. Deep Dive with Examples

```java
import java.math.*; import java.text.*; import java.time.*; import java.time.format.*; import java.util.*;

class BigNumberDemo {
    public static void main(String[] args) {
        BigDecimal a = new BigDecimal("0.1");
        BigDecimal b = new BigDecimal("0.2");
        System.out.println(a.add(b)); // 0.3 exact

        BigDecimal price = new BigDecimal("10.005");
        System.out.println(price.setScale(2, RoundingMode.HALF_UP)); // 10.01

        NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.US);
        System.out.println(nf.format(1234.56));

        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        System.out.println(LocalDateTime.now().format(fmt));
    }
}
```

## 4. Best Practices & Pitfalls

- Create `BigDecimal` from `String`, not `double`.
- Centralize rounding/scale; document currency rules.
- Prefer `DateTimeFormatter` over legacy `SimpleDateFormat`.

## 5. Summary

- Use `BigDecimal` for money with explicit rounding; format with locale-aware formatters.

## 6. Tricky Interview Questions

1. Why is `new BigDecimal(0.1)` bad? Show fix.
2. Explain rounding modes and when to use them.

