## 1. Topic Overview

- Packages organize code and avoid naming conflicts.
- `static` members belong to the class; `final` prevents reassignment/overriding.

## 2. Deep Dive with Examples

```java
package com.example.fundamentals;

public class Util {
    public static final double TAX_RATE = 0.18;
    public static double applyTax(double amount) { return amount * (1 + TAX_RATE); }
}
```

```java
import com.example.fundamentals.Util;

public class UseUtil {
    public static void main(String[] args) {
        System.out.println(Util.applyTax(100));
    }
}
```

## 3. Best Practices & Pitfalls

- Keep package names lowercase, domain-style (e.g., `com.company.project`).
- Limit `public` API surface; prefer package-private for internal helpers.
- Use `final` for constants and immutable references.

## 4. Mini Exercises

- Create a package `com.play.math` with a `MathUtil` class and static `square(int)`.
- Mark immutable fields `final` and try reassigning to see compiler errors.
- Move classes between packages and update imports.

## 5. Summary

- Packages structure projects; `static` and `final` govern member semantics and immutability.

## 6. Tricky Interview Questions

- Static imports: when do they aid readability versus harm it?
- `final` field semantics: when are they safely published across threads?
- Package-private access across modules: why can it fail in JPMS?
- Constant interfaces anti-pattern: why is it discouraged?
- Utility classes: how to prevent instantiation reliably?
