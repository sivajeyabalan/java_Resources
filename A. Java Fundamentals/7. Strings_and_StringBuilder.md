## 1. Topic Overview

- `String` is immutable; operations create new objects.
- `StringBuilder` and `StringBuffer` provide mutable string manipulation.

## 2. Deep Dive with Examples

```java
public class StringsDemo {
    public static void main(String[] args) {
        String a = "hello";
        String b = a.toUpperCase(); // a unchanged
        System.out.println(a + " -> " + b);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 3; i++) sb.append(i).append("-");
        System.out.println(sb.toString());

        String x = "abc";
        String y = new String("abc");
        System.out.println(x == y);        // false (different references)
        System.out.println(x.equals(y));   // true (same content)
    }
}
```

## 3. Best Practices & Pitfalls

- Prefer `StringBuilder` in loops or many concatenations.
- Use `.equals` for content comparison; avoid `==` for strings.
- For thread-safe mutable strings, use `StringBuffer` (rarely needed today).

## 4. Mini Exercises

- Reverse a string using `StringBuilder`.
- Count vowels in a string ignoring case.
- Build a CSV line from an array of values.

## 5. Summary

- `String` is immutable; `StringBuilder` is mutable and efficient for building strings.
- Always compare string content with `.equals`.

## 6. Tricky Interview Questions

- String pool subtleties: when does `==` return true for strings?
- Cost of concatenation in loops and how JIT may optimize `+`.
- Unicode/UTF-16: how do surrogate pairs affect `length()` and indexing?
- `substring` memory leak history (pre-Java 7u6) and current behavior.
- Thread safety trade-offs: `StringBuffer` vs `StringBuilder` in modern apps.
