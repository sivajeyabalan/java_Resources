## 1. Topic Overview

- Interfaces define contracts. Classes implement them; multiple interfaces can be implemented.
- Access modifiers control visibility: `public`, `protected`, package-private (default), `private`.

## 2. Deep Dive with Examples

```java
interface Printable {
    void print();
    default void printWithHeader(String header) {
        System.out.println("== " + header + " ==");
        print();
    }
    static void info() { System.out.println("Printable interface"); }
}

class Report implements Printable {
    private final String content;
    Report(String content) { this.content = content; }
    public void print() { System.out.println(content); }
}
```

### Access Modifiers

- `public`: visible everywhere.
- `protected`: visible in package and subclasses.
- package-private: visible within same package only.
- `private`: visible within the class.

## 3. Best Practices & Pitfalls

- Prefer interfaces for APIs; depend on abstractions rather than concretions.
- Keep visibility as restrictive as possible; open up only as needed.
- Use default methods for non-breaking interface evolution.

## 4. Mini Exercises

- Define an interface `Payable` with `amount()` and implement in `Invoice` and `Salary`.
- Add a default method to `Payable` that applies a tax rate.
- Practice converting a concrete dependency to an interface.

## 5. Summary

- Interfaces model capabilities; access modifiers enforce encapsulation boundaries.
- Restrictive visibility and clear contracts improve maintainability.

## 6. Tricky Interview Questions

- Default methods diamond problem: how does Java resolve conflicts?
- Can an interface field be non-`public static final`? Explain defaults.
- Method hiding vs overriding with `static` methods.
- Package-private pitfalls when splitting modules/packages.
- API evolution: adding methods to an interface without breaking implementors.
