## 1. Topic Overview

- Methods group reusable behavior; parameters provide inputs; return values provide outputs.
- **Overloading**: multiple methods with the same name but different parameter lists.
- Java is pass-by-value; for objects, the reference value is copied.

## 2. Deep Dive with Examples

```java
public class MethodsDemo {
    static int add(int a, int b) { return a + b; }
    static double add(double a, double b) { return a + b; }

    static void mutateInt(int x) { x = 999; }
    static void mutateArray(int[] a) { a[0] = 42; }

    public static void main(String[] args) {
        System.out.println(add(2, 3));
        System.out.println(add(2.5, 3.1));

        int n = 5; mutateInt(n); System.out.println(n); // still 5
        int[] arr = {1, 2, 3}; mutateArray(arr); System.out.println(arr[0]); // 42
    }
}
```

## 3. Best Practices & Pitfalls

- Keep methods short and single-purpose; name them with verbs.
- Prefer immutability for method parameters; avoid mutating inputs unless necessary.
- Overload only when it improves clarity; avoid ambiguous overloads.

## 4. Mini Exercises

- Create overloaded `max` methods for `int`, `double`.
- Write a `swap` method for an array that swaps two indices.
- Implement `factorial(int n)` using a loop.

## 5. Summary

- Methods encapsulate behavior; overloading increases usability when used judiciously.
- Java passes values; object references can make mutations visible to callers.

## 6. Tricky Interview Questions

- Overloading resolution: what happens with `add(1, 2L)`? Explain widening vs boxing.
- Varargs ambiguity: `foo(int...)` vs `foo(Integer...)`â€”which is chosen?
- Side effects: why a `swap(a, b)` method on primitives cannot work in Java?
- Recursion stack limits: design tail-recursive alternatives where possible.
- Default parameters are not in Java: common patterns to emulate them.
