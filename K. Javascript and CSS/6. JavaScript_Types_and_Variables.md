## 1. Topic Overview

JavaScript is a dynamically typed, prototype‑based language. Understanding primitive vs reference types, `let/const/var`, and how values are compared and copied is foundational.

## 2 . Topic definition

- **What**: Types—primitive (string, number, boolean, null, undefined, symbol, bigint) and objects (arrays, functions, dates, etc.).
- **Why**: Predict behavior, avoid bugs with coercion and mutation.
- **How**: Declare variables with `let` (block‑scoped), `const` (immutable binding), `var` (function‑scoped). Use strict equality to avoid implicit coercion.
- **When/Where**: Everywhere JS runs—browsers and Node.js.
- **What If**: Using `var` causes hoisting surprises; mutating shared objects causes side effects.

## 3. Deep Dive with Examples

```html
<script>
  // Primitives vs objects
  const a = 1;                 // number (primitive)
  const b = '1';               // string (primitive)
  const c = { value: 1 };      // object (reference)

  console.log(a === b);        // false (no coercion)
  console.log(a == b);         // true  (coercion)

  // let / const / var
  let x = 10; x = 11;          // ok
  const y = 20; // y = 21;     // TypeError: assignment to constant variable
  var z = 30;                   // function scoped, hoisted

  // Copying
  const obj1 = { n: 1 };
  const obj2 = obj1;           // ref copy
  obj2.n = 2;
  console.log(obj1.n);         // 2 (same object)

  const obj3 = { ...obj1 };    // shallow clone
  obj3.n = 3;
  console.log(obj1.n);         // 2 (independent)

  // Type checks
  console.log(typeof null);    // 'object' (legacy quirk)
  console.log(Array.isArray([])); // true
  console.log(Number.isNaN(NaN)); // true; isNaN('x') -> true (coercion) vs Number.isNaN('x') -> false

  // BigInt
  const big = 10n ** 20n;
  console.log(big);
</script>
```

## 4. Best Practices & Pitfalls

- Do: prefer `const` by default; use `let` when reassignment is needed.
- Do: use `===` and `!==` to avoid coercion surprises.
- Do: clone objects/arrays before mutating when sharing references.
- Don't: rely on `var`; avoid implicit globals.
- Pitfalls: `typeof null`, truthy/falsy coercion, shallow vs deep copy.

## 5. Summary

- Know JS types and variable scoping; avoid coercion pitfalls with strict equality.

## 6. Tricky Interview Questions

1. Explain differences between `==` and `===` with examples.
2. How do `var`, `let`, and `const` differ in scope and hoisting?
3. How to clone an object—what are shallow vs deep copies?
4. Why is `typeof null === 'object'`? Historical reason.
5. When to use BigInt, and what can’t mix with it?


