## 1. Topic Overview

Beans can be defined via XML, annotations, or JavaConfig. The ApplicationContext reads definitions and wires dependencies.

## 2 . Topic definition

- **XML config**: `<beans>`, `<bean>` and namespace-based config.
- **Annotations**: `@Component`, stereotype annotations (`@Service`, `@Repository`, `@Controller`).
- **JavaConfig**: `@Configuration` with `@Bean` methods.

## 3. Deep Dive with Examples

JavaConfig + component scan:
```java
@Configuration
@ComponentScan("com.example")
public class AppConfig {
  @Bean DataSource dataSource(){ /* build and return */ return new org.h2.jdbcx.JdbcDataSource(); }
}
```

XML:
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  <bean id="messageService" class="com.example.MessageService"/>
</beans>
```

Retrieving beans:
```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
MessageService svc = ctx.getBean(MessageService.class);
```

## 4. Best Practices & Pitfalls

- Prefer JavaConfig; itâ€™s typesafe and refactor-friendly.
- Use stereotypes for clarity; keep config cohesive.
- Pitfall: Overlapping component scans causing duplicate beans.

## 5. Summary

- Spring supports XML, annotations, and JavaConfig for bean definitions.

## 6. Tricky Interview Questions

1) When would you still use XML in modern Spring apps?
2) How do you resolve bean definition conflicts?
