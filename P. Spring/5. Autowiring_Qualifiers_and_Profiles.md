## 1. Topic Overview

Autowiring lets Spring resolve and inject collaborating beans. Qualifiers disambiguate multiple candidates. Profiles enable environment-specific configuration.

## 2 . Topic definition

- **Autowiring**: `@Autowired` on constructors/setters/parameters.
- **Qualifiers**: `@Qualifier` or custom qualifier annotations to pick a specific bean.
- **Primary**: `@Primary` marks a default when multiple candidates exist.
- **Profiles**: `@Profile("dev")` activates beans only for certain environments.

## 3. Deep Dive with Examples

Multiple beans:
```java
interface Store {}
@Component("memoryStore") class MemoryStore implements Store {}
@Component("dbStore") @Primary class DbStore implements Store {}
@Component class Service { Service(Store store) { /* gets DbStore by default */ } }
```

Qualifier:
```java
@Component class ReportService {
  ReportService(@Qualifier("memoryStore") Store store) { /* specific */ }
}
```

Profiles:
```java
@Configuration
@Profile("dev")
class DevConfig { @Bean DataSource ds(){ /* H2 */ return new org.h2.jdbcx.JdbcDataSource(); } }

@Configuration
@Profile("prod")
class ProdConfig { @Bean DataSource ds(){ /* real DB */ return /* ... */ null; } }
```

Activate profile:
```java
new AnnotationConfigApplicationContext("com.example") {{ getEnvironment().setActiveProfiles("dev"); refresh(); }};
```

## 4. Best Practices & Pitfalls

- Prefer constructor injection; avoid optional/nullable autowiring.
- Use qualifiers sparingly; design clearer abstractions if too many qualifiers appear.
- Pitfall: Forgetting to set active profile causes missing bean errors.

## 5. Summary

- Autowiring wires dependencies; qualifiers resolve ambiguity; profiles switch env-specific beans.

## 6. Tricky Interview Questions

1) When would you use `@Primary` vs `@Qualifier`?
2) How do you manage secrets/config differences across profiles safely?
