## 1. Topic Overview

Spring beans have scopes (lifecycle boundaries) and lifecycle callbacks. Understanding scopes and init/destroy hooks is key to resource management and correct behavior.

## 2 . Topic definition

- **Scopes**: `singleton` (default), `prototype`, `request`, `session`, `application`, `websocket`.
- **Initialization**: After dependency injection; via `@PostConstruct` or init methods.
- **Destruction**: Before container shutdown; via `@PreDestroy` or destroy methods.

## 3. Deep Dive with Examples

Scopes:
```java
@Component @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
class AppConfigHolder {}

@Component @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
class Task {}
```

Lifecycle callbacks:
```java
@Component
class ResourceClient {
  @PostConstruct void init(){ /* open connections */ }
  @PreDestroy  void close(){ /* close connections */ }
}
```

Custom init/destroy via JavaConfig:
```java
@Configuration
class Cfg {
  @Bean(initMethod = "start", destroyMethod = "stop")
  Server server(){ return new Server(); }
}
class Server { void start(){} void stop(){} }
```

Prototype note: container does not manage destroy callbacks for prototype beans.

## 4. Best Practices & Pitfalls

- Prefer `singleton` unless you need per-use instances; avoid global mutable state.
- Don’t store request/session data in singletons; use proper scopes or request-bound context.
- Pitfall: Expecting `@PreDestroy` on prototypes to run automatically.

## 5. Summary

- Choose appropriate scopes and use lifecycle hooks for resource safety.

## 6. Tricky Interview Questions

1) Why doesn’t Spring invoke destroy methods for prototypes? How to handle cleanup?
2) How do you inject a prototype into a singleton correctly (ObjectFactory/Provider)?
