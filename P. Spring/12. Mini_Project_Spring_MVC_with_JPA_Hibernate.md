## 1. Topic Overview

Mini-project: Spring MVC + Spring Data JPA CRUD for `Product` with validation and PRG.

## 2 . Topic definition

- **Scope**: Controller, service, repository, entity, views (JSP), Bean Validation.

## 3. Deep Dive with Examples

Entity:
```java
@Entity class Product { @Id @GeneratedValue Long id; @NotBlank String name; @Positive BigDecimal price; }
```

Repository and service:
```java
public interface ProductRepo extends JpaRepository<Product, Long> {}
@Service class ProductService { private final ProductRepo repo; ProductService(ProductRepo r){this.repo=r;} @Transactional public Product save(Product p){ return repo.save(p);} public List<Product> all(){ return repo.findAll(); } }
```

Controller:
```java
@Controller @RequestMapping("/products")
class ProductController {
  private final ProductService svc; ProductController(ProductService s){ this.svc=s; }
  @GetMapping String list(Model m){ m.addAttribute("list", svc.all()); return "products"; }
  @PostMapping String create(@Valid @ModelAttribute Product p, BindingResult br, RedirectAttributes ra){
    if (br.hasErrors()) return "product_form";
    svc.save(p); ra.addFlashAttribute("msg","Saved"); return "redirect:/products";
  }
}
```

Views:
```jsp
<!-- /WEB-INF/views/products.jsp -->
<c:if test="${not empty msg}"><div>${msg}</div></c:if>
<ul><c:forEach var="p" items="${list}"><li>${p.name} - ${p.price}</li></c:forEach></ul>
<form method="post" action="${pageContext.request.contextPath}/products">
  <input name="name" placeholder="Name"/>
  <input name="price" placeholder="0.00"/>
  <button>Save</button>
</form>
```

## 4. Best Practices & Pitfalls

- Validate inputs; use PRG; handle errors with `@ControllerAdvice` if needed.
- Keep repository thin; business logic in services; avoid exposing entities directly in APIs.

## 5. Summary

- End-to-end MVC + JPA CRUD with validation and clean layering.

## 6. Tricky Interview Questions

1) How to handle optimistic locking conflicts in the UI?
2) How to add pagination and sorting efficiently?
