## 1. Topic Overview

Controllers map HTTP requests to handler methods using annotations. Methods return views (JSP/Thymeleaf) or bodies (JSON). Models carry data to the view.

## 2 . Topic definition

- **@Controller / @RestController**: MVC vs REST endpoints.
- **@RequestMapping / @GetMapping / @PostMapping**: Map paths and methods.
- **Model/ModelMap**: Data for rendering; `RedirectAttributes` for flash.
- **ViewResolver**: Maps logical view names to templates.

## 3. Deep Dive with Examples

```java
@Controller
@RequestMapping("/products")
class ProductController {
  @GetMapping
  String list(Model model) {
    model.addAttribute("products", svc.findAll());
    return "products"; // /WEB-INF/views/products.jsp
  }

  @GetMapping("/{id}")
  String detail(@PathVariable Long id, Model model) {
    model.addAttribute("p", svc.find(id));
    return "product_detail";
  }

  @PostMapping
  String create(@ModelAttribute ProductForm form, RedirectAttributes ra) {
    svc.create(form);
    ra.addFlashAttribute("msg", "Created");
    return "redirect:/products"; // PRG
  }
}
```

REST variant:
```java
@RestController
@RequestMapping("/api/products")
class ProductApi { @GetMapping List<Product> all(){ return svc.findAll(); } }
```

## 4. Best Practices & Pitfalls

- Use DTOs/forms for binding; validate with `@Valid` and `BindingResult`.
- Prefer REST controllers for APIs; MVC controllers for server-rendered views.
- Pitfall: Returning raw entity to view may expose lazy-loading issues.

## 5. Summary

- Controllers map requests to methods; models carry data; view resolvers pick templates.

## 6. Tricky Interview Questions

1) How do `@Controller` and `@RestController` differ under the hood?
2) How to pass flash messages across redirects safely?
