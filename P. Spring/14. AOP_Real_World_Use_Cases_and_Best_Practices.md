## 1. Topic Overview

- Aspect-Oriented Programming modularizes cross-cutting concerns like logging, metrics, transactions, and security.

## 2 . Topic definition

- WHAT: Aspects, pointcuts, advices (`@Before`, `@AfterReturning`, `@Around`), join points, proxies.
- WHY: Keep business code clean while applying orthogonal behaviors consistently.
- HOW: Define `@Aspect` classes with pointcut expressions; use `@Around` for timing/metrics; mind proxying semantics.
- WHEN/WHERE: Logging, metrics, caching, retries, security checks.
- WHAT IF: Self-invocation bypasses proxies; broad pointcuts can hurt performance.

## 3. Deep Dive with Examples

```java
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
class TimingAspect {
    @Around("execution(* com.example.service..*(..))")
    public Object time(ProceedingJoinPoint pjp) throws Throwable {
        long t0 = System.nanoTime();
        try { return pjp.proceed(); }
        finally { long dt = System.nanoTime() - t0; System.out.println(pjp.getSignature()+" took "+dt/1_000_000+"ms"); }
    }
}
```

```java
// AfterReturning example for auditing
import org.aspectj.lang.annotation.*;

@Aspect
@Component
class AuditAspect {
    @AfterReturning(pointcut = "execution(* com.example.order.OrderService.create(..))", returning = "ret")
    public void audit(Object ret) { /* send event */ }
}
```

## 4. Best Practices & Pitfalls

- Keep pointcuts specific; avoid `execution(* *(..))` catch-alls.
- Use `@Around` sparingly; prefer `@Before/@After` when sufficient.
- Be aware of proxy types (JDK vs CGLIB) and final classes/methods limitations.

## 5. Summary

- AOP applies cross-cutting behavior cleanly; understand proxying and scope to avoid surprises.

## 6. Tricky Interview Questions

1. Why can aspects fail on self-invocation? Solutions?
2. How do you scope pointcuts to avoid performance overhead?

