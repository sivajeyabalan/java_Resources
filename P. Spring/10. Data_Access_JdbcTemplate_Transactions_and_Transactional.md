## 1. Topic Overview

Spring simplifies JDBC access with `JdbcTemplate` and manages transactions declaratively via `@Transactional`.

## 2 . Topic definition

- **JdbcTemplate**: Template for executing SQL with resource management and mapping.
- **RowMapper**: Maps rows to objects.
- **@Transactional**: Demarcates transactional boundaries with rollback rules.

## 3. Deep Dive with Examples

Configuration:
```java
@Configuration
@EnableTransactionManagement
class DataConfig {
  @Bean DataSource ds(){ return new org.h2.jdbcx.JdbcDataSource(); }
  @Bean JdbcTemplate jdbcTemplate(DataSource ds){ return new JdbcTemplate(ds); }
  @Bean PlatformTransactionManager txManager(DataSource ds){ return new DataSourceTransactionManager(ds); }
}
```

Repository:
```java
@Repository
class ProductRepo {
  private final JdbcTemplate jdbc;
  ProductRepo(JdbcTemplate jdbc){ this.jdbc = jdbc; }
  List<Product> findAll(){
    return jdbc.query("select id,name,price from product", (rs,i)-> new Product(rs.getLong(1), rs.getString(2), rs.getBigDecimal(3)));
  }
  int save(Product p){ return jdbc.update("insert into product(name,price) values(?,?)", p.getName(), p.getPrice()); }
}
```

Service with transactions:
```java
@Service
class ProductService {
  private final ProductRepo repo;
  ProductService(ProductRepo repo){ this.repo = repo; }
  @Transactional
  public void create(Product p){ repo.save(p); }
}
```

## 4. Best Practices & Pitfalls

- Keep transactions at service layer; avoid long-running transactions.
- Be mindful of proxying: `@Transactional` works on public methods called via proxy.
- Pitfall: Self-invocation bypasses proxies; split methods or use AspectJ.

## 5. Summary

- Use `JdbcTemplate` for clean JDBC; `@Transactional` for consistent data operations.

## 6. Tricky Interview Questions

1) How does rollback behavior differ for checked vs unchecked exceptions?
2) Why does `@Transactional` not work on private or internal method calls?
