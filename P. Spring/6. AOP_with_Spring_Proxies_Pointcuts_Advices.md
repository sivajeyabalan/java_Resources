## 1. Topic Overview

Aspect-Oriented Programming (AOP) modularizes cross-cutting concerns (logging, transactions, security) via proxies that wrap target beans and apply advice at join points.

## 2 . Topic definition

- **Join point**: A point during execution (method call).
- **Pointcut**: Expression selecting join points (e.g., methods in a package).
- **Advice**: Action taken at a join point (before/after/around/afterThrowing/afterReturning).
- **Aspect**: A module grouping pointcuts and advice.

## 3. Deep Dive with Examples

```java
@Aspect
@Component
class LogAspect {
  @Pointcut("execution(* com.example.service..*(..))")
  void svc() {}

  @Before("svc()")
  void before(JoinPoint jp) { System.out.println("→ " + jp.getSignature()); }

  @AfterReturning(pointcut = "svc()", returning = "ret")
  void after(Object ret) { System.out.println("← ret=" + ret); }

  @Around("svc()")
  Object around(ProceedingJoinPoint pjp) throws Throwable {
    long t=System.nanoTime();
    try { return pjp.proceed(); } finally { System.out.println("took="+(System.nanoTime()-t)); }
  }
}
```

Enable AOP:
```java
@Configuration
@EnableAspectJAutoProxy
class AopConfig {}
```

## 4. Best Practices & Pitfalls

- Keep pointcuts specific; avoid broad matches that impact performance.
- Be aware of self-invocation not going through proxies; use AspectJ if needed.
- Pitfall: Final methods/classes cannot be proxied by JDK dynamic proxies.

## 5. Summary

- Spring AOP uses proxies to apply advice at selected join points via pointcuts.

## 6. Tricky Interview Questions

1) Why doesn’t advice run on self-invocation and how to fix it?
2) When do you choose proxy-based Spring AOP vs compile-time/load-time weaving?
