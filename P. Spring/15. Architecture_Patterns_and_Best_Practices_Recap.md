## 1. Topic Overview

- Recap of Spring-friendly architecture patterns: layered architecture, hexagonal (ports/adapters), DDD building blocks, and SOLID applied to Spring.

## 2 . Topic definition

- WHAT: Structure apps with clear boundariesâ€”controllers, services, repositories, domain model; ports/adapters for external systems; DDD concepts (entities, value objects, aggregates, domain services).
- WHY: Maintainability, testability, and evolvability.
- HOW: Define interfaces (ports) for outbound dependencies, implement adapters, keep business logic in domain/services, use DTOs at boundaries.
- WHEN/WHERE: Medium to large services; microservices.
- WHAT IF: Anemic domain or god services lead to tight coupling and brittle systems.

## 3. Deep Dive with Examples

Layered vs Hexagonal:
- Layered: `controller -> service -> repository`.
- Hexagonal: `domain` at center; inbound port (service interface) implemented by controllers; outbound ports (repos, clients) with adapters.

```java
// Port and adapter example
interface PaymentsPort { void charge(String userId, int amount); }
class StripeAdapter implements PaymentsPort { public void charge(String userId, int amount) { /* call Stripe */ } }

class OrderService {
    private final PaymentsPort payments;
    OrderService(PaymentsPort payments) { this.payments = payments; }
    public void placeOrder(/*...*/) { payments.charge("u1", 100); }
}
```

DDD Notes:
- Entity: identity + lifecycle; Value Object: immutable, equals by value; Aggregate: consistency boundary with aggregate root.
- Domain events decouple side effects (e.g., publish `OrderPlaced`).

SOLID in Spring:
- SRP: controllers thin; services cohesive.
- OCP: add new functionality via new beans/strategies.
- LSP/ISP: program to interfaces (ports), segregate by usage.
- DI (DIP): inject abstractions.

## 4. Best Practices & Pitfalls

- Keep controllers free of business logic; validate and delegate.
- Prevent leakage of JPA entities across API boundaries; use DTOs.
- Centralize cross-cutting concerns via AOP/filters (logging, metrics, security).

## 5. Summary

- Choose layered or hexagonal; keep clear boundaries, apply DDD/SOLID; drive dependencies inward via ports/adapters.

## 6. Tricky Interview Questions

1. When would you move from layered to hexagonal architecture?
2. How do domain events improve modularity and consistency?

