## 1. Topic Overview

- Spring declarative transactions provide consistent data integrity across services with minimal boilerplate.

## 2 . Topic definition

- WHAT: `@Transactional` semantics, propagation (REQUIRED, REQUIRES_NEW, NESTED, etc.), isolation levels, read-only, rollback rules.
- WHY: Control transaction boundaries across layered services and avoid data anomalies.
- HOW: Annotate service methods; understand proxy-based behavior and self-invocation caveats; configure platform transaction manager.
- WHEN/WHERE: Service/business layer methods performing DB work.
- WHAT IF: Wrong propagation can swallow exceptions or expand scope; self-invocation bypasses proxies.

## 3. Deep Dive with Examples

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.*;

@Service
class BillingService {
    private final PaymentRepo payments; private final LedgerRepo ledger;
    BillingService(PaymentRepo payments, LedgerRepo ledger) { this.payments = payments; this.ledger = ledger; }

    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void chargeAndRecord(Payment p) {
        payments.save(p);
        ledger.record(p);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void audit(Payment p) { ledger.audit(p); }
}
```

Common pitfalls:
- Self-invocation: calling another `@Transactional` method on `this` won’t start a new transaction.
- Checked exceptions don’t trigger rollback by default; configure `rollbackFor` as needed.
- Read-only hints allow optimizations; don’t modify data in read-only transactions.

## 4. Best Practices & Pitfalls

- Keep transactions short; avoid remote calls within transaction scopes.
- Choose propagation carefully; use `REQUIRES_NEW` sparingly for outbox/audit patterns.
- Align isolation with DB defaults and anomalies tolerance; prefer READ COMMITTED.

## 5. Summary

- Correct `@Transactional` use hinges on understanding proxies, propagation, isolation, and rollback rules.

## 6. Tricky Interview Questions

1. Why doesn’t `@Transactional` work in self-invocation? How to fix?
2. Compare `REQUIRED` vs `REQUIRES_NEW` with real scenarios.
3. Which exceptions trigger rollback by default and how to customize?

