## 1. Topic Overview

JUnit is a widely-used testing framework for Java applications that provides a simple and powerful way to write and execute unit tests. It offers annotations to mark test methods, assertion methods to verify expected behavior, and a test runner to execute tests automatically. JUnit follows a structured approach with important classes like TestCase, TestSuite, and TestRunner, and provides features like test fixtures, exception testing, and parameterized tests. Understanding JUnit's architecture, setup, and core features is essential for effective Java application testing.

## 2. Topic Definition

- **What**: Open-source unit testing framework for Java providing annotations, assertions, and test execution capabilities
- **Why**: Standardizes testing approach, automates test execution, provides clear test results, integrates with IDEs and build tools
- **How**: Through annotations (@Test, @BeforeEach, etc.), assertion methods (assertEquals, assertTrue, etc.), and test runners
- **When/Where**: During development for unit testing, in CI/CD pipelines, before releases, and for regression testing
- **What If**:
  - Test methods must be public (or package-private in JUnit 5) and return void
  - Private test methods are ignored by JUnit
  - Tests returning non-void types are invalid
  - Proper setup and teardown ensure test isolation
- **Examples**:
  - Basic test: `@Test void testAddition() { assertEquals(5, calculator.add(2, 3)); }`
  - Setup: `@BeforeEach void setUp() { calculator = new Calculator(); }`
  - Exception test: `assertThrows(IllegalArgumentException.class, () -> divide(5, 0))`

## 3. Deep Dive with Examples

```java
// File: JUnitFrameworkBasicsDemo.java
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import static org.junit.jupiter.api.Assertions.*;
import java.time.Duration;
import java.util.*;

/**
 * Comprehensive demonstration of JUnit framework basics, classes, and features
 */
public class JUnitFrameworkBasicsDemo {
    
    // ========== SAMPLE CLASSES FOR TESTING ==========
    
    static class MathUtils {
        public int add(int a, int b) {
            return a + b;
        }
        
        public int multiply(int a, int b) {
            return a * b;
        }
        
        public double divide(double a, double b) {
            if (b == 0) {
                throw new IllegalArgumentException("Cannot divide by zero");
            }
            return a / b;
        }
        
        public int factorial(int n) {
            if (n < 0) {
                throw new IllegalArgumentException("Factorial not defined for negative numbers");
            }
            if (n == 0 || n == 1) {
                return 1;
            }
            return n * factorial(n - 1);
        }
        
        public boolean isPerfectSquare(int number) {
            if (number < 0) return false;
            int sqrt = (int) Math.sqrt(number);
            return sqrt * sqrt == number;
        }
    }
    
    static class StringUtils {
        public String reverse(String input) {
            if (input == null) {
                throw new IllegalArgumentException("Input cannot be null");
            }
            return new StringBuilder(input).reverse().toString();
        }
        
        public boolean isPalindrome(String input) {
            if (input == null) return false;
            String cleaned = input.toLowerCase().replaceAll("[^a-zA-Z0-9]", "");
            return cleaned.equals(reverse(cleaned).toLowerCase());
        }
        
        public String capitalize(String input) {
            if (input == null || input.isEmpty()) {
                return input;
            }
            return input.substring(0, 1).toUpperCase() + input.substring(1).toLowerCase();
        }
    }
    
    // Test instance variables
    private MathUtils mathUtils;
    private StringUtils stringUtils;
    private List<String> testData;
    
    // ========== JUNIT LIFECYCLE METHODS ==========
    
    @BeforeAll
    static void setUpClass() {
        // Runs once before all test methods in the class
        // Used for expensive setup operations
        System.out.println("=== JUnit Framework Basics Demo Started ===");
        System.out.println("Setting up class-level resources...");
    }
    
    @AfterAll
    static void tearDownClass() {
        // Runs once after all test methods in the class
        // Used for cleanup of class-level resources
        System.out.println("Cleaning up class-level resources...");
        System.out.println("=== JUnit Framework Basics Demo Completed ===");
    }
    
    @BeforeEach
    void setUp() {
        // Runs before each test method
        // Used to initialize test fixtures
        mathUtils = new MathUtils();
        stringUtils = new StringUtils();
        testData = new ArrayList<>();
        testData.add("test1");
        testData.add("test2");
        
        System.out.println("Setting up test fixtures for: " + 
                          getClass().getSimpleName());
    }
    
    @AfterEach
    void tearDown() {
        // Runs after each test method
        // Used to clean up test fixtures
        mathUtils = null;
        stringUtils = null;
        testData.clear();
        testData = null;
        
        System.out.println("Cleaning up test fixtures");
    }
    
    // ========== BASIC TEST METHODS ==========
    
    @Test
    @DisplayName("Test Math Addition - Basic JUnit Test")
    void testMathAddition() {
        // Basic test method demonstrating JUnit structure
        
        // Arrange
        int a = 5;
        int b = 3;
        int expected = 8;
        
        // Act
        int actual = mathUtils.add(a, b);
        
        // Assert
        assertEquals(expected, actual, "5 + 3 should equal 8");
        
        System.out.println("✓ Basic addition test completed");
    }
    
    @Test
    @DisplayName("Test String Reversal")
    void testStringReversal() {
        // Test string utility functionality
        
        String input = "hello";
        String expected = "olleh";
        String actual = stringUtils.reverse(input);
        
        assertEquals(expected, actual, "String should be reversed correctly");
        
        System.out.println("✓ String reversal test completed");
    }
    
    // ========== TESTING METHOD VISIBILITY ==========
    
    @Test
    void testPublicMethodVisibility() {
        // JUnit can execute public test methods
        assertTrue(true, "Public test methods work fine");
        System.out.println("✓ Public test method executed successfully");
    }
    
    @Test
    // Package-private methods also work in JUnit 5
    void testPackagePrivateMethodVisibility() {
        assertTrue(true, "Package-private test methods work in JUnit 5");
        System.out.println("✓ Package-private test method executed successfully");
    }
    
    // This method demonstrates what happens with private methods
    @Test
    // Note: Private methods are NOT executed by JUnit
    // Uncommenting @Test on a private method would cause it to be ignored
    void demonstratePrivateMethodIssue() {
        // If this were private, JUnit would ignore it
        System.out.println("✓ This method runs because it's not private");
    }
    
    // ========== TESTING RETURN TYPES ==========
    
    @Test
    void testMethodMustReturnVoid() {
        // JUnit test methods must return void
        // Methods returning String, int, etc. are invalid
        
        assertNotNull(mathUtils, "MathUtils should be initialized");
        
        // This is correct - returns void
        System.out.println("✓ Test method correctly returns void");
    }
    
    // This would be INVALID - test methods cannot return non-void types
    // @Test
    // String invalidTestMethod() {
    //     return "This would not work as a JUnit test";
    // }
    
    // ========== EXCEPTION TESTING ==========
    
    @Test
    @DisplayName("Test Exception Handling - Division by Zero")
    void testDivisionByZeroException() {
        // Testing that code throws the expected exception
        
        IllegalArgumentException exception = assertThrows(
            IllegalArgumentException.class,
            () -> mathUtils.divide(10, 0),
            "Division by zero should throw IllegalArgumentException"
        );
        
        assertEquals("Cannot divide by zero", exception.getMessage(),
                    "Exception message should match expected text");
        
        System.out.println("✓ Exception testing completed");
    }
    
    @Test
    @DisplayName("Test Exception Handling - Null Input")
    void testNullInputException() {
        // Testing exception with null input
        
        assertThrows(IllegalArgumentException.class,
                    () -> stringUtils.reverse(null),
                    "Null input should throw IllegalArgumentException");
        
        System.out.println("✓ Null input exception test completed");
    }
    
    @Test
    @DisplayName("Test No Exception Thrown")
    void testNoExceptionThrown() {
        // Testing that code does NOT throw an exception
        
        assertDoesNotThrow(() -> mathUtils.add(5, 3),
                          "Addition should not throw any exception");
        
        assertDoesNotThrow(() -> stringUtils.reverse("hello"),
                          "String reversal should not throw exception");
        
        System.out.println("✓ No exception test completed");
    }
    
    // ========== TIMEOUT TESTING ==========
    
    @Test
    @DisplayName("Test Method Execution Timeout")
    void testMethodTimeout() {
        // Testing that method completes within specified time
        
        assertTimeout(Duration.ofSeconds(1), () -> {
            // Simulate some work that should complete quickly
            Thread.sleep(100);
            return mathUtils.factorial(5);
        }, "Factorial calculation should complete within 1 second");
        
        System.out.println("✓ Timeout test completed");
    }
    
    @Test
    @DisplayName("Test Timeout with Preemptive Termination")
    void testTimeoutPreemptive() {
        // Test with preemptive timeout (terminates execution if timeout exceeded)
        
        assertTimeoutPreemptively(Duration.ofMillis(500), () -> {
            // Quick operation
            return mathUtils.multiply(10, 20);
        }, "Multiplication should complete very quickly");
        
        System.out.println("✓ Preemptive timeout test completed");
    }
    
    // ========== TESTING PROTECTED AND PRIVATE METHODS ==========
    
    static class TestableClass {
        protected int protectedMethod(int value) {
            return value * 2;
        }
        
        private int privateMethod(int value) {
            return value * 3;
        }
        
        // Public method that uses private method (for testing private indirectly)
        public int publicMethodUsingPrivate(int value) {
            return privateMethod(value);
        }
    }
    
    @Test
    @DisplayName("Test Protected Method")
    void testProtectedMethod() {
        // Protected methods can be tested directly if in same package
        // or through inheritance
        
        TestableClass testable = new TestableClass();
        int result = testable.protectedMethod(5);
        
        assertEquals(10, result, "Protected method should double the input");
        
        System.out.println("✓ Protected method test completed");
    }
    
    @Test
    @DisplayName("Test Private Method Indirectly")
    void testPrivateMethodIndirectly() {
        // Private methods cannot be tested directly
        // Test them indirectly through public methods that use them
        
        TestableClass testable = new TestableClass();
        int result = testable.publicMethodUsingPrivate(5);
        
        assertEquals(15, result, "Private method should triple the input (tested indirectly)");
        
        System.out.println("✓ Private method (indirect) test completed");
    }
    
    // ========== PARAMETERIZED TESTS ==========
    
    @ParameterizedTest
    @DisplayName("Test Perfect Squares with Multiple Values")
    @ValueSource(ints = {1, 4, 9, 16, 25, 36, 49, 64, 81, 100})
    void testPerfectSquares(int number) {
        // Parameterized test runs multiple times with different values
        
        assertTrue(mathUtils.isPerfectSquare(number),
                  number + " should be identified as a perfect square");
        
        System.out.println("✓ Perfect square test for: " + number);
    }
    
    @ParameterizedTest
    @DisplayName("Test Non-Perfect Squares")
    @ValueSource(ints = {2, 3, 5, 6, 7, 8, 10, 11, 12, 15})
    void testNonPerfectSquares(int number) {
        assertFalse(mathUtils.isPerfectSquare(number),
                   number + " should NOT be identified as a perfect square");
        
        System.out.println("✓ Non-perfect square test for: " + number);
    }
    
    @ParameterizedTest
    @DisplayName("Test String Capitalization with CSV Data")
    @CsvSource({
        "hello, Hello",
        "WORLD, World", 
        "tESt, Test",
        "java, Java",
        "JuNiT, Junit"
    })
    void testStringCapitalization(String input, String expected) {
        String actual = stringUtils.capitalize(input);
        assertEquals(expected, actual, 
                    "Capitalization of '" + input + "' should be '" + expected + "'");
        
        System.out.println("✓ Capitalization test: " + input + " -> " + actual);
    }
    
    // ========== CONDITIONAL TESTS ==========
    
    @Test
    @EnabledOnOs(OS.WINDOWS)
    @DisplayName("Test Only on Windows")
    void testOnlyOnWindows() {
        // This test only runs on Windows
        assertTrue(true, "This test runs only on Windows");
        System.out.println("✓ Windows-specific test completed");
    }
    
    @Test
    @EnabledOnJre(JRE.JAVA_11)
    @DisplayName("Test Only on Java 11")
    void testOnlyOnJava11() {
        // This test only runs on Java 11
        assertTrue(true, "This test runs only on Java 11");
        System.out.println("✓ Java 11-specific test completed");
    }
    
    @Test
    @EnabledIf("java.version.startsWith('11')")
    @DisplayName("Test with Custom Condition")
    void testWithCustomCondition() {
        // Custom condition for test execution
        assertTrue(true, "This test runs based on custom condition");
        System.out.println("✓ Custom condition test completed");
    }
    
    // ========== NESTED TESTS ==========
    
    @Nested
    @DisplayName("Math Operations Tests")
    class MathOperationsTests {
        
        @Test
        @DisplayName("Test Addition in Nested Class")
        void testAddition() {
            assertEquals(8, mathUtils.add(5, 3), "Addition should work in nested test");
            System.out.println("✓ Nested addition test completed");
        }
        
        @Test
        @DisplayName("Test Multiplication in Nested Class")
        void testMultiplication() {
            assertEquals(15, mathUtils.multiply(5, 3), "Multiplication should work in nested test");
            System.out.println("✓ Nested multiplication test completed");
        }
        
        @Nested
        @DisplayName("Factorial Tests")
        class FactorialTests {
            
            @Test
            @DisplayName("Test Factorial of Positive Numbers")
            void testPositiveFactorial() {
                assertEquals(1, mathUtils.factorial(0), "0! should be 1");
                assertEquals(1, mathUtils.factorial(1), "1! should be 1");
                assertEquals(2, mathUtils.factorial(2), "2! should be 2");
                assertEquals(6, mathUtils.factorial(3), "3! should be 6");
                assertEquals(24, mathUtils.factorial(4), "4! should be 24");
                assertEquals(120, mathUtils.factorial(5), "5! should be 120");
                
                System.out.println("✓ Positive factorial tests completed");
            }
            
            @Test
            @DisplayName("Test Factorial of Negative Numbers")
            void testNegativeFactorial() {
                assertThrows(IllegalArgumentException.class,
                           () -> mathUtils.factorial(-1),
                           "Factorial of negative number should throw exception");
                
                System.out.println("✓ Negative factorial test completed");
            }
        }
    }
    
    // ========== REPEATED TESTS ==========
    
    @RepeatedTest(5)
    @DisplayName("Repeated Test Example")
    void repeatedTestExample(RepetitionInfo repetitionInfo) {
        // This test runs 5 times
        
        int currentRepetition = repetitionInfo.getCurrentRepetition();
        int totalRepetitions = repetitionInfo.getTotalRepetitions();
        
        assertTrue(currentRepetition <= totalRepetitions,
                  "Current repetition should not exceed total");
        
        System.out.println("✓ Repeated test execution: " + 
                          currentRepetition + "/" + totalRepetitions);
    }
    
    // ========== DYNAMIC TESTS ==========
    
    @TestFactory
    @DisplayName("Dynamic Tests for Palindromes")
    Collection<DynamicTest> dynamicTestsForPalindromes() {
        // Generate tests dynamically at runtime
        
        List<String> palindromes = Arrays.asList(
            "racecar", "level", "madam", "noon", "civic"
        );
        
        return palindromes.stream()
                .map(palindrome -> DynamicTest.dynamicTest(
                    "Test palindrome: " + palindrome,
                    () -> assertTrue(stringUtils.isPalindrome(palindrome),
                                   palindrome + " should be identified as palindrome")
                ))
                .toList();
    }
    
    // ========== ASSUMPTIONS ==========
    
    @Test
    @DisplayName("Test with Assumptions")
    void testWithAssumptions() {
        // Assumptions allow conditional test execution
        
        // Only run this test if we're on a Unix-like system
        assumeTrue(System.getProperty("os.name").toLowerCase().contains("nix") ||
                  System.getProperty("os.name").toLowerCase().contains("nux"),
                  "This test only runs on Unix-like systems");
        
        // Test code here would only run if assumption is true
        assertTrue(true, "This test runs only under certain assumptions");
        
        System.out.println("✓ Assumption-based test completed");
    }
    
    @Test
    @DisplayName("Test with Assumption Message")
    void testWithAssumptionMessage() {
        // Assumption with custom message
        
        assumingThat(System.getProperty("java.version").startsWith("11"),
                    () -> {
                        // This block only runs if assumption is true
                        assertEquals(2, 1 + 1, "Math should work on Java 11");
                        System.out.println("✓ Java 11 specific logic executed");
                    });
        
        // This always runs regardless of assumption
        assertTrue(true, "This assertion always runs");
        System.out.println("✓ General test logic completed");
    }
}

// ========== DEMONSTRATION OF JUNIT CLASSES ==========

/**
 * Demonstrates important JUnit classes and their usage
 */
class JUnitClassesDemo {
    
    // JUnit 5 doesn't use TestCase class (that was JUnit 3/4)
    // Instead, it uses annotations and assertions
    
    @Test
    @DisplayName("Demonstrate JUnit Classes Usage")
    void demonstrateJUnitClasses() {
        // Important JUnit classes and interfaces:
        
        // 1. Assertions class - provides static assertion methods
        Assertions.assertEquals(5, 2 + 3, "Assertions class provides assertion methods");
        
        // 2. Assumptions class - provides assumption methods
        Assumptions.assumeTrue(true, "Assumptions class provides assumption methods");
        
        // 3. TestInfo - provides information about current test
        // (Available as parameter in test methods)
        
        // 4. TestReporter - for publishing test data
        // (Available as parameter in test methods)
        
        System.out.println("✓ JUnit classes demonstration completed");
    }
    
    @Test
    @DisplayName("Test with TestInfo and TestReporter")
    void testWithTestInfoAndReporter(TestInfo testInfo, TestReporter testReporter) {
        // TestInfo provides metadata about the current test
        
        String displayName = testInfo.getDisplayName();
        String methodName = testInfo.getTestMethod().get().getName();
        Set<String> tags = testInfo.getTags();
        
        // TestReporter allows publishing additional test data
        testReporter.publishEntry("displayName", displayName);
        testReporter.publishEntry("methodName", methodName);
        testReporter.publishEntry("tags", tags.toString());
        
        assertNotNull(displayName, "Display name should not be null");
        assertNotNull(methodName, "Method name should not be null");
        
        System.out.println("✓ TestInfo and TestReporter demonstration completed");
    }
}

// ========== MAIN METHOD FOR UNIT TESTING DEMONSTRATION ==========

/**
 * Demonstrates using main() method for unit testing (not recommended)
 */
class MainMethodTestingDemo {
    
    public static void main(String[] args) {
        // You CAN use main() method for unit testing, but it's not recommended
        
        System.out.println("=== Main Method Testing Demo ===");
        
        MathUtils mathUtils = new MathUtils();
        
        // Manual testing using main method
        int result = mathUtils.add(2, 3);
        if (result == 5) {
            System.out.println("✓ Addition test passed: " + result);
        } else {
            System.out.println("✗ Addition test failed: expected 5, got " + result);
        }
        
        // Test exception handling
        try {
            mathUtils.divide(10, 0);
            System.out.println("✗ Exception test failed: should have thrown exception");
        } catch (IllegalArgumentException e) {
            System.out.println("✓ Exception test passed: " + e.getMessage());
        }
        
        System.out.println("\nWhy main() method testing is not recommended:");
        System.out.println("- No automatic test discovery");
        System.out.println("- No test reporting");
        System.out.println("- No integration with IDEs/build tools");
        System.out.println("- Manual result verification");
        System.out.println("- No test lifecycle management");
        System.out.println("- Difficult to organize and maintain");
        
        System.out.println("\nUse JUnit framework instead for proper unit testing!");
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use descriptive test method names and @DisplayName annotations
- Follow the Arrange-Act-Assert pattern in test methods
- Use @BeforeEach and @AfterEach for proper test setup and cleanup
- Test both positive and negative scenarios (happy path and edge cases)
- Use parameterized tests for testing multiple input values

**Don'ts:**
- Don't make test methods private (JUnit will ignore them)
- Don't return non-void types from test methods
- Don't write tests that depend on execution order
- Don't use main() method for unit testing in production code
- Don't ignore test failures or write tests that always pass

**Common Pitfalls:**
- Forgetting to initialize test fixtures in @BeforeEach methods
- Writing tests that are too complex or test multiple things
- Not cleaning up resources properly in @AfterEach methods
- Creating tests that are flaky due to timing or external dependencies
- Not testing exception scenarios and edge cases

## 5. Summary

- **JUnit** is Java's premier unit testing framework providing annotations, assertions, and test execution
- **Test methods** must be public (or package-private in JUnit 5) and return void
- **Private test methods** are ignored by JUnit and won't be executed
- **Test lifecycle** managed through @BeforeAll, @BeforeEach, @AfterEach, @AfterAll annotations
- **Exception testing** supported through assertThrows() and assertDoesNotThrow() methods
- **Parameterized tests** allow testing multiple values with @ParameterizedTest
- **JUnit classes** include Assertions, Assumptions, TestInfo, and TestReporter for various testing needs
- **Main() method** can be used for testing but is not recommended due to limitations

## 6. Tricky Interview Questions

1. **JUnit Framework**: What is JUnit? What are the important features of JUnit framework?

2. **JUnit Classes**: What are JUnit classes? List some of the important JUnit classes and their purposes.

3. **Private Test Methods**: What happens if a JUnit test method is declared as "private"? Why doesn't JUnit execute private methods?

4. **Return Types**: What happens if a JUnit test method is declared to return "String" or any non-void type?

5. **Protected Methods**: How do you test a "protected" method? Show different approaches.

6. **Private Methods**: How do you test a "private" method? What are the recommended strategies?

7. **Exception Testing**: How can you use JUnit to test that the code throws the desired exception? Show examples.

8. **Parameterized Tests**: How do you create parameterized tests in JUnit? What are the benefits?

9. **Main Method Testing**: Can you use a main() method for unit testing? What are the limitations compared to JUnit?

10. **Test Lifecycle**: Explain the JUnit test lifecycle. When are @BeforeEach and @AfterEach methods called?

11. **Garbage Collection**: When are test objects garbage collected? How does JUnit manage test instance lifecycle?

12. **Test Method Requirements**: What are the requirements for a valid JUnit test method (visibility, return type, parameters)?
