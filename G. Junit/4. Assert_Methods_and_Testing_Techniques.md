## 1. Topic Overview

Assert methods are the core of JUnit testing, providing mechanisms to verify that code behaves as expected. These methods compare actual results with expected values and fail the test if assertions are not met. JUnit provides a comprehensive set of assertion methods including assertEquals(), assertTrue(), assertFalse(), assertNull(), assertThrows(), and many others. Understanding how to use these assertions effectively, along with proper error messages and testing techniques, is crucial for writing reliable and maintainable unit tests that clearly communicate test failures.

## 2. Topic Definition

- **What**: Methods that verify expected behavior by comparing actual results with expected values, failing tests when conditions are not met
- **Why**: Provide automated verification, clear failure messages, test result documentation, and confidence in code correctness
- **How**: Through static methods in Assertions class that compare values, check conditions, and validate exceptions
- **When/Where**: In test methods to verify method outputs, object states, exception handling, and boundary conditions
- **What If**:
  - Assertions fail when expected != actual, stopping test execution
  - Custom messages help identify specific failure reasons
  - Different assertion types handle various data types and conditions
  - Assert keyword conflicts are avoided by using JUnit's assertion methods
- **Examples**:
  - Value comparison: `assertEquals(expected, actual, "Custom message")`
  - Boolean check: `assertTrue(condition, "Should be true")`
  - Exception testing: `assertThrows(Exception.class, () -> method())`

## 3. Deep Dive with Examples

```java
// File: AssertMethodsDemo.java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.time.Duration;
import java.util.*;
import java.util.function.Supplier;

/**
 * Comprehensive demonstration of JUnit assert methods and testing techniques
 */
@DisplayName("Assert Methods and Testing Techniques Demo")
public class AssertMethodsDemo {
    
    // Sample classes for testing
    static class Person {
        private String name;
        private int age;
        private String email;
        
        public Person(String name, int age, String email) {
            this.name = name;
            this.age = age;
            this.email = email;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getEmail() { return email; }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Person person = (Person) obj;
            return age == person.age && 
                   Objects.equals(name, person.name) && 
                   Objects.equals(email, person.email);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, age, email);
        }
        
        @Override
        public String toString() {
            return "Person{name='" + name + "', age=" + age + ", email='" + email + "'}";
        }
    }
    
    static class Calculator {
        public int add(int a, int b) { return a + b; }
        public int divide(int a, int b) {
            if (b == 0) throw new ArithmeticException("Division by zero");
            return a / b;
        }
        public double sqrt(double number) {
            if (number < 0) throw new IllegalArgumentException("Cannot calculate square root of negative number");
            return Math.sqrt(number);
        }
        public List<Integer> getEvenNumbers(List<Integer> numbers) {
            return numbers.stream().filter(n -> n % 2 == 0).toList();
        }
    }
    
    static class StringProcessor {
        public String process(String input) {
            if (input == null) return null;
            if (input.isEmpty()) return "";
            return input.trim().toUpperCase();
        }
        
        public boolean isValidEmail(String email) {
            return email != null && email.contains("@") && email.contains(".");
        }
    }
    
    private Calculator calculator;
    private StringProcessor stringProcessor;
    
    @BeforeEach
    void setUp() {
        calculator = new Calculator();
        stringProcessor = new StringProcessor();
    }
    
    // ========== BASIC EQUALITY ASSERTIONS ==========
    
    @Test
    @DisplayName("assertEquals - Basic Value Comparison")
    void testAssertEquals() {
        // assertEquals: Compares expected and actual values for equality
        
        // Basic equality tests
        assertEquals(5, calculator.add(2, 3), "2 + 3 should equal 5");
        assertEquals("HELLO", stringProcessor.process("  hello  "), "String processing should work");
        
        // Testing with different data types
        assertEquals(10, calculator.add(4, 6), "Addition should work with different numbers");
        assertEquals(0, calculator.add(-5, 5), "Addition with negative numbers");
        
        // Testing with floating point numbers (requires delta for precision)
        assertEquals(2.0, Math.sqrt(4), 0.001, "Square root of 4 should be 2.0");
        assertEquals(3.14159, Math.PI, 0.00001, "Pi approximation");
        
        System.out.println("✓ assertEquals tests completed");
    }
    
    @Test
    @DisplayName("assertNotEquals - Value Inequality")
    void testAssertNotEquals() {
        // assertNotEquals: Verifies that values are NOT equal
        
        assertNotEquals(10, calculator.add(2, 3), "2 + 3 should not equal 10");
        assertNotEquals("hello", stringProcessor.process("HELLO"), "Processed string should be different");
        assertNotEquals(null, stringProcessor.process("test"), "Processed string should not be null");
        
        System.out.println("✓ assertNotEquals tests completed");
    }
    
    // ========== BOOLEAN ASSERTIONS ==========
    
    @Test
    @DisplayName("assertTrue and assertFalse - Boolean Conditions")
    void testBooleanAssertions() {
        // assertTrue: Verifies condition is true
        assertTrue(5 > 3, "5 should be greater than 3");
        assertTrue(stringProcessor.isValidEmail("test@example.com"), "Valid email should return true");
        assertTrue(calculator.add(2, 3) > 0, "Sum should be positive");
        
        // assertFalse: Verifies condition is false
        assertFalse(3 > 5, "3 should not be greater than 5");
        assertFalse(stringProcessor.isValidEmail("invalid-email"), "Invalid email should return false");
        assertFalse(calculator.add(-2, -3) > 0, "Sum of negatives should not be positive");
        
        System.out.println("✓ Boolean assertion tests completed");
    }
    
    // ========== NULL ASSERTIONS ==========
    
    @Test
    @DisplayName("assertNull and assertNotNull - Null Checking")
    void testNullAssertions() {
        // assertNull: Verifies value is null
        assertNull(stringProcessor.process(null), "Processing null should return null");
        
        String nullString = null;
        assertNull(nullString, "Null string should be null");
        
        // assertNotNull: Verifies value is not null
        assertNotNull(calculator, "Calculator should be initialized");
        assertNotNull(stringProcessor.process("test"), "Processing valid string should not return null");
        assertNotNull(calculator.getEvenNumbers(Arrays.asList(1, 2, 3, 4)), "Even numbers list should not be null");
        
        System.out.println("✓ Null assertion tests completed");
    }
    
    // ========== OBJECT IDENTITY ASSERTIONS ==========
    
    @Test
    @DisplayName("assertSame and assertNotSame - Object Identity")
    void testIdentityAssertions() {
        // assertSame: Verifies two references point to the same object
        String str1 = "hello";
        String str2 = str1;
        assertSame(str1, str2, "Both references should point to same object");
        
        Calculator calc1 = calculator;
        assertSame(calculator, calc1, "References should be identical");
        
        // assertNotSame: Verifies two references point to different objects
        String str3 = new String("hello");
        String str4 = new String("hello");
        assertNotSame(str3, str4, "Different string objects should not be same");
        
        Person person1 = new Person("John", 25, "john@example.com");
        Person person2 = new Person("John", 25, "john@example.com");
        assertNotSame(person1, person2, "Different person objects should not be same");
        
        // Note: They might be equal but not same
        assertEquals(person1, person2, "Persons should be equal");
        assertNotSame(person1, person2, "But not the same object");
        
        System.out.println("✓ Identity assertion tests completed");
    }
    
    // ========== EXCEPTION ASSERTIONS ==========
    
    @Test
    @DisplayName("assertThrows - Exception Testing")
    void testAssertThrows() {
        // assertThrows: Verifies that code throws expected exception
        
        // Test arithmetic exception
        ArithmeticException arithmeticEx = assertThrows(
            ArithmeticException.class,
            () -> calculator.divide(10, 0),
            "Division by zero should throw ArithmeticException"
        );
        assertEquals("Division by zero", arithmeticEx.getMessage(), "Exception message should match");
        
        // Test illegal argument exception
        IllegalArgumentException illegalArgEx = assertThrows(
            IllegalArgumentException.class,
            () -> calculator.sqrt(-4),
            "Square root of negative number should throw IllegalArgumentException"
        );
        assertTrue(illegalArgEx.getMessage().contains("negative"), "Exception message should mention negative");
        
        // Test with lambda expression
        assertThrows(NullPointerException.class, () -> {
            String str = null;
            str.length(); // This will throw NullPointerException
        }, "Calling method on null should throw NullPointerException");
        
        System.out.println("✓ assertThrows tests completed");
    }
    
    @Test
    @DisplayName("assertDoesNotThrow - No Exception Expected")
    void testAssertDoesNotThrow() {
        // assertDoesNotThrow: Verifies that code does NOT throw any exception
        
        assertDoesNotThrow(() -> calculator.add(5, 3), "Addition should not throw exception");
        assertDoesNotThrow(() -> calculator.sqrt(9), "Square root of positive number should not throw");
        assertDoesNotThrow(() -> stringProcessor.process("test"), "String processing should not throw");
        
        // Can also capture return value
        String result = assertDoesNotThrow(() -> stringProcessor.process("hello"), "Should not throw");
        assertEquals("HELLO", result, "Result should be processed correctly");
        
        System.out.println("✓ assertDoesNotThrow tests completed");
    }
    
    // ========== TIMEOUT ASSERTIONS ==========
    
    @Test
    @DisplayName("assertTimeout - Execution Time Limits")
    void testAssertTimeout() {
        // assertTimeout: Verifies code completes within specified time
        
        assertTimeout(Duration.ofSeconds(1), () -> {
            // Simulate work that should complete quickly
            Thread.sleep(100);
            return calculator.add(2, 3);
        }, "Addition should complete within 1 second");
        
        // Test with return value
        Integer result = assertTimeout(Duration.ofMillis(500), () -> {
            return calculator.add(10, 20);
        }, "Fast calculation should complete quickly");
        assertEquals(30, result, "Result should be correct");
        
        System.out.println("✓ assertTimeout tests completed");
    }
    
    @Test
    @DisplayName("assertTimeoutPreemptively - Preemptive Timeout")
    void testAssertTimeoutPreemptively() {
        // assertTimeoutPreemptively: Terminates execution if timeout exceeded
        
        assertTimeoutPreemptively(Duration.ofMillis(100), () -> {
            // Quick operation
            return calculator.add(1, 2);
        }, "Simple addition should be very fast");
        
        System.out.println("✓ assertTimeoutPreemptively tests completed");
    }
    
    // ========== COLLECTION ASSERTIONS ==========
    
    @Test
    @DisplayName("Collection and Array Assertions")
    void testCollectionAssertions() {
        // Testing collections and arrays
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        List<Integer> evenNumbers = calculator.getEvenNumbers(numbers);
        
        // Test collection properties
        assertNotNull(evenNumbers, "Even numbers list should not be null");
        assertEquals(2, evenNumbers.size(), "Should have 2 even numbers");
        assertTrue(evenNumbers.contains(2), "Should contain 2");
        assertTrue(evenNumbers.contains(4), "Should contain 4");
        assertFalse(evenNumbers.contains(1), "Should not contain 1");
        assertFalse(evenNumbers.contains(3), "Should not contain 3");
        
        // Test array equality
        int[] expectedArray = {2, 4};
        int[] actualArray = evenNumbers.stream().mapToInt(Integer::intValue).toArray();
        assertArrayEquals(expectedArray, actualArray, "Arrays should be equal");
        
        // Test string arrays
        String[] expectedStrings = {"apple", "banana", "cherry"};
        String[] actualStrings = {"apple", "banana", "cherry"};
        assertArrayEquals(expectedStrings, actualStrings, "String arrays should be equal");
        
        System.out.println("✓ Collection assertion tests completed");
    }
    
    // ========== ITERABLE ASSERTIONS ==========
    
    @Test
    @DisplayName("assertIterableEquals - Iterable Comparison")
    void testAssertIterableEquals() {
        // assertIterableEquals: Compares iterables element by element
        
        List<String> list1 = Arrays.asList("a", "b", "c");
        List<String> list2 = Arrays.asList("a", "b", "c");
        Set<String> set1 = new LinkedHashSet<>(list1); // Maintains order
        
        assertIterableEquals(list1, list2, "Lists with same elements should be equal");
        assertIterableEquals(list1, set1, "List and set with same ordered elements should be equal");
        
        // Test with custom objects
        List<Person> persons1 = Arrays.asList(
            new Person("Alice", 25, "alice@example.com"),
            new Person("Bob", 30, "bob@example.com")
        );
        
        List<Person> persons2 = Arrays.asList(
            new Person("Alice", 25, "alice@example.com"),
            new Person("Bob", 30, "bob@example.com")
        );
        
        assertIterableEquals(persons1, persons2, "Person lists should be equal");
        
        System.out.println("✓ assertIterableEquals tests completed");
    }
    
    // ========== LINES ASSERTION ==========
    
    @Test
    @DisplayName("assertLinesMatch - String Lines Comparison")
    void testAssertLinesMatch() {
        // assertLinesMatch: Compares strings line by line (supports regex)
        
        List<String> expectedLines = Arrays.asList(
            "Line 1",
            "Line 2", 
            "Line 3"
        );
        
        List<String> actualLines = Arrays.asList(
            "Line 1",
            "Line 2",
            "Line 3"
        );
        
        assertLinesMatch(expectedLines, actualLines, "Lines should match exactly");
        
        // Test with regex patterns
        List<String> expectedPatterns = Arrays.asList(
            "\\d{4}-\\d{2}-\\d{2}", // Date pattern
            "User: .*",              // User line pattern
            "Status: (ACTIVE|INACTIVE)" // Status pattern
        );
        
        List<String> actualContent = Arrays.asList(
            "2023-12-25",
            "User: John Doe",
            "Status: ACTIVE"
        );
        
        assertLinesMatch(expectedPatterns, actualContent, "Content should match patterns");
        
        System.out.println("✓ assertLinesMatch tests completed");
    }
    
    // ========== MULTIPLE ASSERTIONS ==========
    
    @Test
    @DisplayName("assertAll - Multiple Assertions")
    void testAssertAll() {
        // assertAll: Groups multiple assertions, reports all failures
        
        Person person = new Person("John Doe", 30, "john@example.com");
        
        assertAll("Person validation",
            () -> assertNotNull(person, "Person should not be null"),
            () -> assertEquals("John Doe", person.getName(), "Name should match"),
            () -> assertEquals(30, person.getAge(), "Age should match"),
            () -> assertTrue(person.getAge() > 0, "Age should be positive"),
            () -> assertNotNull(person.getEmail(), "Email should not be null"),
            () -> assertTrue(person.getEmail().contains("@"), "Email should contain @")
        );
        
        // Test calculator with multiple assertions
        assertAll("Calculator operations",
            () -> assertEquals(8, calculator.add(3, 5), "Addition should work"),
            () -> assertEquals(2, calculator.divide(10, 5), "Division should work"),
            () -> assertThrows(ArithmeticException.class, () -> calculator.divide(5, 0), "Division by zero should throw"),
            () -> assertEquals(3.0, calculator.sqrt(9), 0.001, "Square root should work")
        );
        
        System.out.println("✓ assertAll tests completed");
    }
    
    // ========== CUSTOM ASSERTION MESSAGES ==========
    
    @Test
    @DisplayName("Custom Assertion Messages")
    void testCustomAssertionMessages() {
        // Importance of custom messages for debugging
        
        int expected = 10;
        int actual = calculator.add(4, 5);
        
        // Without custom message (not recommended)
        assertEquals(expected, actual);
        
        // With custom message (recommended)
        assertEquals(expected, actual, 
            String.format("Expected %d but got %d when adding 4 + 5", expected, actual));
        
        // Message with context
        String input = "test input";
        String result = stringProcessor.process(input);
        assertNotNull(result, "Processing input '" + input + "' should not return null");
        
        // Supplier for expensive message computation
        Supplier<String> messageSupplier = () -> {
            // This is only computed if assertion fails
            return "Expensive computation: " + System.currentTimeMillis();
        };
        assertTrue(true, messageSupplier);
        
        System.out.println("✓ Custom message tests completed");
    }
    
    // ========== ASSERT KEYWORD CONFLICT ==========
    
    @Test
    @DisplayName("Assert Keyword vs JUnit Assertions")
    void testAssertKeywordConflict() {
        // Java has 'assert' keyword, but JUnit uses assertion methods
        
        System.out.println("Java assert keyword vs JUnit assertions:");
        System.out.println("1. Java assert: Language feature, can be disabled with -da");
        System.out.println("2. JUnit assertions: Framework methods, always active");
        System.out.println("3. No conflict: Use JUnit assertions in tests");
        System.out.println("4. JUnit assertions provide better error messages");
        System.out.println("5. JUnit assertions integrate with test runners");
        
        // Java assert (not recommended in tests)
        // assert 5 == calculator.add(2, 3) : "Addition should work";
        
        // JUnit assertion (recommended)
        assertEquals(5, calculator.add(2, 3), "Addition should work");
        
        System.out.println("✓ Assert keyword explanation completed");
    }
    
    // ========== TESTING TECHNIQUES ==========
    
    @Test
    @DisplayName("Boundary Value Testing")
    void testBoundaryValues() {
        // Test boundary conditions and edge cases
        
        // Test with zero
        assertEquals(5, calculator.add(5, 0), "Adding zero should work");
        assertEquals(0, calculator.add(0, 0), "Zero plus zero should be zero");
        
        // Test with negative numbers
        assertEquals(-2, calculator.add(-5, 3), "Adding negative numbers should work");
        assertEquals(-8, calculator.add(-3, -5), "Adding two negatives should work");
        
        // Test with maximum/minimum values
        int maxInt = Integer.MAX_VALUE;
        assertEquals(maxInt, calculator.add(maxInt, 0), "Adding zero to max int should work");
        
        // Test empty strings
        assertEquals("", stringProcessor.process(""), "Empty string should remain empty");
        assertEquals("", stringProcessor.process("   "), "Whitespace-only should become empty");
        
        System.out.println("✓ Boundary value tests completed");
    }
    
    @Test
    @DisplayName("Equivalence Class Testing")
    void testEquivalenceClasses() {
        // Test representative values from different equivalence classes
        
        // Valid email equivalence class
        assertTrue(stringProcessor.isValidEmail("user@domain.com"), "Standard email should be valid");
        assertTrue(stringProcessor.isValidEmail("test.user@example.org"), "Email with dot should be valid");
        assertTrue(stringProcessor.isValidEmail("user123@test-domain.co.uk"), "Complex email should be valid");
        
        // Invalid email equivalence class
        assertFalse(stringProcessor.isValidEmail(null), "Null email should be invalid");
        assertFalse(stringProcessor.isValidEmail(""), "Empty email should be invalid");
        assertFalse(stringProcessor.isValidEmail("invalid"), "Email without @ should be invalid");
        assertFalse(stringProcessor.isValidEmail("user@"), "Email without domain should be invalid");
        assertFalse(stringProcessor.isValidEmail("@domain.com"), "Email without user should be invalid");
        
        System.out.println("✓ Equivalence class tests completed");
    }
    
    @Test
    @DisplayName("Error Condition Testing")
    void testErrorConditions() {
        // Test various error scenarios
        
        // Null input handling
        assertNull(stringProcessor.process(null), "Null input should return null");
        
        // Invalid operations
        assertThrows(ArithmeticException.class, () -> calculator.divide(1, 0), "Division by zero should throw");
        assertThrows(IllegalArgumentException.class, () -> calculator.sqrt(-1), "Negative sqrt should throw");
        
        // Empty collections
        List<Integer> emptyList = new ArrayList<>();
        List<Integer> result = calculator.getEvenNumbers(emptyList);
        assertNotNull(result, "Result should not be null for empty input");
        assertTrue(result.isEmpty(), "Result should be empty for empty input");
        
        System.out.println("✓ Error condition tests completed");
    }
    
    @Test
    @DisplayName("State-Based Testing")
    void testStateBased() {
        // Test object state changes
        
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        // Test initial state
        assertEquals(5, numbers.size(), "Initial size should be 5");
        assertTrue(numbers.contains(3), "Should contain 3 initially");
        
        // Test state after modification
        numbers.add(6);
        assertEquals(6, numbers.size(), "Size should be 6 after adding element");
        assertTrue(numbers.contains(6), "Should contain newly added element");
        
        // Test state after removal
        numbers.remove(Integer.valueOf(3));
        assertEquals(5, numbers.size(), "Size should be 5 after removing element");
        assertFalse(numbers.contains(3), "Should not contain removed element");
        
        System.out.println("✓ State-based tests completed");
    }
}

// ========== ADDITIONAL TESTING TECHNIQUES ==========

/**
 * Demonstrates advanced assertion techniques and patterns
 */
class AdvancedAssertionTechniques {
    
    @Test
    @DisplayName("Fluent Assertions Pattern")
    void testFluentAssertions() {
        // Custom fluent assertion pattern
        
        Person person = new Person("Alice", 25, "alice@example.com");
        
        // Traditional assertions
        assertNotNull(person);
        assertEquals("Alice", person.getName());
        assertEquals(25, person.getAge());
        assertTrue(person.getAge() > 18);
        
        // Grouped assertions (better)
        assertAll("Person validation",
            () -> assertNotNull(person),
            () -> assertEquals("Alice", person.getName()),
            () -> assertEquals(25, person.getAge()),
            () -> assertTrue(person.getAge() > 18)
        );
        
        System.out.println("✓ Fluent assertions demonstrated");
    }
    
    @Test
    @DisplayName("Assertion Helper Methods")
    void testAssertionHelpers() {
        // Custom helper methods for complex assertions
        
        Person person = new Person("Bob", 30, "bob@example.com");
        
        assertValidPerson(person);
        assertAdultPerson(person);
        
        System.out.println("✓ Assertion helpers demonstrated");
    }
    
    // Helper assertion methods
    private void assertValidPerson(Person person) {
        assertAll("Valid person",
            () -> assertNotNull(person, "Person should not be null"),
            () -> assertNotNull(person.getName(), "Name should not be null"),
            () -> assertFalse(person.getName().trim().isEmpty(), "Name should not be empty"),
            () -> assertTrue(person.getAge() >= 0, "Age should not be negative"),
            () -> assertNotNull(person.getEmail(), "Email should not be null"),
            () -> assertTrue(person.getEmail().contains("@"), "Email should contain @")
        );
    }
    
    private void assertAdultPerson(Person person) {
        assertTrue(person.getAge() >= 18, 
                  "Person should be adult (18+), but was " + person.getAge());
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Always provide meaningful custom messages for assertions
- Use the most specific assertion method available (assertEquals vs assertTrue)
- Test both positive and negative scenarios
- Use assertAll() to group related assertions and see all failures
- Test boundary conditions and edge cases

**Don'ts:**
- Don't use assertTrue() when more specific assertions are available
- Don't write assertions without custom failure messages
- Don't test multiple unrelated things in a single assertion
- Don't ignore the order of expected vs actual parameters
- Don't use Java's assert keyword in JUnit tests

**Common Pitfalls:**
- Swapping expected and actual parameters in assertEquals()
- Using assertEquals() for floating-point comparisons without delta
- Not testing exception messages when using assertThrows()
- Writing assertions that are too complex or hard to understand
- Forgetting to test null and empty value scenarios

## 5. Summary

- **Assert methods** provide automated verification of expected behavior in JUnit tests
- **assertEquals()** compares expected and actual values, most commonly used assertion
- **assertTrue/assertFalse()** verify boolean conditions and expressions
- **assertNull/assertNotNull()** check for null values and object initialization
- **assertThrows()** verifies that code throws expected exceptions with proper messages
- **assertAll()** groups multiple assertions and reports all failures together
- **Custom messages** are crucial for debugging and understanding test failures
- **Assert keyword conflict** avoided by using JUnit's assertion methods instead of Java's assert

## 6. Tricky Interview Questions

1. **Assert Methods**: What are assert methods in JUnit? List the most commonly used assertion methods.

2. **Assert Keyword Conflict**: In Java, assert is a keyword. Won't this conflict with JUnit's assert() method? How does JUnit handle this?

3. **assertEquals vs assertTrue**: When should you use assertEquals() vs assertTrue()? What are the advantages of each?

4. **Exception Testing**: How do you test that code throws the desired exception? Show examples with message verification.

5. **Assertion Messages**: Why are custom assertion messages important? Show examples of good vs bad assertion messages.

6. **assertAll Usage**: What is the benefit of using assertAll() over individual assertions? When should you use it?

7. **Floating Point Assertions**: How do you properly assert equality for floating-point numbers? Why is delta parameter needed?

8. **Null Testing**: What's the difference between assertNull() and assertNotNull()? When would you use each?

9. **Array vs Collection**: How do you assert equality for arrays vs collections? What methods are available?

10. **Timeout Assertions**: What's the difference between assertTimeout() and assertTimeoutPreemptively()? When would you use each?

11. **Assertion Best Practices**: What are the best practices for writing effective assertions? How do you make tests more maintainable?

12. **Custom Assertions**: How would you create custom assertion methods for domain-specific testing? Show examples.
