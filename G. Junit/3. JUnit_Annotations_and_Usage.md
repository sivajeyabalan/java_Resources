## 1. Topic Overview

JUnit annotations are metadata markers that provide instructions to the JUnit framework about how to execute tests. They eliminate the need for extending specific classes or following naming conventions, making test code cleaner and more flexible. Key annotations include @Test for marking test methods, @BeforeEach/@AfterEach for setup/teardown, @DisplayName for readable test names, @Disabled/@Ignore for skipping tests, and @ParameterizedTest for data-driven testing. Understanding these annotations and their proper usage is essential for writing effective and maintainable JUnit tests.

## 2. Topic Definition

- **What**: Metadata markers that instruct JUnit framework on test execution, setup, teardown, and configuration
- **Why**: Simplify test configuration, eliminate boilerplate code, provide declarative test behavior, improve test readability
- **How**: Applied to classes, methods, and parameters using @ syntax with optional parameters for configuration
- **When/Where**: On test methods (@Test), lifecycle methods (@BeforeEach), conditional execution (@EnabledIf), test organization (@DisplayName)
- **What If**:
  - @Test marks methods as executable tests
  - @Ignore/@Disabled skips test execution with optional reasons
  - Lifecycle annotations control test setup and cleanup
  - Conditional annotations enable environment-specific testing
- **Examples**:
  - Basic test: `@Test void testMethod() { ... }`
  - Setup: `@BeforeEach void setUp() { ... }`
  - Skip test: `@Disabled("Reason") @Test void skippedTest() { ... }`

## 3. Deep Dive with Examples

```java
// File: JUnitAnnotationsDemo.java
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.condition.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;
import static org.junit.jupiter.api.Assertions.*;
import java.time.Duration;
import java.util.stream.Stream;

/**
 * Comprehensive demonstration of JUnit annotations and their usage
 */
@DisplayName("JUnit Annotations Comprehensive Demo")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class JUnitAnnotationsDemo {
    
    // Sample class for testing
    static class Calculator {
        public int add(int a, int b) { return a + b; }
        public int subtract(int a, int b) { return a - b; }
        public int multiply(int a, int b) { return a * b; }
        public double divide(int a, int b) {
            if (b == 0) throw new ArithmeticException("Division by zero");
            return (double) a / b;
        }
        public int factorial(int n) {
            if (n < 0) throw new IllegalArgumentException("Negative number");
            return n <= 1 ? 1 : n * factorial(n - 1);
        }
    }
    
    private Calculator calculator;
    
    // ========== LIFECYCLE ANNOTATIONS ==========
    
    @BeforeAll
    @DisplayName("Class Setup")
    static void setUpClass() {
        // @BeforeAll: Runs once before all test methods in the class
        // Must be static in JUnit 5
        // Used for expensive setup operations
        
        System.out.println("=== JUnit Annotations Demo Started ===");
        System.out.println("@BeforeAll: Setting up class-level resources");
        System.out.println("- Database connections");
        System.out.println("- External service connections");
        System.out.println("- Loading configuration files");
    }
    
    @AfterAll
    @DisplayName("Class Cleanup")
    static void tearDownClass() {
        // @AfterAll: Runs once after all test methods in the class
        // Must be static in JUnit 5
        // Used for cleanup of class-level resources
        
        System.out.println("@AfterAll: Cleaning up class-level resources");
        System.out.println("- Closing database connections");
        System.out.println("- Shutting down external services");
        System.out.println("=== JUnit Annotations Demo Completed ===");
    }
    
    @BeforeEach
    @DisplayName("Test Setup")
    void setUp() {
        // @BeforeEach: Runs before each individual test method
        // Used to initialize test fixtures and ensure test isolation
        
        calculator = new Calculator();
        System.out.println("@BeforeEach: Initializing test fixtures for each test");
    }
    
    @AfterEach
    @DisplayName("Test Cleanup")
    void tearDown() {
        // @AfterEach: Runs after each individual test method
        // Used to clean up test fixtures and ensure test isolation
        
        calculator = null;
        System.out.println("@AfterEach: Cleaning up test fixtures after each test");
    }
    
    // ========== BASIC TEST ANNOTATIONS ==========
    
    @Test
    @DisplayName("Basic Test Annotation Demo")
    @Order(1)
    void basicTestAnnotationDemo() {
        // @Test: Marks a method as a test method
        // @DisplayName: Provides a custom display name for the test
        // @Order: Controls test execution order (when using @TestMethodOrder)
        
        int result = calculator.add(2, 3);
        assertEquals(5, result, "2 + 3 should equal 5");
        
        System.out.println("âœ“ @Test annotation executed successfully");
    }
    
    @Test
    @DisplayName("Test with Custom Display Name ðŸ“Š")
    @Order(2)
    void testWithCustomDisplayName() {
        // @DisplayName can include emojis and special characters
        // Improves test readability in test reports
        
        assertTrue(calculator.multiply(4, 5) == 20, 
                  "Multiplication should work correctly");
        
        System.out.println("âœ“ Custom display name with emoji works");
    }
    
    // ========== DISABLED/IGNORE ANNOTATIONS ==========
    
    @Test
    @Disabled
    @DisplayName("Disabled Test Without Reason")
    @Order(3)
    void disabledTestWithoutReason() {
        // @Disabled: Skips test execution (JUnit 5)
        // Equivalent to @Ignore in JUnit 4
        
        fail("This test should not run because it's disabled");
    }
    
    @Test
    @Disabled("Feature not yet implemented")
    @DisplayName("Disabled Test With Reason")
    @Order(4)
    void disabledTestWithReason() {
        // @Disabled with reason: Provides explanation for why test is disabled
        // Reason appears in test reports
        
        fail("This test should not run - feature pending implementation");
    }
    
    @Test
    @DisplayName("Demonstrating @Ignore Annotation Usage")
    @Order(5)
    void demonstrateIgnoreAnnotation() {
        // @Ignore annotation and how it's useful:
        
        System.out.println("@Ignore/@Disabled annotation is useful when:");
        System.out.println("1. Feature is not yet implemented");
        System.out.println("2. Test is temporarily broken due to external dependencies");
        System.out.println("3. Test needs to be excluded from certain environments");
        System.out.println("4. Test is being refactored");
        System.out.println("5. Known issues that will be fixed later");
        
        assertTrue(true, "This test demonstrates when to use @Ignore");
    }
    
    // ========== CONDITIONAL EXECUTION ANNOTATIONS ==========
    
    @Test
    @EnabledOnOs(OS.WINDOWS)
    @DisplayName("Test Only on Windows")
    @Order(6)
    void testOnlyOnWindows() {
        // @EnabledOnOs: Runs test only on specified operating systems
        
        System.out.println("âœ“ This test runs only on Windows OS");
        assertTrue(true, "Windows-specific functionality");
    }
    
    @Test
    @EnabledOnOs({OS.LINUX, OS.MAC})
    @DisplayName("Test Only on Unix-like Systems")
    @Order(7)
    void testOnlyOnUnixLike() {
        // Multiple OS values can be specified
        
        System.out.println("âœ“ This test runs only on Linux or Mac");
        assertTrue(true, "Unix-specific functionality");
    }
    
    @Test
    @DisabledOnOs(OS.WINDOWS)
    @DisplayName("Test Disabled on Windows")
    @Order(8)
    void testDisabledOnWindows() {
        // @DisabledOnOs: Skips test on specified operating systems
        
        System.out.println("âœ“ This test is disabled on Windows");
        assertTrue(true, "Non-Windows functionality");
    }
    
    @Test
    @EnabledOnJre(JRE.JAVA_11)
    @DisplayName("Test Only on Java 11")
    @Order(9)
    void testOnlyOnJava11() {
        // @EnabledOnJre: Runs test only on specified Java versions
        
        System.out.println("âœ“ This test runs only on Java 11");
        assertTrue(true, "Java 11 specific features");
    }
    
    @Test
    @EnabledForJreRange(min = JRE.JAVA_8, max = JRE.JAVA_11)
    @DisplayName("Test for Java 8-11 Range")
    @Order(10)
    void testForJavaRange() {
        // @EnabledForJreRange: Runs test for a range of Java versions
        
        System.out.println("âœ“ This test runs on Java 8 through 11");
        assertTrue(true, "Compatible with Java 8-11");
    }
    
    @Test
    @EnabledIf("java.awt.GraphicsEnvironment#isHeadless")
    @DisplayName("Test with Custom Condition")
    @Order(11)
    void testWithCustomCondition() {
        // @EnabledIf: Runs test based on custom condition
        // Can reference system properties, environment variables, or methods
        
        System.out.println("âœ“ This test runs based on custom condition");
        assertTrue(true, "Custom condition met");
    }
    
    @Test
    @EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
    @DisplayName("Test Only on 64-bit Architecture")
    @Order(12)
    void testOnlyOn64Bit() {
        // @EnabledIfSystemProperty: Runs test based on system property
        
        System.out.println("âœ“ This test runs only on 64-bit systems");
        assertTrue(true, "64-bit specific functionality");
    }
    
    @Test
    @EnabledIfEnvironmentVariable(named = "ENV", matches = "test")
    @DisplayName("Test Only in Test Environment")
    @Order(13)
    void testOnlyInTestEnvironment() {
        // @EnabledIfEnvironmentVariable: Runs test based on environment variable
        
        System.out.println("âœ“ This test runs only when ENV=test");
        assertTrue(true, "Test environment specific");
    }
    
    // ========== TIMEOUT ANNOTATIONS ==========
    
    @Test
    @Timeout(1) // 1 second timeout
    @DisplayName("Test with Timeout Annotation")
    @Order(14)
    void testWithTimeout() throws InterruptedException {
        // @Timeout: Specifies maximum execution time for test
        // Test fails if it takes longer than specified time
        
        Thread.sleep(500); // Simulate work that takes 0.5 seconds
        
        assertEquals(6, calculator.factorial(3), "3! should equal 6");
        
        System.out.println("âœ“ Test completed within timeout");
    }
    
    @Test
    @Timeout(value = 2, unit = java.util.concurrent.TimeUnit.SECONDS)
    @DisplayName("Test with Custom Timeout Unit")
    @Order(15)
    void testWithCustomTimeoutUnit() {
        // @Timeout with custom time unit
        
        int result = calculator.multiply(100, 200);
        assertEquals(20000, result, "Multiplication should complete quickly");
        
        System.out.println("âœ“ Test with custom timeout unit completed");
    }
    
    // ========== PARAMETERIZED TEST ANNOTATIONS ==========
    
    @ParameterizedTest
    @DisplayName("Parameterized Test with Value Source")
    @ValueSource(ints = {1, 2, 3, 4, 5})
    @Order(16)
    void parameterizedTestWithValueSource(int number) {
        // @ParameterizedTest: Marks method as parameterized test
        // @ValueSource: Provides array of values for single parameter
        
        int factorial = calculator.factorial(number);
        assertTrue(factorial > 0, "Factorial of " + number + " should be positive");
        
        System.out.println("âœ“ Factorial of " + number + " = " + factorial);
    }
    
    @ParameterizedTest
    @DisplayName("Parameterized Test with CSV Source")
    @CsvSource({
        "1, 1",
        "2, 2", 
        "3, 6",
        "4, 24",
        "5, 120"
    })
    @Order(17)
    void parameterizedTestWithCsvSource(int input, int expected) {
        // @CsvSource: Provides CSV data for multiple parameters
        
        int actual = calculator.factorial(input);
        assertEquals(expected, actual, 
                    "Factorial of " + input + " should be " + expected);
        
        System.out.println("âœ“ " + input + "! = " + actual);
    }
    
    @ParameterizedTest
    @DisplayName("Parameterized Test with Method Source")
    @MethodSource("provideAdditionData")
    @Order(18)
    void parameterizedTestWithMethodSource(int a, int b, int expected) {
        // @MethodSource: Uses method to provide test data
        
        int actual = calculator.add(a, b);
        assertEquals(expected, actual, 
                    a + " + " + b + " should equal " + expected);
        
        System.out.println("âœ“ " + a + " + " + b + " = " + actual);
    }
    
    // Method source for parameterized test
    static Stream<org.junit.jupiter.params.provider.Arguments> provideAdditionData() {
        return Stream.of(
            org.junit.jupiter.params.provider.Arguments.of(1, 2, 3),
            org.junit.jupiter.params.provider.Arguments.of(5, 7, 12),
            org.junit.jupiter.params.provider.Arguments.of(-1, 1, 0),
            org.junit.jupiter.params.provider.Arguments.of(0, 0, 0)
        );
    }
    
    @ParameterizedTest
    @DisplayName("Parameterized Test with Enum Source")
    @EnumSource(TimeUnit.class)
    @Order(19)
    void parameterizedTestWithEnumSource(TimeUnit timeUnit) {
        // @EnumSource: Uses enum values as test parameters
        
        assertNotNull(timeUnit, "TimeUnit should not be null");
        System.out.println("âœ“ Testing with TimeUnit: " + timeUnit);
    }
    
    enum TimeUnit {
        SECONDS, MINUTES, HOURS, DAYS
    }
    
    // ========== REPEATED TEST ANNOTATIONS ==========
    
    @RepeatedTest(3)
    @DisplayName("Repeated Test Example")
    @Order(20)
    void repeatedTestExample(RepetitionInfo repetitionInfo) {
        // @RepeatedTest: Runs test multiple times
        // RepetitionInfo provides information about current repetition
        
        int current = repetitionInfo.getCurrentRepetition();
        int total = repetitionInfo.getTotalRepetitions();
        
        assertTrue(calculator.add(2, 2) == 4, "Addition should work consistently");
        
        System.out.println("âœ“ Repeated test execution: " + current + "/" + total);
    }
    
    @RepeatedTest(value = 2, name = "Custom Repetition {currentRepetition}/{totalRepetitions}")
    @DisplayName("Repeated Test with Custom Name")
    @Order(21)
    void repeatedTestWithCustomName() {
        // Custom name pattern for repeated tests
        
        assertNotNull(calculator, "Calculator should be initialized");
        System.out.println("âœ“ Custom named repetition executed");
    }
    
    // ========== NESTED TEST ANNOTATIONS ==========
    
    @Nested
    @DisplayName("Calculator Addition Tests")
    @Order(22)
    class CalculatorAdditionTests {
        // @Nested: Groups related tests together
        // Provides better test organization and reporting
        
        @Test
        @DisplayName("Test Positive Numbers Addition")
        void testPositiveAddition() {
            assertEquals(8, calculator.add(3, 5), "Positive addition should work");
            System.out.println("âœ“ Nested test: Positive addition");
        }
        
        @Test
        @DisplayName("Test Negative Numbers Addition")
        void testNegativeAddition() {
            assertEquals(-2, calculator.add(-5, 3), "Negative addition should work");
            System.out.println("âœ“ Nested test: Negative addition");
        }
        
        @Test
        @DisplayName("Test Zero Addition")
        void testZeroAddition() {
            assertEquals(5, calculator.add(5, 0), "Adding zero should work");
            assertEquals(0, calculator.add(0, 0), "Zero plus zero should be zero");
            System.out.println("âœ“ Nested test: Zero addition");
        }
    }
    
    // ========== TAG ANNOTATIONS ==========
    
    @Test
    @Tag("fast")
    @DisplayName("Fast Test Example")
    @Order(23)
    void fastTestExample() {
        // @Tag: Categorizes tests for selective execution
        // Can run only tests with specific tags
        
        assertEquals(10, calculator.multiply(2, 5), "Fast multiplication test");
        System.out.println("âœ“ Fast test completed");
    }
    
    @Test
    @Tag("slow")
    @Tag("integration")
    @DisplayName("Slow Integration Test Example")
    @Order(24)
    void slowIntegrationTestExample() throws InterruptedException {
        // Multiple tags can be applied to a single test
        
        Thread.sleep(100); // Simulate slow operation
        assertTrue(calculator.factorial(5) == 120, "Slow factorial calculation");
        System.out.println("âœ“ Slow integration test completed");
    }
    
    // ========== CUSTOM ANNOTATIONS ==========
    
    // Custom annotation combining multiple JUnit annotations
    @Target({ElementType.METHOD})
    @Retention(RetentionPolicy.RUNTIME)
    @Test
    @Tag("unit")
    @DisplayName("Unit Test")
    public @interface UnitTest {
        String value() default "";
    }
    
    @UnitTest("Custom annotation example")
    @Order(25)
    void customAnnotationExample() {
        // Custom annotation that combines @Test, @Tag, and @DisplayName
        
        assertEquals(2, calculator.subtract(5, 3), "Subtraction should work");
        System.out.println("âœ“ Custom annotation test completed");
    }
    
    // ========== EXTENSION ANNOTATIONS ==========
    
    @ExtendWith(CustomTestExtension.class)
    @Test
    @DisplayName("Test with Custom Extension")
    @Order(26)
    void testWithCustomExtension() {
        // @ExtendWith: Registers extensions for additional functionality
        
        assertTrue(true, "Test with custom extension");
        System.out.println("âœ“ Test with custom extension completed");
    }
    
    // Simple custom extension
    static class CustomTestExtension implements org.junit.jupiter.api.extension.BeforeEachCallback {
        @Override
        public void beforeEach(org.junit.jupiter.api.extension.ExtensionContext context) {
            System.out.println("Custom extension: Before each test execution");
        }
    }
    
    // ========== DEMONSTRATION METHODS ==========
    
    @Test
    @DisplayName("Annotations vs Traditional Approach")
    @Order(27)
    void demonstrateAnnotationsVsTraditional() {
        // Annotations provide several advantages over traditional approaches:
        
        System.out.println("Annotations advantages:");
        System.out.println("1. No need to extend TestCase class");
        System.out.println("2. No naming conventions required (testXxx methods)");
        System.out.println("3. Declarative configuration");
        System.out.println("4. Better IDE support and tooling");
        System.out.println("5. More flexible test organization");
        System.out.println("6. Conditional test execution");
        System.out.println("7. Parameterized testing support");
        System.out.println("8. Custom display names");
        
        assertTrue(true, "Annotations make testing more flexible and powerful");
    }
    
    @Test
    @DisplayName("How Annotations Are Useful in JUnit")
    @Order(28)
    void demonstrateHowAnnotationsAreUseful() {
        // Annotations are useful in JUnit because they:
        
        System.out.println("How annotations are useful in JUnit:");
        System.out.println("1. Eliminate boilerplate code");
        System.out.println("2. Provide metadata about test behavior");
        System.out.println("3. Enable conditional test execution");
        System.out.println("4. Support parameterized and repeated tests");
        System.out.println("5. Improve test readability and documentation");
        System.out.println("6. Allow custom test configurations");
        System.out.println("7. Enable test categorization with tags");
        System.out.println("8. Support lifecycle management");
        
        assertNotNull(calculator, "Test fixtures should be properly initialized");
    }
}

// ========== ADDITIONAL ANNOTATION EXAMPLES ==========

/**
 * Class demonstrating test method ordering annotations
 */
@TestMethodOrder(MethodOrderer.DisplayName.class)
class TestOrderingDemo {
    
    @Test
    @DisplayName("A - First Test")
    void firstTest() {
        System.out.println("First test (alphabetically by display name)");
        assertTrue(true);
    }
    
    @Test
    @DisplayName("B - Second Test") 
    void secondTest() {
        System.out.println("Second test (alphabetically by display name)");
        assertTrue(true);
    }
    
    @Test
    @DisplayName("C - Third Test")
    void thirdTest() {
        System.out.println("Third test (alphabetically by display name)");
        assertTrue(true);
    }
}

/**
 * Class demonstrating test instance lifecycle annotations
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TestInstanceLifecycleDemo {
    // @TestInstance(PER_CLASS): Creates one test instance for all test methods
    // Default is PER_METHOD (new instance for each test method)
    
    private int counter = 0;
    
    @BeforeAll
    void setUpClass() {
        // Can be non-static when using PER_CLASS lifecycle
        System.out.println("Setting up class (non-static with PER_CLASS)");
    }
    
    @Test
    void firstTest() {
        counter++;
        System.out.println("First test, counter: " + counter);
        assertEquals(1, counter);
    }
    
    @Test
    void secondTest() {
        counter++;
        System.out.println("Second test, counter: " + counter);
        assertEquals(2, counter); // This works with PER_CLASS lifecycle
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use @DisplayName to provide meaningful test descriptions
- Apply @BeforeEach/@AfterEach for proper test isolation
- Use @Disabled with reasons when temporarily skipping tests
- Leverage conditional annotations for environment-specific tests
- Use @ParameterizedTest for testing multiple input values

**Don'ts:**
- Don't forget to remove @Disabled when tests are fixed
- Don't use @BeforeAll/@AfterAll for test-specific setup
- Don't rely on test execution order unless explicitly ordered
- Don't overuse nested tests (keep hierarchy simple)
- Don't ignore timeout annotations in performance-critical tests

**Common Pitfalls:**
- Forgetting that @BeforeAll/@AfterAll methods must be static (unless using PER_CLASS lifecycle)
- Using @Disabled without providing a reason for future reference
- Creating complex conditional logic that makes tests hard to understand
- Not cleaning up resources properly in @AfterEach methods
- Overusing tags without a clear categorization strategy

## 5. Summary

- **Annotations** provide metadata to JUnit framework for test configuration and execution control
- **@Test** marks methods as executable tests, eliminating need for naming conventions
- **@Disabled/@Ignore** skips test execution with optional reasons for documentation
- **Lifecycle annotations** (@BeforeAll, @BeforeEach, @AfterEach, @AfterAll) manage test setup and cleanup
- **Conditional annotations** enable environment-specific test execution based on OS, Java version, or custom conditions
- **@ParameterizedTest** supports data-driven testing with various data sources
- **@DisplayName** improves test readability and reporting with custom names
- **Annotations are useful** because they eliminate boilerplate code, provide declarative configuration, and improve test organization

## 6. Tricky Interview Questions

1. **Annotations Purpose**: What are annotations and how are they useful in JUnit? Compare with traditional approaches.

2. **@Ignore Annotation**: What is @Ignore annotation and how is this useful? When should you use it?

3. **Lifecycle Annotations**: Explain the difference between @BeforeAll, @BeforeEach, @AfterEach, and @AfterAll. When is each used?

4. **Conditional Execution**: How do you run tests only on specific operating systems or Java versions? Show examples.

5. **Parameterized Tests**: How do you create parameterized tests using annotations? What are the different data sources available?

6. **Test Method Requirements**: What are the requirements for methods annotated with @Test? What about visibility and return types?

7. **@Disabled vs @Ignore**: What's the difference between @Disabled (JUnit 5) and @Ignore (JUnit 4)? How do you provide reasons?

8. **Custom Annotations**: How can you create custom annotations that combine multiple JUnit annotations?

9. **Test Ordering**: How do you control the order of test execution using annotations? What are the different ordering strategies?

10. **Nested Tests**: How do @Nested annotations help organize tests? What are the benefits and limitations?

11. **Extension Annotations**: What is @ExtendWith annotation used for? How do you create and register custom extensions?

12. **Tag Annotations**: How do @Tag annotations help in test organization? How can you run only specific tagged tests?
