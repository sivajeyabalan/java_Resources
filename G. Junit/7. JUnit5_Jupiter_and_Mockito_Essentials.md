## 1. Topic Overview

- JUnit 5 (Jupiter) is the modern testing platform; Mockito provides flexible test doubles for isolation.

## 2 . Topic definition

- WHAT: Jupiter annotations (`@Test`, `@BeforeEach`, `@Nested`, `@ParameterizedTest`), assertions, assumptions; Mockito stubbing/verification.
- WHY: Write maintainable, expressive unit tests.
- HOW: Use Jupiter engine, write parameterized tests, mock dependencies with Mockito or use @Mock/@InjectMocks.
- WHEN/WHERE: Unit tests at class level; integration tests with Boot slices elsewhere.

## 3. Deep Dive with Examples

```java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    @BeforeEach void setup() {}
    @Test void adds() { assertEquals(4, 2 + 2); }
    @ParameterizedTest @ValueSource(strings = {"a","bb"})
    void lengths(String s) { assertTrue(s.length() >= 1); }
}
```

```java
// Mockito
import org.junit.jupiter.api.*;
import org.mockito.*;
import static org.mockito.Mockito.*;

class Service { Repo repo; Service(Repo r){this.repo=r;} String greet(){ return "hi " + repo.name(); } }
interface Repo { String name(); }

class ServiceTest {
    @Mock Repo repo; @InjectMocks Service svc;
    @BeforeEach void init() { MockitoAnnotations.openMocks(this); }
    @Test void greet() {
        when(repo.name()).thenReturn("ann");
        assertEquals("hi ann", svc.greet());
        verify(repo).name();
    }
}
```

## 4. Best Practices & Pitfalls

- Keep tests deterministic; avoid time/randomness without control.
- Prefer parameterized tests for matrix coverage.
- Donâ€™t overuse mocks; test behavior, not implementation details.

## 5. Summary

- JUnit 5 + Mockito covers modern unit testing needs with clarity and power.

## 6. Tricky Interview Questions

1. When to mock vs use in-memory fakes?
2. How to structure parameterized tests and custom argument sources?

