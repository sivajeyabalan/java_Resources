## 1. Topic Overview

Java provides multiple approaches for file operations: traditional IO (java.io package) and New IO (NIO/NIO.2 in java.nio package). Traditional IO uses streams and is suitable for sequential access, while NIO.2 (introduced in Java 7) provides the Files class with utility methods for common file operations, better performance, and more comprehensive file system support. Understanding both approaches is essential as legacy code uses traditional IO while modern applications benefit from NIO.2's convenience and performance improvements.

## 2. Topic Definition

- **What**: File operations using traditional IO streams vs modern NIO.2 Files class and Path interface
- **Why**: Enable file creation, reading, writing, copying, moving, and metadata operations with better performance and convenience
- **How**: Traditional IO uses FileInputStream/FileOutputStream/FileReader/FileWriter; NIO.2 uses Files static methods with Path objects
- **When/Where**: File processing applications, configuration management, data persistence, log file handling, backup systems
- **What If**:
  - Traditional IO requires manual resource management and exception handling
  - NIO.2 provides atomic operations and better error reporting
  - Path objects are more flexible than File objects for cross-platform compatibility
  - Memory-mapped files enable efficient large file processing
- **Examples**:
  - Traditional: `new FileInputStream("file.txt")`
  - NIO.2: `Files.readAllLines(Paths.get("file.txt"))`
  - Path operations: `path.resolve("subdir").normalize()`

## 3. Deep Dive with Examples

```java
// File: FileOperationsDemo.java
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Stream;

public class FileOperationsDemo {
    public static void main(String[] args) {
        demonstrateTraditionalFileIO();
        demonstrateNIOBasics();
        demonstratePathOperations();
        demonstrateFileOperations();
        demonstrateDirectoryOperations();
        demonstrateFileAttributes();
        demonstrateAdvancedNIOFeatures();
    }
    
    static void demonstrateTraditionalFileIO() {
        System.out.println("=== Traditional File IO (java.io) ===");
        
        String fileName = "traditional_io_demo.txt";
        String content = "Line 1: Traditional IO\nLine 2: Using streams\nLine 3: Manual resource management";
        
        try {
            // Writing with traditional IO
            System.out.println("--- Writing with FileWriter ---");
            try (FileWriter writer = new FileWriter(fileName)) {
                writer.write(content);
                System.out.println("Successfully wrote to " + fileName);
            }
            
            // Reading with traditional IO
            System.out.println("\n--- Reading with FileReader ---");
            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
                String line;
                int lineNumber = 1;
                while ((line = reader.readLine()) != null) {
                    System.out.printf("Line %d: %s%n", lineNumber++, line);
                }
            }
            
            // File operations with File class
            System.out.println("\n--- File class operations ---");
            File file = new File(fileName);
            System.out.println("File exists: " + file.exists());
            System.out.println("File size: " + file.length() + " bytes");
            System.out.println("Last modified: " + new Date(file.lastModified()));
            System.out.println("Can read: " + file.canRead());
            System.out.println("Can write: " + file.canWrite());
            System.out.println("Is file: " + file.isFile());
            System.out.println("Is directory: " + file.isDirectory());
            System.out.println("Absolute path: " + file.getAbsolutePath());
            
            // Copy file using traditional IO
            System.out.println("\n--- Copying file (traditional way) ---");
            String copyName = "traditional_copy.txt";
            try (FileInputStream input = new FileInputStream(fileName);
                 FileOutputStream output = new FileOutputStream(copyName)) {
                
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = input.read(buffer)) != -1) {
                    output.write(buffer, 0, bytesRead);
                }
                System.out.println("File copied to " + copyName);
            }
            
            // Cleanup
            new File(copyName).delete();
            
        } catch (IOException e) {
            System.err.println("Traditional IO error: " + e.getMessage());
        } finally {
            new File(fileName).delete();
        }
    }
    
    static void demonstrateNIOBasics() {
        System.out.println("\n=== NIO.2 Basics (java.nio.file) ===");
        
        Path filePath = Paths.get("nio_demo.txt");
        List<String> lines = Arrays.asList(
            "Line 1: NIO.2 demonstration",
            "Line 2: Modern file operations", 
            "Line 3: Simplified API"
        );
        
        try {
            // Writing with NIO.2
            System.out.println("--- Writing with Files.write() ---");
            Files.write(filePath, lines, StandardCharsets.UTF_8);
            System.out.println("Successfully wrote to " + filePath);
            
            // Reading with NIO.2
            System.out.println("\n--- Reading with Files.readAllLines() ---");
            List<String> readLines = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            for (int i = 0; i < readLines.size(); i++) {
                System.out.printf("Line %d: %s%n", i + 1, readLines.get(i));
            }
            
            // Reading as String (Java 11+)
            System.out.println("\n--- Reading entire file as String ---");
            String entireContent = Files.readString(filePath, StandardCharsets.UTF_8);
            System.out.println("Entire content:\n" + entireContent);
            
            // File information with NIO.2
            System.out.println("\n--- File information (NIO.2) ---");
            System.out.println("File exists: " + Files.exists(filePath));
            System.out.println("File size: " + Files.size(filePath) + " bytes");
            System.out.println("Is regular file: " + Files.isRegularFile(filePath));
            System.out.println("Is directory: " + Files.isDirectory(filePath));
            System.out.println("Is readable: " + Files.isReadable(filePath));
            System.out.println("Is writable: " + Files.isWritable(filePath));
            System.out.println("Is executable: " + Files.isExecutable(filePath));
            
            // Copy file with NIO.2
            System.out.println("\n--- Copying file (NIO.2 way) ---");
            Path copyPath = Paths.get("nio_copy.txt");
            Files.copy(filePath, copyPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File copied to " + copyPath);
            
            // Compare traditional vs NIO.2 approach
            System.out.println("\n--- Traditional vs NIO.2 Comparison ---");
            System.out.println("Traditional: Multiple lines of code, manual resource management");
            System.out.println("NIO.2: Single method call, automatic resource management");
            System.out.println("NIO.2: Better error messages and atomic operations");
            
            // Cleanup
            Files.deleteIfExists(copyPath);
            
        } catch (IOException e) {
            System.err.println("NIO.2 error: " + e.getMessage());
        } finally {
            try {
                Files.deleteIfExists(filePath);
            } catch (IOException e) {
                System.err.println("Cleanup error: " + e.getMessage());
            }
        }
    }
    
    static void demonstratePathOperations() {
        System.out.println("\n=== Path Operations ===");
        
        // Creating paths
        System.out.println("--- Creating Paths ---");
        Path path1 = Paths.get("folder", "subfolder", "file.txt");
        Path path2 = Paths.get("/home/user/documents/file.txt");
        Path path3 = Paths.get("C:\\Users\\User\\Documents\\file.txt");
        
        System.out.println("Relative path: " + path1);
        System.out.println("Unix absolute path: " + path2);
        System.out.println("Windows absolute path: " + path3);
        
        // Path components
        System.out.println("\n--- Path Components ---");
        Path examplePath = Paths.get("/home/user/documents/project/src/Main.java");
        System.out.println("Full path: " + examplePath);
        System.out.println("File name: " + examplePath.getFileName());
        System.out.println("Parent: " + examplePath.getParent());
        System.out.println("Root: " + examplePath.getRoot());
        System.out.println("Name count: " + examplePath.getNameCount());
        
        for (int i = 0; i < examplePath.getNameCount(); i++) {
            System.out.printf("  Name[%d]: %s%n", i, examplePath.getName(i));
        }
        
        // Path operations
        System.out.println("\n--- Path Operations ---");
        Path basePath = Paths.get("/home/user");
        Path relativePath = Paths.get("documents/file.txt");
        
        Path resolvedPath = basePath.resolve(relativePath);
        System.out.println("Resolved: " + basePath + " + " + relativePath + " = " + resolvedPath);
        
        Path siblingPath = Paths.get("file.txt").resolveSibling("other.txt");
        System.out.println("Sibling: " + siblingPath);
        
        // Normalize paths
        Path messyPath = Paths.get("/home/user/../user/./documents/../documents/file.txt");
        Path normalizedPath = messyPath.normalize();
        System.out.println("Messy path: " + messyPath);
        System.out.println("Normalized: " + normalizedPath);
        
        // Relativize paths
        Path path1Abs = Paths.get("/home/user/documents/file1.txt");
        Path path2Abs = Paths.get("/home/user/pictures/file2.txt");
        Path relativeBetween = path1Abs.relativize(path2Abs);
        System.out.println("Relative from " + path1Abs + " to " + path2Abs + ": " + relativeBetween);
        
        // Path comparison
        System.out.println("\n--- Path Comparison ---");
        Path pathA = Paths.get("file.txt");
        Path pathB = Paths.get("./file.txt");
        Path pathC = Paths.get("FILE.TXT");
        
        System.out.println("pathA equals pathB: " + pathA.equals(pathB));
        System.out.println("pathA equals pathC: " + pathA.equals(pathC));
        System.out.println("Paths are case-sensitive on most systems");
    }
    
    static void demonstrateFileOperations() {
        System.out.println("\n=== File Operations with NIO.2 ===");
        
        try {
            // Create test files
            Path sourceFile = Paths.get("source.txt");
            Path targetFile = Paths.get("target.txt");
            Path backupFile = Paths.get("backup.txt");
            
            // Create and write to source file
            List<String> content = Arrays.asList("Hello", "World", "NIO.2", "File Operations");
            Files.write(sourceFile, content);
            System.out.println("Created source file: " + sourceFile);
            
            // Copy operations
            System.out.println("\n--- Copy Operations ---");
            Files.copy(sourceFile, targetFile);
            System.out.println("Copied to target file");
            
            // Copy with options
            Files.copy(sourceFile, backupFile, 
                      StandardCopyOption.REPLACE_EXISTING,
                      StandardCopyOption.COPY_ATTRIBUTES);
            System.out.println("Copied with options (replace existing, copy attributes)");
            
            // Move operations
            System.out.println("\n--- Move Operations ---");
            Path movedFile = Paths.get("moved.txt");
            Files.move(targetFile, movedFile, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Moved target file to: " + movedFile);
            
            // Delete operations
            System.out.println("\n--- Delete Operations ---");
            boolean deleted = Files.deleteIfExists(backupFile);
            System.out.println("Deleted backup file: " + deleted);
            
            try {
                Files.delete(Paths.get("nonexistent.txt"));
            } catch (NoSuchFileException e) {
                System.out.println("Expected exception when deleting non-existent file: " + e.getClass().getSimpleName());
            }
            
            // File comparison
            System.out.println("\n--- File Comparison ---");
            Path file1 = sourceFile;
            Path file2 = movedFile;
            
            long mismatch = Files.mismatch(file1, file2);
            if (mismatch == -1) {
                System.out.println("Files are identical");
            } else {
                System.out.println("Files differ at byte position: " + mismatch);
            }
            
            // Cleanup
            Files.deleteIfExists(sourceFile);
            Files.deleteIfExists(movedFile);
            
        } catch (IOException e) {
            System.err.println("File operations error: " + e.getMessage());
        }
    }
    
    static void demonstrateDirectoryOperations() {
        System.out.println("\n=== Directory Operations ===");
        
        try {
            // Create directory structure
            Path baseDir = Paths.get("test_directory");
            Path subDir1 = baseDir.resolve("subdir1");
            Path subDir2 = baseDir.resolve("subdir2");
            Path deepDir = subDir1.resolve("deep").resolve("nested");
            
            System.out.println("--- Creating Directories ---");
            Files.createDirectories(deepDir); // Creates all parent directories
            Files.createDirectory(subDir2);   // Creates single directory
            System.out.println("Created directory structure: " + baseDir);
            
            // Create some files
            Files.write(baseDir.resolve("file1.txt"), Arrays.asList("Content 1"));
            Files.write(subDir1.resolve("file2.txt"), Arrays.asList("Content 2"));
            Files.write(deepDir.resolve("file3.txt"), Arrays.asList("Content 3"));
            
            // List directory contents
            System.out.println("\n--- Listing Directory Contents ---");
            System.out.println("Contents of " + baseDir + ":");
            try (Stream<Path> paths = Files.list(baseDir)) {
                paths.forEach(path -> {
                    try {
                        String type = Files.isDirectory(path) ? "[DIR]" : "[FILE]";
                        System.out.printf("  %s %s%n", type, path.getFileName());
                    } catch (Exception e) {
                        System.err.println("Error checking path: " + e.getMessage());
                    }
                });
            }
            
            // Walk directory tree
            System.out.println("\n--- Walking Directory Tree ---");
            System.out.println("All files and directories:");
            try (Stream<Path> paths = Files.walk(baseDir)) {
                paths.forEach(path -> {
                    try {
                        String indent = "  ".repeat(baseDir.relativize(path).getNameCount() - 1);
                        String type = Files.isDirectory(path) ? "[DIR]" : "[FILE]";
                        System.out.printf("%s%s %s%n", indent, type, path.getFileName());
                    } catch (Exception e) {
                        System.err.println("Error processing path: " + e.getMessage());
                    }
                });
            }
            
            // Find files
            System.out.println("\n--- Finding Files ---");
            System.out.println("All .txt files:");
            try (Stream<Path> paths = Files.find(baseDir, Integer.MAX_VALUE,
                    (path, attrs) -> path.toString().endsWith(".txt"))) {
                paths.forEach(path -> System.out.println("  " + path));
            }
            
            // Directory size calculation
            System.out.println("\n--- Directory Size ---");
            long totalSize = Files.walk(baseDir)
                .filter(Files::isRegularFile)
                .mapToLong(path -> {
                    try {
                        return Files.size(path);
                    } catch (IOException e) {
                        return 0;
                    }
                })
                .sum();
            System.out.println("Total size of directory: " + totalSize + " bytes");
            
            // Cleanup - delete directory tree
            System.out.println("\n--- Cleaning Up ---");
            Files.walk(baseDir)
                .sorted(Comparator.reverseOrder()) // Delete files before directories
                .forEach(path -> {
                    try {
                        Files.delete(path);
                    } catch (IOException e) {
                        System.err.println("Error deleting: " + path);
                    }
                });
            System.out.println("Deleted directory tree");
            
        } catch (IOException e) {
            System.err.println("Directory operations error: " + e.getMessage());
        }
    }
    
    static void demonstrateFileAttributes() {
        System.out.println("\n=== File Attributes ===");
        
        Path testFile = Paths.get("attributes_test.txt");
        
        try {
            // Create test file
            Files.write(testFile, Arrays.asList("Test file for attributes"));
            
            // Basic attributes
            System.out.println("--- Basic Attributes ---");
            BasicFileAttributes attrs = Files.readAttributes(testFile, BasicFileAttributes.class);
            
            System.out.println("Creation time: " + attrs.creationTime());
            System.out.println("Last modified: " + attrs.lastModifiedTime());
            System.out.println("Last accessed: " + attrs.lastAccessTime());
            System.out.println("Size: " + attrs.size() + " bytes");
            System.out.println("Is directory: " + attrs.isDirectory());
            System.out.println("Is regular file: " + attrs.isRegularFile());
            System.out.println("Is symbolic link: " + attrs.isSymbolicLink());
            
            // File permissions (POSIX systems)
            if (FileSystems.getDefault().supportedFileAttributeViews().contains("posix")) {
                System.out.println("\n--- POSIX Attributes ---");
                PosixFileAttributes posixAttrs = Files.readAttributes(testFile, PosixFileAttributes.class);
                System.out.println("Owner: " + posixAttrs.owner());
                System.out.println("Group: " + posixAttrs.group());
                System.out.println("Permissions: " + PosixFilePermissions.toString(posixAttrs.permissions()));
            } else {
                System.out.println("\n--- File Permissions (Non-POSIX) ---");
                System.out.println("Readable: " + Files.isReadable(testFile));
                System.out.println("Writable: " + Files.isWritable(testFile));
                System.out.println("Executable: " + Files.isExecutable(testFile));
            }
            
            // Modify attributes
            System.out.println("\n--- Modifying Attributes ---");
            FileTime newTime = FileTime.fromMillis(System.currentTimeMillis() - 86400000); // 1 day ago
            Files.setLastModifiedTime(testFile, newTime);
            System.out.println("Set last modified time to 1 day ago");
            
            BasicFileAttributes newAttrs = Files.readAttributes(testFile, BasicFileAttributes.class);
            System.out.println("New last modified: " + newAttrs.lastModifiedTime());
            
            // File store information
            System.out.println("\n--- File Store Information ---");
            FileStore store = Files.getFileStore(testFile);
            System.out.println("File store: " + store.name());
            System.out.println("Type: " + store.type());
            System.out.println("Total space: " + formatBytes(store.getTotalSpace()));
            System.out.println("Usable space: " + formatBytes(store.getUsableSpace()));
            System.out.println("Unallocated space: " + formatBytes(store.getUnallocatedSpace()));
            
        } catch (IOException e) {
            System.err.println("File attributes error: " + e.getMessage());
        } finally {
            try {
                Files.deleteIfExists(testFile);
            } catch (IOException e) {
                System.err.println("Cleanup error: " + e.getMessage());
            }
        }
    }
    
    static String formatBytes(long bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return String.format("%.1f KB", bytes / 1024.0);
        if (bytes < 1024 * 1024 * 1024) return String.format("%.1f MB", bytes / (1024.0 * 1024));
        return String.format("%.1f GB", bytes / (1024.0 * 1024 * 1024));
    }
    
    static void demonstrateAdvancedNIOFeatures() {
        System.out.println("\n=== Advanced NIO Features ===");
        
        // File watching
        System.out.println("--- File Watching (WatchService) ---");
        System.out.println("WatchService allows monitoring directory changes:");
        System.out.println("  - File creation, modification, deletion");
        System.out.println("  - Asynchronous notification of changes");
        System.out.println("  - Useful for hot-reloading, backup systems");
        
        // Memory-mapped files
        System.out.println("\n--- Memory-Mapped Files ---");
        System.out.println("Memory-mapped files provide:");
        System.out.println("  - Direct memory access to file content");
        System.out.println("  - Better performance for large files");
        System.out.println("  - Shared memory between processes");
        
        // Demonstrate simple memory mapping
        demonstrateMemoryMapping();
        
        // File systems
        System.out.println("\n--- File Systems ---");
        System.out.println("Available file systems:");
        for (FileSystem fs : FileSystems.getDefault().getFileStores()) {
            System.out.println("  " + fs);
        }
        
        // Path matchers
        System.out.println("\n--- Path Matchers ---");
        PathMatcher txtMatcher = FileSystems.getDefault().getPathMatcher("glob:*.txt");
        PathMatcher javaMatcher = FileSystems.getDefault().getPathMatcher("glob:**/*.java");
        
        System.out.println("test.txt matches *.txt: " + txtMatcher.matches(Paths.get("test.txt")));
        System.out.println("src/Main.java matches **/*.java: " + javaMatcher.matches(Paths.get("src/Main.java")));
    }
    
    static void demonstrateMemoryMapping() {
        Path testFile = Paths.get("memory_mapped_test.txt");
        
        try {
            // Create a test file
            String content = "Hello, Memory-Mapped Files! This is a test of direct memory access.";
            Files.write(testFile, content.getBytes());
            
            // Memory-map the file
            try (RandomAccessFile raf = new RandomAccessFile(testFile.toFile(), "rw");
                 java.nio.channels.FileChannel channel = raf.getChannel()) {
                
                java.nio.MappedByteBuffer buffer = channel.map(
                    java.nio.channels.FileChannel.MapMode.READ_WRITE, 0, channel.size());
                
                System.out.println("Memory-mapped file size: " + buffer.capacity() + " bytes");
                
                // Read from memory-mapped buffer
                byte[] data = new byte[buffer.capacity()];
                buffer.get(data);
                System.out.println("Content: " + new String(data));
                
                // Modify through memory mapping
                buffer.position(0);
                buffer.put("HELLO".getBytes()); // Modify first 5 bytes
                buffer.force(); // Force changes to disk
                
                System.out.println("Modified file through memory mapping");
            }
            
            // Verify changes
            String modifiedContent = Files.readString(testFile);
            System.out.println("File content after modification: " + modifiedContent);
            
        } catch (IOException e) {
            System.err.println("Memory mapping error: " + e.getMessage());
        } finally {
            try {
                Files.deleteIfExists(testFile);
            } catch (IOException e) {
                System.err.println("Cleanup error: " + e.getMessage());
            }
        }
    }
}
```

## 4. Best Practices & Pitfalls

**Do's:**
- Use NIO.2 (Files class) for new applications - it's more convenient and performant
- Use Path objects instead of File objects for better cross-platform compatibility
- Specify character encoding explicitly when reading/writing text files
- Use try-with-resources for traditional IO streams
- Use Files.walk() with try-with-resources to ensure stream closure

**Don'ts:**
- Don't mix File and Path APIs unnecessarily (prefer Path consistently)
- Don't assume file operations are atomic (use StandardCopyOption.ATOMIC_MOVE when needed)
- Don't ignore IOException - file operations can fail for many reasons
- Don't use deprecated File methods when Path/Files alternatives exist
- Don't forget to handle platform-specific path separators

**Common Pitfalls:**
- Resource leaks from not closing streams in traditional IO
- Platform-dependent path handling when using string concatenation
- Performance issues from not using buffered streams for frequent operations
- Security issues from not validating file paths (directory traversal attacks)
- Memory leaks from not closing directory streams (Files.walk, Files.list)

## 5. Summary

- **Traditional IO** uses File class and stream-based operations with manual resource management
- **NIO.2** provides Files class with utility methods for convenient file operations
- **Path objects** are more flexible and cross-platform than File objects
- **Files.readAllLines()** and **Files.write()** simplify common file operations
- **Directory operations** include listing, walking, finding, and recursive deletion
- **File attributes** provide metadata like timestamps, permissions, and size information
- **Advanced features** include file watching, memory-mapped files, and path matching
- **NIO.2 is preferred** for new development due to better API design and performance

## 6. Tricky Interview Questions

1. **API Comparison**: Compare traditional File class vs NIO.2 Path/Files API. What are the advantages of each approach?

2. **Path Operations**: How do you safely resolve a relative path against a base path? What security considerations apply?

3. **Directory Traversal**: How do you recursively delete a directory tree using NIO.2? Why is the order of deletion important?

4. **File Attributes**: How do you check and modify file permissions in a cross-platform way? What's the difference between POSIX and non-POSIX systems?

5. **Memory Mapping**: When would you use memory-mapped files instead of regular file IO? What are the benefits and limitations?

6. **Resource Management**: Why do Files.walk() and Files.list() return streams that need to be closed? Show proper usage.

7. **Atomic Operations**: How do you ensure file operations are atomic? What happens if a copy operation fails halfway through?

8. **Performance**: Compare the performance of reading a large file using traditional BufferedReader vs Files.readAllLines() vs Files.lines().

9. **Path Normalization**: What does Path.normalize() do? Give examples of paths that would benefit from normalization.

10. **File Watching**: How would you implement a file monitoring system using WatchService? What events can you monitor and what are the limitations?
