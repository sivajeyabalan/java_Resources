## 1. Topic Overview

- NIO.2 offers modern file APIs: `Path/Files`, channels/buffers, file tree walking, and directory watch service.

## 2 . Topic definition

- WHAT: `java.nio.file` for paths and operations; `FileChannel`/`ByteBuffer`; `WatchService` for file system events.
- WHY: Better performance, scalability, and rich features compared to classic IO.
- HOW: Use `Files` static methods, try-with-resources, channels for large transfers, watch for changes.
- WHEN/WHERE: File processing, ETL, log tailing, large file IO.
- WHAT IF: Wrong charsets and buffer handling cause data corruption.

## 3. Deep Dive with Examples

```java
import java.nio.file.*;
import java.io.IOException;

class WalkCopy {
    public static void main(String[] args) throws IOException {
        Path src = Path.of("src"), dst = Path.of("dst");
        Files.walk(src).forEach(p -> {
            try {
                Path target = dst.resolve(src.relativize(p));
                if (Files.isDirectory(p)) Files.createDirectories(target);
                else Files.copy(p, target, StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException e) { throw new RuntimeException(e); }
        });
    }
}
```

```java
// Channels and ByteBuffers
import java.nio.*; import java.nio.channels.*; import java.nio.file.*; import java.io.*;

class ChannelCopy {
    public static void main(String[] args) throws Exception {
        try (FileChannel in = FileChannel.open(Path.of("in.bin"));
             FileChannel out = FileChannel.open(Path.of("out.bin"), StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            ByteBuffer buf = ByteBuffer.allocateDirect(16 * 1024);
            while (in.read(buf) != -1) { buf.flip(); while (buf.hasRemaining()) out.write(buf); buf.clear(); }
        }
    }
}
```

```java
// WatchService
import java.nio.file.*; import static java.nio.file.StandardWatchEventKinds.*;

class WatchDir {
    public static void main(String[] args) throws Exception {
        WatchService ws = FileSystems.getDefault().newWatchService();
        Path dir = Path.of("watched");
        dir.register(ws, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);
        for (;;) {
            WatchKey key = ws.take();
            for (WatchEvent<?> ev : key.pollEvents()) System.out.println(ev.kind()+": "+ev.context());
            if (!key.reset()) break;
        }
    }
}
```

## 4. Best Practices & Pitfalls

- Use correct charsets; prefer `Files.newBufferedReader/Writer` for text.
- Prefer direct buffers for large transfers; respect OS limits.
- Debounce WatchService events if needed; handle overflow.

## 5. Summary

- NIO.2 provides robust, efficient file handling and monitoring for modern Java apps.

## 6. Tricky Interview Questions

1. Compare stream vs channel IO and when to choose each.
2. How do you reliably monitor directories with `WatchService` across platforms?

