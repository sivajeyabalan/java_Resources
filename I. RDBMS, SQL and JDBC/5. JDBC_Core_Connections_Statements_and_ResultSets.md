## 1. Topic Overview

- JDBC provides a standard API to connect Java applications to relational databases, execute SQL, and process results.

## 2 . Topic definition

- WHAT: Drivers, `DriverManager`, `Connection`, `Statement`, `PreparedStatement`, `ResultSet`, `ResultSetMetaData`.
- WHY: Database-agnostic data access, safe parameter binding, and robust result handling.
- HOW: Load driver, obtain `Connection`, prepare/execute SQL, iterate `ResultSet`, close resources.
- WHEN/WHERE: Any Java app needing direct SQL access.
- WHAT IF: String concatenation causes SQL injection; forgetting to close resources leaks connections.

## 3. Deep Dive with Examples

```java
import java.sql.*;

public class JdbcBasics {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1";
        try (Connection con = DriverManager.getConnection(url);
             Statement st = con.createStatement()) {
            st.executeUpdate("create table users(id int primary key, name varchar(50))");
            st.executeUpdate("insert into users values(1,'Ann'),(2,'Bob')");

            try (ResultSet rs = st.executeQuery("select * from users")) {
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    System.out.println(id + ": " + name);
                }
            }
        }
    }
}
```

```java
// PreparedStatement with parameters and metadata
import java.sql.*;

public class PreparedDemo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:h2:mem:prep;DB_CLOSE_DELAY=-1";
        try (Connection con = DriverManager.getConnection(url)) {
            try (Statement s = con.createStatement()) {
                s.executeUpdate("create table emp(id int primary key, sal decimal(10,2))");
            }
            try (PreparedStatement ps = con.prepareStatement("insert into emp values(?,?)")) {
                ps.setInt(1, 1);
                ps.setBigDecimal(2, new java.math.BigDecimal("1000.50"));
                ps.executeUpdate();
            }
            try (PreparedStatement ps = con.prepareStatement("select * from emp where sal > ?")) {
                ps.setBigDecimal(1, new java.math.BigDecimal("900"));
                try (ResultSet rs = ps.executeQuery()) {
                    ResultSetMetaData md = rs.getMetaData();
                    for (int i = 1; i <= md.getColumnCount(); i++) {
                        System.out.println(md.getColumnName(i) + " (" + md.getColumnTypeName(i) + ")");
                    }
                }
            }
        }
    }
}
```

## 4. Best Practices & Pitfalls

- Always use `PreparedStatement` for user input; avoid building SQL strings.
- Close resources with try-with-resources in the smallest scope.
- Use column names over indices for readability; cache indices if hot path.

## 5. Summary

- JDBC core involves obtaining connections, using prepared statements, and iterating result sets safely.

## 6. Tricky Interview Questions

1. Contrast `Statement` vs `PreparedStatement` and their performance/security implications.
2. How do you retrieve column names and types from a `ResultSet`?
3. What happens if you forget to close a `ResultSet`/`Statement`?

