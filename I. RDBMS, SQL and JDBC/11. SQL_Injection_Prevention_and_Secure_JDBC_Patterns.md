## 1. Topic Overview

- Prevent SQL injection and write secure JDBC by design: parameter binding, whitelisting, least privilege, and safe logging.

## 2 . Topic definition

- WHAT: SQL injection occurs when untrusted input alters query structure.
- WHY: Leads to data theft or corruption.
- HOW: Use `PreparedStatement`, whitelist dynamic parts, use stored procedures carefully, escape like literals correctly.
- WHEN/WHERE: All user-influenced queries.
- WHAT IF: Concatenating inputs into SQL risks injection even when escaped incorrectly.

## 3. Deep Dive with Examples

```java
// Vulnerable
String q = "select * from users where name='" + userInput + "'"; // BAD
```

```java
// Safe parameter binding
try (PreparedStatement ps = con.prepareStatement("select * from users where name=? and status=?")) {
    ps.setString(1, userInput);
    ps.setString(2, "ACTIVE");
}
```

```java
// Whitelisting dynamic ORDER BY
String sort = List.of("name","created_at").contains(userSort) ? userSort : "name";
String sql = "select * from users order by " + sort + " desc";
```

Additional patterns:
- Use least-privilege DB accounts; separate read/write users.
- Avoid logging full SQL with secrets; use placeholders.
- Validate length/charset of inputs; parameterize LIKE with escaped wildcards where supported.

## 4. Best Practices & Pitfalls

- Never build SQL by concatenating untrusted input; even table/column names must be whitelisted.
- Use `setObject` with explicit SQL types when necessary; avoid implicit conversions surprises.
- Consider ORMs or query builders that enforce binding by default.

## 5. Summary

- Secure JDBC centers on parameter binding and strict whitelisting, backed by least privilege and careful logging.

## 6. Tricky Interview Questions

1. How do you safely implement dynamic filtering and sorting with user inputs?
2. Why isnâ€™t escaping quotes sufficient protection against SQL injection?

