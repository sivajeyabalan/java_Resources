## 1. Topic Overview

- Build a small CRUD mini-project using JDBC with DAO pattern, transactions, and batch operations on an in-memory H2 database.

## 2 . Topic definition

- WHAT: DAO encapsulates persistence logic; operations include create, read, update, delete with transaction handling and batch inserts.
- WHY: Structure code cleanly, improve testability, and demonstrate real-world JDBC patterns.
- HOW: Model `User{id, name, email}`, create `UserDao` with CRUD, configure H2, and implement batch insert with rollback on error.
- WHEN/WHERE: Foundational pattern before moving to ORM frameworks like JPA/Hibernate.
- WHAT IF: Without transactions, partial updates lead to inconsistent state; without prepared statements, risk SQL injection.

## 3. Deep Dive with Examples

```java
// pom-less standalone examples use H2 in-memory; adapt to your build if needed
import java.sql.*;
import java.util.*;

record User(int id, String name, String email) {}

class DataSourceProvider {
    static Connection getConnection() throws SQLException {
        return DriverManager.getConnection("jdbc:h2:mem:mini;DB_CLOSE_DELAY=-1");
    }
}

class Schema {
    static void init() throws SQLException {
        try (Connection con = DataSourceProvider.getConnection(); Statement st = con.createStatement()) {
            st.executeUpdate("create table users(id int primary key, name varchar(50), email varchar(100) unique)");
        }
    }
}

class UserDao {
    public void create(User u) throws SQLException {
        try (Connection con = DataSourceProvider.getConnection();
             PreparedStatement ps = con.prepareStatement("insert into users(id,name,email) values(?,?,?)")) {
            ps.setInt(1, u.id()); ps.setString(2, u.name()); ps.setString(3, u.email());
            ps.executeUpdate();
        }
    }

    public Optional<User> findById(int id) throws SQLException {
        try (Connection con = DataSourceProvider.getConnection();
             PreparedStatement ps = con.prepareStatement("select * from users where id=?")) {
            ps.setInt(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) return Optional.of(new User(rs.getInt("id"), rs.getString("name"), rs.getString("email")));
                return Optional.empty();
            }
        }
    }

    public int updateEmail(int id, String email) throws SQLException {
        try (Connection con = DataSourceProvider.getConnection();
             PreparedStatement ps = con.prepareStatement("update users set email=? where id=?")) {
            ps.setString(1, email); ps.setInt(2, id);
            return ps.executeUpdate();
        }
    }

    public int delete(int id) throws SQLException {
        try (Connection con = DataSourceProvider.getConnection();
             PreparedStatement ps = con.prepareStatement("delete from users where id=?")) {
            ps.setInt(1, id);
            return ps.executeUpdate();
        }
    }

    public void batchInsert(List<User> users) throws SQLException {
        try (Connection con = DataSourceProvider.getConnection();
             PreparedStatement ps = con.prepareStatement("insert into users(id,name,email) values(?,?,?)")) {
            con.setAutoCommit(false);
            try {
                for (User u : users) {
                    ps.setInt(1, u.id()); ps.setString(2, u.name()); ps.setString(3, u.email());
                    ps.addBatch();
                }
                ps.executeBatch();
                con.commit();
            } catch (SQLException e) {
                con.rollback();
                throw e;
            } finally {
                con.setAutoCommit(true);
            }
        }
    }
}

public class JdbcMiniProject {
    public static void main(String[] args) throws Exception {
        Schema.init();
        UserDao dao = new UserDao();
        dao.create(new User(1, "Ann", "ann@example.com"));
        dao.batchInsert(List.of(
            new User(2, "Bob", "bob@example.com"),
            new User(3, "Cat", "cat@example.com")
        ));
        System.out.println(dao.findById(2));
        dao.updateEmail(2, "bob2@example.com");
        dao.delete(3);
    }
}
```

## 4. Best Practices & Pitfalls

- Keep DAO methods small and cohesive; return domain types, not JDBC types.
- Always use prepared statements and transactions for multi-step operations.
- Centralize connection acquisition to ease migration to a pool/DataSource.

## 5. Summary

- This mini-project demonstrates clean JDBC with DAO, transactions, and batch operations.

## 6. Tricky Interview Questions

1. How would you refactor this DAO to use a connection pool transparently?
2. How to handle unique constraint violations and map them to domain errors?

