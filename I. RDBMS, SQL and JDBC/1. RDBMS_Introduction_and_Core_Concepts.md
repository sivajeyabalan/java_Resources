## 1. Topic Overview

Relational Database Management Systems (RDBMS) store data in tables (relations) with rows (tuples) and columns (attributes). They enforce relationships using keys and constraints and provide a declarative language, SQL, to query and manipulate data. Understanding core relational concepts like schema, keys, normalization, and relational algebra is essential to design, query, and maintain consistent data.

## 2 . Topic definition

- **What**: RDBMS is a DBMS based on the relational model where data is organized as related tables.
- **Why**: Ensures data integrity, reduces redundancy, supports ACID transactions, enables powerful querying with SQL.
- **How**: Through schemas, tables, constraints, and a query processor that optimizes and executes SQL; a storage engine manages files, indexes, buffers, and transactions.
- **When/Where**: Business apps, financial systems, ERPs, CRMs, analytics backends—any system demanding consistency and structured data.
- **What If**:
  - Without RDBMS: ad‑hoc files, redundancy, inconsistency, difficult concurrency control.
  - Poor schema design: anomalies (insert/update/delete), performance issues, integrity problems.
  - No constraints: orphan records, duplicates, broken references.
- **Examples**: Oracle, PostgreSQL, MySQL, SQL Server, DB2.

Key terms
- **Database**: Named collection of related data and metadata.
- **Schema**: Logical structure defining tables, columns, constraints.
- **Table (Relation)**: Rows and columns storing entity instances.
- **Tuple/Row**: One record; **Attribute/Column**: data field.
- **Degree**: Number of columns; **Cardinality**: number of rows.
- **Keys**: Candidate, Primary, Unique, Foreign, Surrogate; **Super key**: any superset uniquely identifying a row.
- **Constraints**: NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK, DEFAULT.
- **Metadata**: Data about data (schemas, columns, types, privileges, indexes).
- **ACID**: Atomicity, Consistency, Isolation, Durability.
- **Normalization**: Organizing data to minimize redundancy (1NF, 2NF, 3NF, BCNF).

## 3. Deep Dive with Examples

```sql
-- Create two related tables with constraints
CREATE TABLE departments (
  dept_id NUMBER PRIMARY KEY,
  name    VARCHAR2(50) NOT NULL UNIQUE
);

CREATE TABLE employees (
  emp_id     NUMBER PRIMARY KEY,
  first_name VARCHAR2(30) NOT NULL,
  last_name  VARCHAR2(30) NOT NULL,
  dept_id    NUMBER NOT NULL,
  salary     NUMBER(10,2) CHECK (salary >= 0),
  CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id)
    REFERENCES departments(dept_id)
);

-- Insert data
INSERT INTO departments VALUES (10, 'Sales');
INSERT INTO departments VALUES (20, 'Engineering');
INSERT INTO employees VALUES (1, 'Ada', 'Lovelace', 20, 120000);
INSERT INTO employees VALUES (2, 'Grace', 'Hopper', 10, 110000);

-- Simple select with projection and selection
SELECT first_name, last_name
FROM employees
WHERE dept_id = 20;

-- Join
SELECT e.first_name, e.last_name, d.name AS department
FROM employees e
JOIN departments d ON d.dept_id = e.dept_id;

-- Primary vs foreign key integrity (violates FK)
-- INSERT INTO employees VALUES (3, 'Alan', 'Turing', 30, 130000); -- Fails: 30 not in departments
```

### Anomalies and Normalization quick look
- In 1NF: no repeating groups; atomic values.
- In 2NF: no partial dependency on a composite key.
- In 3NF: no transitive dependency on non‑key attributes.

```sql
-- Example of denormalization causing update anomalies
-- Suppose employees table had department name column too
-- Updating department name would need multiple row updates → risk of inconsistency
```

## 4. Best Practices & Pitfalls

- Do: model with clear primary keys and foreign keys.
- Do: enforce constraints; let the database guarantee integrity.
- Do: normalize for OLTP; denormalize judiciously for analytics.
- Do: index selective columns used in joins/filters.
- Don't: store derived data unless necessary; if stored, keep it consistent.
- Don't: let application enforce referential integrity alone.
- Pitfalls: missing constraints, wide NULLable schemas, over‑indexing, no plan for transactions/concurrency.

## 5. Summary

- Tables, keys, constraints, and ACID underpin RDBMS.
- Normalization prevents anomalies; constraints enforce integrity.
- SQL provides projection, selection, join, aggregation.

## 6. Tricky Interview Questions

1. Explain candidate vs primary vs super vs surrogate keys with examples.
2. What anomalies can appear without normalization? Give a scenario.
3. How do foreign keys enforce referential integrity? Can they be deferred?
4. How does the query processor optimize SQL? What is a plan?
5. Trade‑offs of normalization vs denormalization in OLTP vs OLAP.


