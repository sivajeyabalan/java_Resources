## 1. Topic Overview

- Transactions ensure atomicity and consistency; batching improves performance; savepoints allow partial rollbacks.

## 2 . Topic definition

- WHAT: ACID, isolation levels, auto-commit, `commit`, `rollback`, `Savepoint`, batch updates.
- WHY: Ensure correctness across multiple statements and reduce round trips.
- HOW: Disable auto-commit, perform operations, commit/rollback; use `addBatch`/`executeBatch`; manage savepoints for granular rollback.
- WHEN/WHERE: Multi-step operations needing all-or-nothing semantics; bulk inserts/updates.
- WHAT IF: Wrong isolation causes anomalies; forgetting to reset auto-commit or to close on failure leaks connections.

## 3. Deep Dive with Examples

```java
import java.sql.*;

public class TxBatchDemo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:h2:mem:tx;DB_CLOSE_DELAY=-1";
        try (Connection con = DriverManager.getConnection(url)) {
            try (Statement s = con.createStatement()) {
                s.executeUpdate("create table acc(id int primary key, bal int)");
                s.executeUpdate("insert into acc values(1,100),(2,100)");
            }
            con.setAutoCommit(false);
            Savepoint sp = null;
            try (PreparedStatement debit = con.prepareStatement("update acc set bal = bal - ? where id=?");
                 PreparedStatement credit = con.prepareStatement("update acc set bal = bal + ? where id=?")) {
                debit.setInt(1, 50); debit.setInt(2, 1); debit.executeUpdate();
                sp = con.setSavepoint("after_debit");
                credit.setInt(1, 50); credit.setInt(2, 2); credit.executeUpdate();
                con.commit();
            } catch (Exception e) {
                if (sp != null) con.rollback(sp); // rollback to savepoint
                con.rollback();
            } finally {
                con.setAutoCommit(true);
            }

            // Batch insert
            try (PreparedStatement ps = con.prepareStatement("insert into acc values(?,?)")) {
                con.setAutoCommit(false);
                for (int i = 3; i <= 10; i++) {
                    ps.setInt(1, i);
                    ps.setInt(2, 100);
                    ps.addBatch();
                }
                ps.executeBatch();
                con.commit();
                con.setAutoCommit(true);
            }
        }
    }
}
```

Isolation levels:
- READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE.
- Set via `con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED)`.

## 4. Best Practices & Pitfalls

- Keep transactions short; set appropriate isolation; handle retries for deadlocks/timeouts.
- Use batch size limits; clear parameters between batches if reusing statements.
- Always restore auto-commit in finally and close resources on errors.

## 5. Summary

- Transactions guarantee atomicity; batches boost throughput; savepoints offer granular control.

## 6. Tricky Interview Questions

1. How do isolation levels impact phenomena like dirty/non-repeatable reads and phantom reads?
2. Show a safe transfer with rollback on failure using savepoints.
3. How would you size and tune batch operations?

