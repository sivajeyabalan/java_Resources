## 1. Topic Overview

Restricting and sorting data are core SELECT skills. Restricting uses the WHERE clause to filter rows; sorting uses ORDER BY to define result order. Mastery includes predicates, operator precedence, NULL handling, and collation.

## 2 . Topic definition

- **What**: Restrict rows with `WHERE`; sort rows with `ORDER BY`.
- **Why**: Improve correctness and performance by returning only relevant, properly ordered data.
- **How**: Use predicates (`=, <>, >, >=, <, <=`), logical operators (`AND, OR, NOT`), pattern matching (`LIKE`), set membership (`IN`), ranges (`BETWEEN`), and null checks (`IS NULL/IS NOT NULL`).
- **When/Where**: All queries needing filters or stable presentation order.
- **What If**: Missing filters cause full scans; wrong operator precedence changes results; ordering without indexes can be expensive.

## 3. Deep Dive with Examples

```sql
-- Sample data
CREATE TABLE products (
  product_id NUMBER PRIMARY KEY,
  name       VARCHAR2(100) NOT NULL,
  price      NUMBER(10,2),
  category   VARCHAR2(50),
  created_at DATE DEFAULT SYSDATE
);

-- Basic comparisons
SELECT * FROM products WHERE price > 1000;

-- Equality and inequality
SELECT * FROM products WHERE category = 'Electronics';
SELECT * FROM products WHERE category <> 'Grocery';

-- Logical operators and precedence (NOT > AND > OR)
SELECT * FROM products WHERE category = 'Electronics' AND price < 500;
SELECT * FROM products WHERE category = 'Electronics' OR category = 'Gadgets' AND price < 500; -- beware precedence
SELECT * FROM products WHERE (category IN ('Electronics','Gadgets')) AND price < 500; -- explicit

-- BETWEEN / IN / LIKE / NULL
SELECT * FROM products WHERE price BETWEEN 100 AND 300;
SELECT * FROM products WHERE category IN ('Books','Games','Toys');
SELECT * FROM products WHERE name LIKE 'Mac%';      -- starts with
SELECT * FROM products WHERE name LIKE '%Pro%';     -- contains
SELECT * FROM products WHERE name LIKE '___%';      -- underscores for single char
SELECT * FROM products WHERE price IS NULL;         -- NULL safe check

-- Date filters
SELECT * FROM products WHERE created_at >= DATE '2024-01-01';

-- ORDER BY
SELECT product_id, name, price FROM products ORDER BY price DESC, name ASC;

-- ORDER BY with expressions and positions (use names for clarity)
SELECT name, price, price*1.18 AS price_with_tax
FROM products
ORDER BY price_with_tax DESC, name;

-- Collation and case sensitivity considerations
-- In Oracle, default comparisons may be case sensitive depending on NLS settings.

-- Handling NULLS in ORDER BY (Oracle)
SELECT name, price FROM products ORDER BY price DESC NULLS LAST;
SELECT name, price FROM products ORDER BY price ASC  NULLS FIRST;

-- Avoiding implicit conversions (e.g., comparing numbers to strings)
-- WHERE price = '100' -- may cause implicit conversion and index miss
```

## 4. Best Practices & Pitfalls

- Do: use parentheses to control precedence with AND/OR.
- Do: use sargable predicates (search‑ARGument ABLE) to enable index usage.
- Do: prefer `IS NULL`/`IS NOT NULL` for null checks.
- Don't: wrap indexed column in functions in WHERE unless using function‑based indexes.
- Don't: rely on implicit type conversions.
- Pitfalls: unexpected results from OR precedence, NULL ordering surprises, locale/collation impacts on string sorting.

## 5. Summary

- WHERE filters rows; ORDER BY defines presentation order.
- Operator precedence matters; use parentheses for clarity.
- Handle NULLs explicitly in ORDER BY in Oracle using `NULLS FIRST/LAST`.

## 6. Tricky Interview Questions

1. Explain operator precedence in WHERE and how to avoid mistakes.
2. What is a sargable predicate? Give examples and counter‑examples.
3. How are NULLs treated in comparisons and ordering in Oracle?
4. Why can `LIKE '%pattern%'` be slow? How to optimize?
5. How do implicit conversions affect index usage? Provide an example.


